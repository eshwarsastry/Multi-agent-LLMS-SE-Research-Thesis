{
  "AccessGatewayFilter": "import time\n\nclass User:\n    def __init__(self, name, level, address):\n        self.name = name\n        self.level = level\n        self.address = address\n\nclass Authorization:\n    def __init__(self, user, jwt):\n        self.user = user\n        self.jwt = jwt\n\nclass Request:\n    def __init__(self, path, method, auth):\n        self.path = path\n        self.method = method\n        self.auth = auth\n\nclass AccessGatewayFilter:\n    def filter(self, request):\n        request_uri = request.path\n        method = request.method\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception:\n            return False\n        return False\n\n    def is_start_with(self, request_uri):\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request.auth\n        user = token.user\n\n        if token.jwt.startswith(user.name):\n            jwt_str_date = token.jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if now - jwt_timestamp >= 3 * 24 * 60 * 60:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return token\n\n    def set_current_user_info_and_log(self, user):\n        print(f\"{user.name} {user.address} {int(time.time())}\")\n",
  "AreaCalculator": "import math\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise ValueError(\"Height cannot be negative.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise ValueError(\"Inner radius cannot be greater than outer radius.\")\n        return math.pi * (outer_radius * outer_radius - inner_radius * inner_radius)\n",
  "ArgumentParser": "import re\nfrom typing import Tuple, Set, Dict, Callable\n\nclass ArgumentParser:\n    def __init__(self):\n        self.arguments: Dict[str, str] = {}\n        self.required: Set[str] = set()\n        self.types: Dict[str, str] = {}\n        self.type_converters: Dict[str, Callable[[str], str]] = {}\n        self.initialize_converters()\n\n    def parse_arguments(self, command_string: str) -> Tuple[bool, Set[str]]:\n        words = command_string.split()\n        if words:\n            words.pop(0)\n\n        for word in words:\n            if word.startswith(\"--\"):\n                key_value = word[2:]\n                key, _, value = key_value.partition('=')\n                value = value if value else \"1\"\n                self.arguments[key] = self.convert_type(key, value)\n            elif word.startswith(\"-\"):\n                key = word[1]\n                value = \"\"\n                if words and not words[0].startswith('-'):\n                    value = words.pop(0)\n                self.arguments[key] = self.convert_type(key, value if value else \"1\")\n\n        missing_args = self.required - self.arguments.keys()\n        return len(missing_args) == 0, missing_args\n\n    def get_argument(self, key: str) -> str:\n        return self.arguments.get(key, \"\")\n\n    def add_argument(self, arg: str, required: bool = False, type: str = \"string\"):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = type\n\n    def convert_type(self, arg: str, value: str) -> str:\n        if arg not in self.types:\n            return value\n        converter = self.type_converters.get(self.types[arg])\n        if converter:\n            return converter(value)\n        return value\n\n    def initialize_converters(self):\n        self.type_converters[\"int\"] = lambda value: str(int(value)) if value.isdigit() else value\n        self.type_converters[\"bool\"] = lambda value: \"1\" if value.lower() == \"true\" else \"0\" if value.lower() == \"false\" else value\n",
  "ArrangementCalculator": "from typing import List\n\nclass ArrangementCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int = -1) -> int:\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m: int = -1) -> List[List[str]]:\n        result = []\n        if m == -1:\n            m = len(self.datas)\n\n        current = []\n        remaining = self.datas\n\n        self.permutations_recursive(current, remaining, m, result)\n\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            partial_result = self.select(i)\n            result.extend(partial_result)\n        return result\n\n    def permutations_recursive(self, current: List[str], remaining: List[str], m: int, result: List[List[str]]) -> None:\n        if len(current) == m:\n            result.append(current)\n        else:\n            for i in range(len(remaining)):\n                new_current = current + [remaining[i]]\n                new_remaining = remaining[:i] + remaining[i+1:]\n                self.permutations_recursive(new_current, new_remaining, m, result)\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n",
  "AssessmentSystem": "from typing import Optional, List, Dict\n\nclass Student:\n    def __init__(self, grade: int, major: str):\n        self.grade = grade\n        self.major = major\n        self.courses: Dict[str, int] = {}\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Student] = {}\n\n    def add_student(self, name: str, grade: int, major: str):\n        self.students[name] = Student(grade, major)\n\n    def add_course_score(self, name: str, course: str, score: int):\n        if name in self.students:\n            self.students[name].courses[course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student.courses:\n            total_score = sum(student.courses.values())\n            return total_score / len(student.courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for name, student in self.students.items():\n            if any(score < 60 for score in student.courses.values()):\n                students_with_fail.append(name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student.courses:\n                total += student.courses[course]\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n",
  "AutomaticGuitarSimulator": "import re\n\nclass PlayItem:\n    def __init__(self, chord, tune):\n        self.Chord = chord\n        self.Tune = tune\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        if not self.play_text:\n            return play_list\n\n        for play_seg in self.play_text.split():\n            match = re.match(r'([a-zA-Z]+)(\\d+)', play_seg)\n            if match:\n                play_chord, play_value = match.groups()\n                item = PlayItem(play_chord, play_value)\n                play_list.append(item)\n\n                if display:\n                    print(self.format_display(play_chord, play_value))\n        return play_list\n\n    def format_display(self, key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def get(self, index):\n        size, remainder = self.set_num()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        return self.lst[start:end]\n",
  "BalancedBrackets": "class BalancedBrackets:\n    def __init__(self, expr: str):\n        self.expr = expr\n        self.stack = []\n        self.left_brackets = \"({[\"\n        self.right_brackets = \")}]\"\n\n    def clear_expr(self):\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets or c in self.right_brackets)\n\n    def check_balanced_brackets(self) -> bool:\n        self.clear_expr()\n        for brkt in self.expr:\n            if brkt in self.left_brackets:\n                self.stack.append(brkt)\n            else:\n                if not self.stack:\n                    return False\n                current_brkt = self.stack.pop()\n                if (current_brkt == '(' and brkt != ')') or \\\n                   (current_brkt == '{' and brkt != '}') or \\\n                   (current_brkt == '[' and brkt != ']'):\n                    return False\n        return not self.stack\n",
  "BankAccount": "class BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)\n",
  "BigNumCalculator": "class BigNumCalculator:\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        max_length = max(len(num1), len(num2))\n        num1_padded = num1.zfill(max_length)\n        num2_padded = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = (ord(num1_padded[i]) - ord('0')) + (ord(num2_padded[i]) - ord('0')) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.append(chr(digit + ord('0')))\n\n        if carry > 0:\n            result.append(chr(carry + ord('0')))\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        num1_local = num1\n        num2_local = num2\n        negative = False\n\n        if len(num1_local) < len(num2_local) or (len(num1_local) == len(num2_local) and num1_local < num2_local):\n            num1_local, num2_local = num2_local, num1_local\n            negative = True\n\n        max_length = max(len(num1_local), len(num2_local))\n        num1_local = num1_local.zfill(max_length)\n        num2_local = num2_local.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = (ord(num1_local[i]) - ord('0')) - (ord(num2_local[i]) - ord('0')) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.append(chr(digit_diff + ord('0')))\n\n        while len(result) > 1 and result[-1] == '0':\n            result.pop()\n\n        if negative:\n            result.append('-')\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        len1 = len(num1)\n        len2 = len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1 = i + j\n                p2 = i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        leading_zero = True\n        result_str = []\n        for num in result:\n            if num == 0 and leading_zero:\n                continue\n            leading_zero = False\n            result_str.append(str(num))\n\n        return ''.join(result_str) if result_str else '0'\n"
}
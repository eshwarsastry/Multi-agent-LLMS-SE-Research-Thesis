{
  "AccessGatewayFilter": "import time\nfrom datetime import datetime\n\nclass User:\n    def __init__(self, name, level, address):\n        self.name = name\n        self.level = level\n        self.address = address\n\n\nclass Authorization:\n    def __init__(self, user, jwt):\n        self.user = user\n        self.jwt = jwt\n\n\nclass Request:\n    def __init__(self, path, method, auth):\n        self.path = path\n        self.method = method\n        self.auth = auth\n\n\nclass AccessGatewayFilter:\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        request_uri = request.path\n        method = request.method\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception as e:\n            print(f\"Exception occurred: {e}\")\n            return False\n        return False\n\n    @staticmethod\n    def is_start_with(request_uri):\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request.auth\n        user = token.user\n\n        if token.jwt.startswith(user.name):\n            jwt_str_date = token.jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if now - jwt_timestamp >= 72 * 60 * 60:  # 72 hours in seconds\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return token\n\n    @staticmethod\n    def set_current_user_info_and_log(user):\n        current_time = int(time.time())\n        print(f\"{user.name} {user.address} {current_time}\")\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    user = User(\"JohnDoe\", 3, \"123 Main St\")\n    auth = Authorization(user, \"JohnDoe1633072800\")  # Example JWT with a valid timestamp\n    request = Request(\"/some/path\", \"GET\", auth)\n\n    filter_instance = AccessGatewayFilter()\n    result = filter_instance.filter(request)\n    print(f\"Request filtered: {result}\")\n",
  "AreaCalculator": "import math\nimport unittest\n\nM_PI = 3.14159265358979323846\n\nclass InvalidArgumentError(Exception):\n    pass\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise InvalidArgumentError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return M_PI * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * M_PI * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise InvalidArgumentError(\"Height cannot be negative.\")\n        return 2 * M_PI * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise InvalidArgumentError(\"Inner radius cannot be greater than outer radius.\")\n        return M_PI * (outer_radius * outer_radius - inner_radius * inner_radius)\n\n\n# Unit tests\nclass TestAreaCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = AreaCalculator(5)\n\n    def test_calculate_circle_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_circle_area(), 78.53981633974483)\n\n    def test_calculate_sphere_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_sphere_area(), 314.1592653589793)\n\n    def test_calculate_cylinder_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_cylinder_area(10), 471.23889803846896)\n        with self.assertRaises(InvalidArgumentError):\n            self.calculator.calculate_cylinder_area(-1)\n\n    def test_calculate_sector_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_sector_area(math.pi / 2), 19.634954084936208)\n\n    def test_calculate_annulus_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_annulus_area(3, 5), 50.26548245743669)\n        with self.assertRaises(InvalidArgumentError):\n            self.calculator.calculate_annulus_area(6, 5)\n\n    def test_invalid_radius(self):\n        with self.assertRaises(InvalidArgumentError):\n            AreaCalculator(-1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "ArgumentParser": "import re\n\nclass ArgumentParser:\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n        self.type_converters = {}\n        self.initialize_converters()\n\n    def parse_arguments(self, command_string):\n        words = command_string.split()\n        if not words:\n            return True, set()\n\n        # Skip the first word which is usually the program name\n        words = words[1:]\n\n        for word in words:\n            if word.startswith('--'):\n                key_value = word[2:]\n                match = re.match(r'([^=]+)(=(.*))?', key_value)\n                if match:\n                    key, _, value = match.groups()\n                    value = value if value is not None else \"1\"\n                    self.arguments[key] = self.convert_type(key, value)\n            elif word.startswith('-'):\n                key = word[1:]\n                next_word = words[words.index(word) + 1] if words.index(word) + 1 < len(words) else \"\"\n                if next_word and not next_word.startswith('-'):\n                    value = next_word\n                    self.arguments[key] = self.convert_type(key, value)\n                    # Skip the next word as it's already processed\n                    words.pop(words.index(word) + 1)\n                else:\n                    self.arguments[key] = self.convert_type(key, \"1\")\n\n        missing_args = self.required - self.arguments.keys()\n        return not missing_args, missing_args\n\n    def get_argument(self, key):\n        return self.arguments.get(key, \"\")\n\n    def add_argument(self, arg, required=False, arg_type=\"string\"):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def convert_type(self, arg, value):\n        if arg not in self.types:\n            return value\n        converter = self.type_converters.get(self.types[arg])\n        if converter:\n            return converter(value)\n        return value\n\n    def initialize_converters(self):\n        self.type_converters[\"int\"] = lambda value: str(int(value)) if value.isdigit() else value\n        self.type_converters[\"bool\"] = lambda value: \"1\" if value.lower() in [\"true\", \"1\"] else \"0\" if value.lower() in [\"false\", \"0\"] else value\n\n# Example usage:\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument(\"verbose\", False, \"bool\")\n    parser.add_argument(\"count\", True, \"int\")\n    result, missing = parser.parse_arguments(\"program --verbose=True -c 5\")\n    print(\"Parsed:\", parser.arguments)\n    print(\"Missing:\", missing)\n",
  "ArrangementCalculator": "from typing import List\n\nclass ArrangementCalculator:\n    def __init__(self, datas: List[str]):\n        self._datas = datas\n\n    @staticmethod\n    def count(n: int, m: int = -1) -> int:\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m: int = -1) -> List[List[str]]:\n        result = []\n        if m == -1:\n            m = len(self._datas)\n\n        current = []\n        remaining = self._datas.copy()\n\n        self._permutations_recursive(current, remaining, m, result)\n\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self._datas) + 1):\n            partial_result = self.select(i)\n            result.extend(partial_result)\n        return result\n\n    def _permutations_recursive(self, current: List[str], remaining: List[str], m: int, result: List[List[str]]) -> None:\n        if len(current) == m:\n            result.append(current.copy())\n        else:\n            for i in range(len(remaining)):\n                new_current = current + [remaining[i]]\n                new_remaining = remaining[:i] + remaining[i+1:]\n                self._permutations_recursive(new_current, new_remaining, m, result)\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n",
  "AssessmentSystem": "from typing import Optional, List, Dict\n\n\nclass Student:\n    def __init__(self, grade: int, major: str):\n        self.grade = grade\n        self.major = major\n        self.courses: Dict[str, int] = {}\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Student] = {}\n\n    def add_student(self, name: str, grade: int, major: str) -> None:\n        self.students[name] = Student(grade, major)\n\n    def add_course_score(self, name: str, course: str, score: int) -> None:\n        if name in self.students:\n            self.students[name].courses[course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student.courses:\n            total_score = sum(student.courses.values())\n            return total_score / len(student.courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for name, student in self.students.items():\n            if any(score < 60 for score in student.courses.values()):\n                students_with_fail.append(name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student.courses:\n                total += student.courses[course]\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    system = AssessmentSystem()\n    system.add_student(\"Alice\", 3, \"Computer Science\")\n    system.add_student(\"Bob\", 2, \"Mathematics\")\n\n    system.add_course_score(\"Alice\", \"Math\", 85)\n    system.add_course_score(\"Alice\", \"Programming\", 90)\n    system.add_course_score(\"Bob\", \"Math\", 75)\n    system.add_course_score(\"Bob\", \"Physics\", 55)\n\n    print(system.get_gpa(\"Alice\"))  # Output: 87.5\n    print(system.get_all_students_with_fail_course())  # Output: ['Bob']\n    print(system.get_course_average(\"Math\"))  # Output: 80.0\n    print(system.get_top_student())  # Output: 'Alice'\n",
  "AutomaticGuitarSimulator": "import re\n\nclass PlayItem:\n    def __init__(self, chord, tune):\n        self.chord = chord\n        self.tune = tune\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        if not self.play_text:\n            return play_list\n\n        # Split the play_text into segments based on spaces\n        play_segments = self.play_text.split()\n\n        for play_seg in play_segments:\n            # Find the position where non-alphabetic character starts\n            match = re.match(r\"[A-Za-z]+\", play_seg)\n            if match:\n                pos = match.end()\n                play_chord = play_seg[:pos]\n                play_value = play_seg[pos:]\n            else:\n                play_chord = \"\"\n                play_value = play_seg\n\n            item = PlayItem(play_chord, play_value)\n            play_list.append(item)\n\n            if display:\n                print(self.format_display(play_chord, play_value))\n\n        return play_list\n\n    def format_display(self, key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n\n# Example usage:\n# simulator = AutomaticGuitarSimulator(\"C4 D5 E6\")\n# play_items = simulator.interpret(display=True)\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def get(self, index):\n        size, remainder = self.set_num()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        return self.lst[start:end]\n\n# Example usage:\n# avg_partition = AvgPartition([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)\n# print(avg_partition.set_num())  # Output: (3, 0)\n# print(avg_partition.get(0))     # Output: [1, 2, 3]\n# print(avg_partition.get(1))     # Output: [4, 5, 6]\n# print(avg_partition.get(2))     # Output: [7, 8, 9]\n",
  "BalancedBrackets": "class BalancedBrackets:\n    def __init__(self, expr):\n        self.expr = expr\n        self.stack = []\n        self.left_brackets = \"({[\"\n        self.right_brackets = \")}]\"\n\n    def clear_expr(self):\n        # Remove all non-bracket characters from the expression\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets or c in self.right_brackets)\n\n    def check_balanced_brackets(self):\n        self.clear_expr()\n        for brkt in self.expr:\n            if brkt in self.left_brackets:\n                self.stack.append(brkt)\n            else:\n                if not self.stack:\n                    return False\n                current_brkt = self.stack.pop()\n                if (current_brkt == '(' and brkt != ')') or \\\n                   (current_brkt == '{' and brkt != '}') or \\\n                   (current_brkt == '[' and brkt != ']'):\n                    return False\n        return not self.stack\n\n# Example usage:\n# balanced_brackets_checker = BalancedBrackets(\"{[()]}\")\n# print(balanced_brackets_checker.check_balanced_brackets())  # Output: True\n",
  "BankAccount": "class InvalidAmountError(Exception):\n    \"\"\"Custom exception for invalid amounts.\"\"\"\n    pass\n\nclass InsufficientBalanceError(Exception):\n    \"\"\"Custom exception for insufficient balance.\"\"\"\n    pass\n\nclass BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise InvalidAmountError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise InvalidAmountError(\"Invalid amount\")\n        if amount > self.balance:\n            raise InsufficientBalanceError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n# Example usage:\ntry:\n    account1 = BankAccount(100)\n    account2 = BankAccount(50)\n    \n    print(account1.view_balance())  # Output: 100\n    print(account2.view_balance())  # Output: 50\n    \n    account1.transfer(account2, 30)\n    \n    print(account1.view_balance())  # Output: 70\n    print(account2.view_balance())  # Output: 80\n    \nexcept (InvalidAmountError, InsufficientBalanceError) as e:\n    print(e)\n",
  "BigNumCalculator": "class BigNumCalculator:\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        max_length = max(len(num1), len(num2))\n        num1_padded = num1.zfill(max_length)\n        num2_padded = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = (ord(num1_padded[i]) - ord('0')) + (ord(num2_padded[i]) - ord('0')) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.append(str(digit))\n\n        if carry > 0:\n            result.append(str(carry))\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        num1_local = num1\n        num2_local = num2\n        negative = False\n\n        if len(num1_local) < len(num2_local) or (len(num1_local) == len(num2_local) and num1_local < num2_local):\n            num1_local, num2_local = num2_local, num1_local\n            negative = True\n\n        max_length = max(len(num1_local), len(num2_local))\n        num1_local = num1_local.zfill(max_length)\n        num2_local = num2_local.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = (ord(num1_local[i]) - ord('0')) - (ord(num2_local[i]) - ord('0')) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.append(str(digit_diff))\n\n        while len(result) > 1 and result[-1] == '0':\n            result.pop()\n\n        if negative:\n            result.append('-')\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        len1 = len(num1)\n        len2 = len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1 = i + j\n                p2 = i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        # Convert list of digits to string\n        result_str = ''.join(map(str, result))\n\n        # Remove leading zeros\n        result_str = result_str.lstrip('0')\n\n        return result_str if result_str else '0'\n\n# Example usage:\n# calculator = BigNumCalculator()\n# print(calculator.add(\"123456789\", \"987654321\"))  # Output: \"1111111110\"\n# print(calculator.subtract(\"123456789\", \"987654321\"))  # Output: \"-864197532\"\n# print(calculator.multiply(\"123456789\", \"987654321\"))  # Output: \"121932631112635269\"\n"
}
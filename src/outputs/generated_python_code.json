{
  "AccessGatewayFilter": "import time\n\nclass User:\n    def __init__(self, name, level, address):\n        self.name = name\n        self.level = level\n        self.address = address\n\nclass Authorization:\n    def __init__(self, user, jwt):\n        self.user = user\n        self.jwt = jwt\n\nclass Request:\n    def __init__(self, path, method, auth):\n        self.path = path\n        self.method = method\n        self.auth = auth\n\nclass AccessGatewayFilter:\n    def filter(self, request):\n        request_uri = request.path\n        method = request.method\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception:\n            return False\n        return False\n\n    def is_start_with(self, request_uri):\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request.auth\n        user = token.user\n\n        if token.jwt.startswith(user.name):\n            jwt_str_date = token.jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if now - jwt_timestamp >= 3 * 24 * 60 * 60:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return token\n\n    def set_current_user_info_and_log(self, user):\n        print(f\"{user.name} {user.address} {int(time.time())}\")\n",
  "AreaCalculator": "import math\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise ValueError(\"Height cannot be negative.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise ValueError(\"Inner radius cannot be greater than outer radius.\")\n        return math.pi * (outer_radius * outer_radius - inner_radius * inner_radius)\n",
  "ArgumentParser": "import re\nfrom typing import Tuple, Set, Dict, Callable\n\nclass ArgumentParser:\n    def __init__(self):\n        self.arguments: Dict[str, str] = {}\n        self.required: Set[str] = set()\n        self.types: Dict[str, str] = {}\n        self.type_converters: Dict[str, Callable[[str], str]] = {}\n        self.initialize_converters()\n\n    def parse_arguments(self, command_string: str) -> Tuple[bool, Set[str]]:\n        words = command_string.split()\n        if words:\n            words.pop(0)\n\n        for word in words:\n            if word.startswith(\"--\"):\n                key_value = word[2:]\n                key, _, value = key_value.partition('=')\n                value = value if value else \"1\"\n                self.arguments[key] = self.convert_type(key, value)\n            elif word.startswith(\"-\"):\n                key = word[1]\n                value = \"\"\n                if words and not words[0].startswith('-'):\n                    value = words.pop(0)\n                self.arguments[key] = self.convert_type(key, value if value else \"1\")\n\n        missing_args = {req for req in self.required if req not in self.arguments}\n        return len(missing_args) == 0, missing_args\n\n    def get_argument(self, key: str) -> str:\n        return self.arguments.get(key, \"\")\n\n    def add_argument(self, arg: str, required: bool = False, arg_type: str = \"string\"):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def convert_type(self, arg: str, value: str) -> str:\n        if arg not in self.types:\n            return value\n        converter = self.type_converters.get(self.types[arg])\n        if converter:\n            return converter(value)\n        return value\n\n    def initialize_converters(self):\n        self.type_converters[\"int\"] = lambda value: str(int(value)) if value.isdigit() else value\n        self.type_converters[\"bool\"] = lambda value: \"1\" if value.lower() == \"true\" else \"0\" if value.lower() == \"false\" else value\n",
  "ArrangementCalculator": "from typing import List\n\nclass ArrangementCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int = -1) -> int:\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m: int = -1) -> List[List[str]]:\n        result = []\n        if m == -1:\n            m = len(self.datas)\n\n        current = []\n        remaining = self.datas\n\n        self.permutations_recursive(current, remaining, m, result)\n\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            partial_result = self.select(i)\n            result.extend(partial_result)\n        return result\n\n    def permutations_recursive(self, current: List[str], remaining: List[str], m: int, result: List[List[str]]) -> None:\n        if len(current) == m:\n            result.append(current)\n        else:\n            for i in range(len(remaining)):\n                new_current = current + [remaining[i]]\n                new_remaining = remaining[:i] + remaining[i+1:]\n                self.permutations_recursive(new_current, new_remaining, m, result)\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n",
  "AssessmentSystem": "from typing import Optional, List, Dict\n\nclass Student:\n    def __init__(self, grade: int, major: str):\n        self.grade = grade\n        self.major = major\n        self.courses: Dict[str, int] = {}\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Student] = {}\n\n    def add_student(self, name: str, grade: int, major: str):\n        self.students[name] = Student(grade, major)\n\n    def add_course_score(self, name: str, course: str, score: int):\n        if name in self.students:\n            self.students[name].courses[course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student.courses:\n            total_score = sum(student.courses.values())\n            return total_score / len(student.courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for name, student in self.students.items():\n            if any(score < 60 for score in student.courses.values()):\n                students_with_fail.append(name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student.courses:\n                total += student.courses[course]\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n",
  "AutomaticGuitarSimulator": "import re\n\nclass PlayItem:\n    def __init__(self, chord, tune):\n        self.Chord = chord\n        self.Tune = tune\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        if not self.play_text:\n            return play_list\n\n        for play_seg in self.play_text.split():\n            match = re.match(r'([a-zA-Z]+)(\\d+)', play_seg)\n            if match:\n                play_chord, play_value = match.groups()\n                item = PlayItem(play_chord, play_value)\n                play_list.append(item)\n\n                if display:\n                    print(self.format_display(play_chord, play_value))\n        return play_list\n\n    def format_display(self, key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def get(self, index):\n        size, remainder = self.set_num()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        return self.lst[start:end]\n",
  "BalancedBrackets": "class BalancedBrackets:\n    def __init__(self, expr: str):\n        self.expr = expr\n        self.stack = []\n        self.left_brackets = \"({[\"\n        self.right_brackets = \")}]\"\n\n    def clear_expr(self):\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets or c in self.right_brackets)\n\n    def check_balanced_brackets(self) -> bool:\n        self.clear_expr()\n        for brkt in self.expr:\n            if brkt in self.left_brackets:\n                self.stack.append(brkt)\n            else:\n                if not self.stack:\n                    return False\n                current_brkt = self.stack.pop()\n                if (current_brkt == '(' and brkt != ')') or \\\n                   (current_brkt == '{' and brkt != '}') or \\\n                   (current_brkt == '[' and brkt != ']'):\n                    return False\n        return not self.stack\n",
  "BankAccount": "class BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)\n",
  "BigNumCalculator": "class BigNumCalculator:\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        max_length = max(len(num1), len(num2))\n        num1_padded = num1.zfill(max_length)\n        num2_padded = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = (ord(num1_padded[i]) - ord('0')) + (ord(num2_padded[i]) - ord('0')) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.append(chr(digit + ord('0')))\n\n        if carry > 0:\n            result.append(chr(carry + ord('0')))\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        num1_local = num1\n        num2_local = num2\n        negative = False\n\n        if len(num1_local) < len(num2_local) or (len(num1_local) == len(num2_local) and num1_local < num2_local):\n            num1_local, num2_local = num2_local, num1_local\n            negative = True\n\n        max_length = max(len(num1_local), len(num2_local))\n        num1_local = num1_local.zfill(max_length)\n        num2_local = num2_local.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = (ord(num1_local[i]) - ord('0')) - (ord(num2_local[i]) - ord('0')) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.append(chr(digit_diff + ord('0')))\n\n        while len(result) > 1 and result[-1] == '0':\n            result.pop()\n\n        if negative:\n            result.append('-')\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        len1 = len(num1)\n        len2 = len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1 = i + j\n                p2 = i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        leading_zero = True\n        result_str = []\n        for num in result:\n            if num == 0 and leading_zero:\n                continue\n            leading_zero = False\n            result_str.append(str(num))\n\n        return ''.join(result_str) if result_str else '0'\n",
  "BinaryDataProcessor": "import re\nfrom collections import Counter\n\nclass BinaryDataProcessor:\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        self.binary_string = re.sub(r'[^01]', '', self.binary_string)\n\n    def calculate_binary_info(self):\n        counts = Counter(self.binary_string)\n        total_length = len(self.binary_string)\n        zeroes_count = counts['0']\n        ones_count = counts['1']\n\n        zeroes_percentage = zeroes_count / total_length if total_length > 0 else 0\n        ones_percentage = ones_count / total_length if total_length > 0 else 0\n\n        return {\n            \"Zeroes\": zeroes_percentage,\n            \"Ones\": ones_percentage,\n            \"Bit length\": float(total_length)\n        }\n\n    def convert_to_ascii(self):\n        result = []\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8].ljust(8, '0')\n            result.append(chr(int(byte, 2)))\n        return ''.join(result)\n\n    def convert_to_utf8(self):\n        return self.convert_to_ascii()\n",
  "BitStatusUtil": "class BitStatusUtil:\n    @staticmethod\n    def add(states, stat):\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n",
  "BlackjackGame": "import random\nfrom typing import List\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand: List[str] = []\n        self.dealer_hand: List[str] = []\n\n    def create_deck(self) -> List[str]:\n        deck = []\n        suits = [\"S\", \"C\", \"D\", \"H\"]\n        ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand: List[str]) -> int:\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if \"2\" <= rank <= \"9\":\n                value += int(rank)\n            elif rank == \"A\":\n                value += 11\n                num_aces += 1\n            else:\n                value += 10\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand: List[str], dealer_hand: List[str]) -> str:\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            return \"Player wins\" if player_value <= dealer_value else \"Dealer wins\"\n        elif player_value > 21:\n            return \"Dealer wins\"\n        elif dealer_value > 21:\n            return \"Player wins\"\n        else:\n            return \"Dealer wins\" if player_value <= dealer_value else \"Player wins\"\n",
  "BookManagement": "class BookManagement:\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise RuntimeError(\"Insufficient quantity or book not found\")\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        return self.inventory.get(title, 0)\n",
  "BookManagementDB": "import sqlite3\nfrom typing import List, Tuple\n\nclass BookManagementDB:\n    def __init__(self, db_name: str):\n        self.connection = sqlite3.connect(db_name)\n        if not self.connection:\n            raise RuntimeError(\"Failed to open database\")\n\n    def __del__(self):\n        self.connection.close()\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS books (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            author TEXT NOT NULL,\n            available INTEGER NOT NULL\n        )\n        \"\"\"\n        try:\n            self.connection.execute(create_table_sql)\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def add_book(self, title: str, author: str):\n        insert_sql = \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\"\n        try:\n            self.connection.execute(insert_sql, (title, author))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def remove_book(self, book_id: int):\n        delete_sql = \"DELETE FROM books WHERE id = ?\"\n        try:\n            self.connection.execute(delete_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def borrow_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 0 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def return_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 1 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def search_books(self) -> List[Tuple[int, str, str, int]]:\n        select_sql = \"SELECT * FROM books\"\n        try:\n            cursor = self.connection.execute(select_sql)\n            books = [tuple(row) for row in cursor.fetchall()]\n            return books\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def get_connection(self):\n        return self.connection\n",
  "BoyerMooreSearch": "class BoyerMooreSearch:\n    def __init__(self, text: str, pattern: str):\n        self.text = text\n        self.pattern = pattern\n        self.text_len = len(text)\n        self.pat_len = len(pattern)\n\n    def match_in_pattern(self, c: str) -> int:\n        for i in range(self.pat_len - 1, -1, -1):\n            if c == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        for i in range(self.pat_len - 1, -1, -1):\n            if self.pattern[i] != self.text[current_pos + i]:\n                return current_pos + i\n        return -1\n\n    def bad_character_heuristic(self) -> list[int]:\n        positions = []\n        i = 0\n        while i <= self.text_len - self.pat_len:\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                mismatched_char = self.text[mismatch_index]\n                match_index = self.match_in_pattern(mismatched_char)\n                if match_index == -1:\n                    i += (mismatch_index - i + 1)\n                else:\n                    i += (mismatch_index - match_index)\n        return positions\n",
  "Calculator": "import math\nfrom collections import deque\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: math.pow(x, y)\n        }\n\n    def calculate(self, expression):\n        if not expression:\n            return 0.0\n\n        operand_stack = deque()\n        operator_stack = deque()\n        num_buffer = []\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer.append(ch)\n            else:\n                if num_buffer:\n                    operand_stack.append(float(''.join(num_buffer)))\n                    num_buffer.clear()\n\n                if ch in '+-*/^':\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(''.join(num_buffer)))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op):\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(op, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[op](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "CalendarUtil": "import datetime\nfrom typing import List, Tuple\n\nclass CalendarUtil:\n    class Event:\n        def __init__(self, date: datetime.datetime, start_time: datetime.datetime, end_time: datetime.datetime, description: str):\n            self.date = date\n            self.start_time = start_time\n            self.end_time = end_time\n            self.description = description\n\n        def __eq__(self, other):\n            return (self.date == other.date and\n                    self.start_time == other.start_time and\n                    self.end_time == other.end_time and\n                    self.description == other.description)\n\n    def __init__(self):\n        self.events: List[CalendarUtil.Event] = []\n\n    def add_event(self, event: Event):\n        self.events.append(event)\n\n    def remove_event(self, event: Event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date: datetime.datetime) -> List[Event]:\n        events_on_date = []\n        for event in self.events:\n            if event.date.date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time: datetime.datetime, end_time: datetime.datetime) -> bool:\n        for event in self.events:\n            if start_time < event.end_time and end_time > event.start_time:\n                return False\n        return True\n\n    def get_available_slots(self, date: datetime.datetime) -> List[Tuple[datetime.datetime, datetime.datetime]]:\n        available_slots = []\n        start_time = date\n        end_time = date + datetime.timedelta(days=1) - datetime.timedelta(seconds=1)\n\n        while start_time < end_time:\n            slot_end_time = start_time + datetime.timedelta(hours=1)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time = slot_end_time\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events: int) -> List[Event]:\n        now = datetime.datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event.start_time >= now:\n                upcoming_events.append(event)\n                if len(upcoming_events) == num_events:\n                    break\n        return upcoming_events\n\ndef time_from_timestamp(timestamp: float) -> datetime.datetime:\n    return datetime.datetime.fromtimestamp(timestamp)\n",
  "CamelCaseMap": "import string\n\nclass CamelCaseMap:\n    def __init__(self):\n        self.data = {}\n        self.insertion_order = []\n\n    @staticmethod\n    def to_camel_case(key):\n        camel_case_key = []\n        capitalize = False\n        for c in key:\n            if c == '_':\n                capitalize = True\n            else:\n                camel_case_key.append(c.upper() if capitalize else c)\n                capitalize = False\n        return ''.join(camel_case_key)\n\n    def convert_key(self, key):\n        return self.to_camel_case(key)\n\n    def set_item(self, key, value):\n        camel_key = self.convert_key(key)\n        if camel_key not in self.data:\n            self.insertion_order.append(camel_key)\n        self.data[camel_key] = value\n\n    def get_item(self, key):\n        return self.data[self.convert_key(key)]\n\n    def del_item(self, key):\n        camel_key = self.convert_key(key)\n        if camel_key in self.data:\n            del self.data[camel_key]\n            self.insertion_order.remove(camel_key)\n\n    def len(self):\n        return len(self.data)\n\n    def __iter__(self):\n        return iter(self.insertion_order)\n",
  "ChandrasekharSieve": "class ChandrasekharSieve:\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def get_primes(self):\n        return self.primes\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        primes = [i for i in range(2, self.n + 1) if sieve[i]]\n        return primes\n",
  "Chat": "from datetime import datetime\nfrom collections import defaultdict\n\nclass Chat:\n    class Message:\n        def __init__(self, sender, receiver, message, timestamp):\n            self.sender = sender\n            self.receiver = receiver\n            self.message = message\n            self.timestamp = timestamp\n\n    def __init__(self):\n        self.users = defaultdict(list)\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = self.get_current_time()\n        message_info = self.Message(sender, receiver, message, timestamp)\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        return self.users.get(username, [])\n\n    def get_users(self):\n        return dict(self.users)\n\n    @staticmethod\n    def get_current_time():\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "ClassRegistrationSystem": "class Student:\n    def __init__(self, name, major):\n        self.name = name\n        self.major = major\n\n    def get_name(self):\n        return self.name\n\n    def get_major(self):\n        return self.major\n\n    def set_name(self, name):\n        self.name = name\n\n    def set_major(self, major):\n        self.major = major\n\n    def __eq__(self, other):\n        return self.name == other.name and self.major == other.major\n\n\nclass ClassRegistrationSystem:\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, new_student):\n        name = new_student.get_name()\n        major = new_student.get_major()\n        for student in self.students:\n            if student.get_name() == name:\n                return 0\n        self.students.append(Student(name, major))\n        return 1\n\n    def register_class(self, student_name, class_name):\n        classes = self.students_registration_classes.setdefault(student_name, [])\n        if class_name not in classes:\n            classes.append(class_name)\n        return classes\n\n    def get_students_by_major(self, major):\n        student_list = [student.get_name() for student in self.students if student.get_major() == major]\n        return student_list\n\n    def get_all_major(self):\n        majors = {student.get_major() for student in self.students}\n        return list(majors)\n\n    def get_most_popular_class_in_major(self, major):\n        class_count = {}\n        for student in self.students:\n            if student.get_major() == major:\n                classes = self.students_registration_classes.get(student.get_name(), [])\n                for class_name in classes:\n                    class_count[class_name] = class_count.get(class_name, 0) + 1\n\n        most_popular_class = max(class_count, key=class_count.get, default=\"\")\n        return most_popular_class\n",
  "Classroom": "from datetime import datetime, time\nfrom typing import List\n\nclass Course:\n    def __init__(self, name: str, start_time: str, end_time: str):\n        self.name = name\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def __eq__(self, other: 'Course') -> bool:\n        return (self.name == other.name and\n                self.start_time == other.start_time and\n                self.end_time == other.end_time)\n\nclass Classroom:\n    def __init__(self, id: int):\n        self.id = id\n        self.courses: List[Course] = []\n\n    def add_course(self, course: Course):\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course: Course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time: str) -> bool:\n        check_time_obj = self.string_to_time(check_time)\n\n        for course in self.courses:\n            start_time_obj = self.string_to_time(course.start_time)\n            end_time_obj = self.string_to_time(course.end_time)\n\n            if check_time_obj >= start_time_obj and check_time_obj <= end_time_obj:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course: Course) -> bool:\n        new_start_time_obj = self.string_to_time(new_course.start_time)\n        new_end_time_obj = self.string_to_time(new_course.end_time)\n\n        for course in self.courses:\n            start_time_obj = self.string_to_time(course.start_time)\n            end_time_obj = self.string_to_time(course.end_time)\n\n            if self.is_time_conflict(start_time_obj, end_time_obj, new_start_time_obj, new_end_time_obj):\n                return False\n        return True\n\n    def has_course(self, course: Course) -> bool:\n        return course in self.courses\n\n    def string_to_time(self, time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(f\"Invalid time format: {time_str}\")\n\n    def is_time_conflict(self, start1: time, end1: time, start2: time, end2: time) -> bool:\n        return (start1 <= end2 and end1 >= start2)\n",
  "CombinationCalculator": "import math\nfrom itertools import combinations\n\nclass CombinationCalculator:\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m):\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(m) * math.factorial(n - m))\n\n    @staticmethod\n    def count_all(n):\n        if n < 0:\n            return float('nan')\n        if n > 63:\n            return float('inf')\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m):\n        if m < 0 or m > len(self.datas):\n            return []\n        return [list(comb) for comb in combinations(self.datas, m)]\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n",
  "ComplexCalculator": "class ComplexCalculator:\n    @staticmethod\n    def add(c1, c2):\n        return complex(c1.real + c2.real, c1.imag + c2.imag)\n\n    @staticmethod\n    def subtract(c1, c2):\n        return complex(c1.real - c2.real, c1.imag - c2.imag)\n\n    @staticmethod\n    def multiply(c1, c2):\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real * c2.real + c2.imag * c2.imag\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)\n",
  "CookiesUtil": "import json\nfrom pathlib import Path\n\nclass CookiesUtil:\n    def __init__(self, cookies_file: str):\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response: dict):\n        if 'cookies' in response:\n            self.cookies = response['cookies']\n        self._save_cookies()\n\n    def load_cookies(self) -> dict:\n        cookies_data = {}\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n        except Exception as e:\n            print(f\"Error reading JSON file: {e}\")\n        return cookies_data\n\n    def _save_cookies(self) -> bool:\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file, indent=4)\n            return True\n        except Exception as e:\n            print(f\"Error writing JSON file: {e}\")\n            return False\n\n    def set_cookies(self, request: dict):\n        cookies_str = '; '.join(f\"{key}={value}\" for key, value in self.cookies.items())\n        request['cookies'] = cookies_str\n",
  "CSVProcessor": "import csv\nimport string\n\nclass CSVProcessor:\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        title = []\n        data = []\n\n        try:\n            with open(file_name, mode='r', newline='') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = [row for row in reader]\n        except FileNotFoundError:\n            pass\n\n        return title, data\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, mode='w', newline='') as file:\n                writer = csv.writer(file)\n                for row in data:\n                    writer.writerow(row)\n            return 1\n        except IOError:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        if N >= len(data[0]):\n            return 0\n\n        column_data = []\n        for row in data:\n            if N < len(row):\n                upper_str = row[N].upper()\n                column_data.append(upper_str)\n\n        new_data = [title] + [column_data]\n        new_file_name = f\"{save_file_name.rsplit('.', 1)[0]}_process.csv\"\n        return self.write_csv(new_data, new_file_name)\n",
  "CurrencyConverter": "class CurrencyConverter:\n    def __init__(self):\n        self.rates = {\n            \"USD\": 1.0,\n            \"EUR\": 0.85,\n            \"GBP\": 0.72,\n            \"JPY\": 110.15,\n            \"CAD\": 1.23,\n            \"AUD\": 1.34,\n            \"CNY\": 6.40,\n        }\n        self.currency_order = [\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CNY\"]\n\n    def convert(self, amount, from_currency, to_currency):\n        if from_currency == to_currency:\n            return amount\n\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n    def get_supported_currencies(self):\n        return self.currency_order\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        self.currency_order.append(currency)\n        return True\n\n    def update_currency_rate(self, currency, new_rate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return True\n",
  "DatabaseProcessor": "import sqlite3\n\nclass DatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def open_database(self):\n        try:\n            return sqlite3.connect(self.database_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def create_table(self, table_name, key1, key2):\n        db = self.open_database()\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        try:\n            db.execute(create_table_query)\n        except sqlite3.Error as e:\n            db.close()\n            raise RuntimeError(f\"Failed to create table: {e}\")\n        finally:\n            db.close()\n\n    def insert_into_database(self, table_name, data):\n        db = self.open_database()\n        insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n        try:\n            cursor = db.cursor()\n            for item in data:\n                cursor.execute(insert_query, (item['name'], int(item['age'])))\n            db.commit()\n        except sqlite3.Error as e:\n            db.rollback()\n            raise RuntimeError(f\"Failed to execute statement: {e}\")\n        finally:\n            db.close()\n\n    def search_database(self, table_name, name):\n        db = self.open_database()\n        query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        result = []\n        try:\n            cursor = db.cursor()\n            cursor.execute(query, (name,))\n            for row in cursor.fetchall():\n                result.append(list(map(str, row)))\n        except sqlite3.Error:\n            pass\n        finally:\n            db.close()\n        return result\n\n    def delete_from_database(self, table_name, name):\n        db = self.open_database()\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        try:\n            cursor = db.cursor()\n            cursor.execute(delete_query, (name,))\n            db.commit()\n        except sqlite3.Error as e:\n            db.rollback()\n            raise RuntimeError(f\"Failed to execute statement: {e}\")\n        finally:\n            db.close()\n",
  "DataStatistics": "from collections import Counter\nimport statistics\n\nclass DataStatistics:\n    def mean(self, data):\n        if not data:\n            raise ValueError(\"Data vector is empty.\")\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        if not data:\n            raise ValueError(\"Data vector is empty.\")\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        else:\n            return sorted_data[mid]\n\n    def mode(self, data):\n        if not data:\n            raise ValueError(\"Data vector is empty.\")\n        count_map = Counter(data)\n        max_count = max(count_map.values())\n        modes = [num for num, count in count_map.items() if count == max_count]\n        return modes\n",
  "DataStatistics2": "import math\nfrom statistics import mean\n\nclass DataStatistics2:\n    def __init__(self, data):\n        self.data = data\n\n    def get_sum(self):\n        return sum(self.data)\n\n    def get_min(self):\n        return min(self.data)\n\n    def get_max(self):\n        return max(self.data)\n\n    def get_variance(self):\n        mean_value = mean(self.data)\n        variance = sum((x - mean_value) ** 2 for x in self.data) / len(self.data)\n        return round(variance, 2)\n\n    def get_std_deviation(self):\n        variance = self.get_variance()\n        std_dev = math.sqrt(variance)\n        return round(std_dev, 2)\n\n    def get_correlation(self):\n        if len(self.data) < 2:\n            return 1.0\n        mean_value = mean(self.data)\n        sum_prod = sum_sq = 0.0\n        for value in self.data:\n            diff = value - mean_value\n            sum_prod += diff * diff\n            sum_sq += diff * diff\n        return sum_prod / sum_sq\n",
  "DataStatistics4": "import math\n\nclass DataStatistics4:\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator1 = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)))\n        denominator2 = math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        denominator = denominator1 * denominator2\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        if std_deviation == 0:\n            return 0.0\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3)\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_dev = math.sqrt(variance)\n\n        if std_dev == 0:\n            return float('nan')\n\n        fourth_moment = sum((x - mean) ** 4 for x in data) / n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3.0\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        pai = 3.141592653589793\n        pdf_values = [(1 / (sigma * math.sqrt(2 * pai))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n",
  "DecryptionUtils": "class DecryptionUtils:\n    def __init__(self, key):\n        self.key_ = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        shift = shift % 26\n        plaintext = []\n        for c in ciphertext:\n            if c.isalpha():\n                base = 'A' if c.isupper() else 'a'\n                shifted_char = chr((ord(c) - ord(base) - shift + 26) % 26 + ord(base))\n                plaintext.append(shifted_char)\n            else:\n                plaintext.append(c)\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = []\n        key_length = len(self.key_)\n        key_index = 0\n\n        for c in ciphertext:\n            if c.isalpha():\n                shift = ord(self.key_[key_index % key_length].lower()) - ord('a')\n                base = 'a' if c.islower() else 'A'\n                decrypted_char = chr((ord(c.lower()) - ord('a') - shift + 26) % 26 + ord('a'))\n                decrypted_text.append(decrypted_char.upper() if c.isupper() else decrypted_char)\n                key_index += 1\n            else:\n                decrypted_text.append(c)\n        return ''.join(decrypted_text)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        if rails <= 1:\n            return encrypted_text\n\n        n = len(encrypted_text)\n        fence = [['\\n'] * n for _ in range(rails)]\n\n        direction = -1\n        row = 0\n        col = 0\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = '*'\n            col += 1\n            row += direction\n\n        index = 0\n        for r in range(rails):\n            for c in range(n):\n                if fence[r][c] == '*':\n                    fence[r][c] = encrypted_text[index]\n                    index += 1\n\n        direction = -1\n        row = 0\n        col = 0\n        plain_text = []\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text.append(fence[row][col])\n            col += 1\n            row += direction\n\n        return ''.join(plain_text)\n",
  "DiscountStrategy": "from enum import Enum\nfrom typing import Dict, List\n\nclass PromoType(Enum):\n    FidelityPromo = 1\n    BulkItemPromo = 2\n    LargeOrderPromo = 3\n    NoPromo = 4\n\nclass DiscountStrategy:\n    def __init__(self, customer: Dict[str, float], cart: List[Dict[str, float]], promo: PromoType = PromoType.NoPromo):\n        self.customer_ = customer\n        self.cart_ = cart\n        self.promo_ = promo\n\n    def total(self) -> float:\n        total = 0.0\n        for item in self.cart_:\n            total += item[\"quantity\"] * item[\"price\"]\n        return total\n\n    def due(self) -> float:\n        return self.total() - self.promotion(self)\n\n    def promotion(self, order: 'DiscountStrategy') -> float:\n        if self.promo_ == PromoType.FidelityPromo:\n            return self.fidelity_discount()\n        elif self.promo_ == PromoType.BulkItemPromo:\n            return self.bulk_item_discount()\n        elif self.promo_ == PromoType.LargeOrderPromo:\n            return self.large_order_discount()\n        else:\n            return 0.0\n\n    def fidelity_discount(self) -> float:\n        total = 0.0\n        fidelity = self.customer_.get(\"fidelity\", 0.0)\n        if fidelity >= 1000.0:\n            total = 0.05 * self.total()\n        return total\n\n    def bulk_item_discount(self) -> float:\n        discount = 0.0\n        for item in self.cart_:\n            if item[\"quantity\"] >= 20:\n                discount += item[\"quantity\"] * item[\"price\"] * 0.1\n        return discount\n\n    def large_order_discount(self) -> float:\n        num_items = len(self.cart_)\n        discount = 0.0\n        if num_items >= 10:\n            discount = 0.07 * self.total()\n        return discount\n",
  "EightPuzzle": "from collections import deque\n\nclass EightPuzzle:\n    def __init__(self, initial_state=None):\n        self.initialState = initial_state if initial_state else []\n        self.goalState = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return -1, -1\n\n    def move(self, state, direction):\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]\n\n        if direction == \"up\" and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == \"down\" and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == \"left\" and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == \"right\" and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        moves = []\n        i, j = self.find_blank(state)\n\n        if i > 0:\n            moves.append(\"up\")\n        if i < 2:\n            moves.append(\"down\")\n        if j > 0:\n            moves.append(\"left\")\n        if j < 2:\n            moves.append(\"right\")\n\n        return moves\n\n    def solve(self):\n        open_list = deque([(self.initialState, [])])\n        closed_list = []\n\n        while open_list:\n            current_state, path = open_list.popleft()\n            closed_list.append(current_state)\n\n            if current_state == self.goalState:\n                return path\n\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if new_state not in closed_list:\n                    new_path = path + [move]\n                    open_list.append((new_state, new_path))\n\n        return []\n\n    def __eq__(self, other):\n        return self.initialState == other.initialState\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(tuple(map(tuple, self.initialState)))\n\n    def __setitem__(self, key, value):\n        self.initialState = value\n        return self\n",
  "EmailClient": "from datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr, capacity):\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def get_current_time(self):\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": str(size),\n                \"time\": self.get_current_time(),\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        if not self.inbox:\n            return {}\n        for email in self.inbox:\n            if email[\"state\"] == \"unread\":\n                email[\"state\"] = \"read\"\n                return email\n        return {}\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return occupied_size + size > self.capacity\n\n    def get_occupied_size(self):\n        return sum(int(email[\"size\"]) for email in self.inbox)\n\n    def clear_inbox(self, size):\n        if not self.addr:\n            return\n\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            freed_space += int(self.inbox[0][\"size\"])\n            del self.inbox[0]\n",
  "EncryptionUtils": "class EncryptionUtils:\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        ciphertext = []\n        for ch in plaintext:\n            if ch.isalpha():\n                ascii_offset = 65 if ch.isupper() else 97\n                shifted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ascii_offset)\n                ciphertext.append(shifted_char)\n            else:\n                ciphertext.append(ch)\n        return ''.join(ciphertext)\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = []\n        key_index = 0\n        for ch in plain_text:\n            if ch.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text.append(encrypted_char.upper() if ch.isupper() else encrypted_char)\n                key_index += 1\n            else:\n                encrypted_text.append(ch)\n        return ''.join(encrypted_text)\n\n    def rail_fence_cipher(self, plain_text, rails):\n        if rails <= 0:\n            raise ValueError(\"Rails must be greater than zero.\")\n        \n        fence = [''] * rails\n        direction = -1\n        row = 0\n\n        for ch in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row] += ch\n            row += direction\n\n        encrypted_text = ''.join(fence)\n        return encrypted_text\n",
  "ExcelProcessor": "import openpyxl\nfrom typing import List, Union, Tuple, Any\n\nclass ExcelProcessor:\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name: str) -> List[List[Union[str, int]]]:\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook['Sheet1']\n\n            for row in sheet.iter_rows(values_only=True):\n                row_data = []\n                for cell_value in row:\n                    if isinstance(cell_value, int):\n                        row_data.append(cell_value)\n                    elif isinstance(cell_value, str):\n                        row_data.append(cell_value)\n                data.append(row_data)\n        except Exception:\n            return []\n        return data\n\n    def write_excel(self, data: List[List[Union[str, int]]], file_name: str) -> int:\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n\n            for row_index, row in enumerate(data):\n                for col_index, cell_value in enumerate(row):\n                    sheet.cell(row=row_index + 1, column=col_index + 1, value=cell_value)\n\n            workbook.save(file_name)\n            return 1\n        except Exception:\n            return 0\n\n    def process_excel_data(self, N: int, save_file_name: str) -> Tuple[int, str]:\n        data = self.read_excel(save_file_name)\n        if not data or N >= len(data[0]):\n            return 0, \"\"\n\n        new_data = []\n        for row in data:\n            new_row = row[:]\n            value = row[N]\n            if isinstance(value, str):\n                if not value[0].isdigit():\n                    new_value = value.upper()\n                    new_row.append(new_value)\n                else:\n                    new_row.append(value[0])\n            else:\n                new_row.append(value)\n            new_data.append(new_row)\n\n        new_file_name = f\"{save_file_name.rsplit('.', 1)[0]}_process.xlsx\"\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name\n",
  "ExpressionCalculator": "import re\nfrom collections import deque, defaultdict\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n        self.postfix_stack = deque()\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        reversed_postfix_stack = deque(reversed(self.postfix_stack))\n\n        while reversed_postfix_stack:\n            current_op = reversed_postfix_stack.pop()\n\n            if not self.is_operator(current_op):\n                current_op = re.sub(r'~', '-', current_op)\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = re.sub(r'~', '-', first_value)\n                second_value = re.sub(r'~', '-', second_value)\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        result_str = '*'.join(result_stack)\n        return float(result_str)\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = expression\n        current_index = 0\n        count = 0\n        self.postfix_stack.clear()\n        for i in range(len(arr)):\n            current_op = arr[i]\n\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(arr[current_index:current_index + count])\n                peek_op = op_stack[-1]\n\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(op_stack.pop())\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(op_stack.pop())\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index:current_index + count])):\n            self.postfix_stack.append(arr[current_index:current_index + count])\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(op_stack.pop())\n\n    @staticmethod\n    def is_operator(c):\n        operators = {'+', '-', '*', '/', '(', ')', '%'}\n        return c in operators\n\n    def compare(self, cur, peek):\n        cur_op = '/' if cur == '%' else cur\n        peek_op = '/' if peek == '%' else peek\n        return self.operat_priority[ord(peek_op) - 40] >= self.operat_priority[ord(cur_op) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        f = float(first_value)\n        s = float(second_value)\n\n        if current_op == '+':\n            return f + s\n        elif current_op == '-':\n            return f - s\n        elif current_op == '*':\n            return f * s\n        elif current_op == '/':\n            return f / s\n        elif current_op == '%':\n            return f % s\n\n        raise ValueError(f\"Unexpected operator: {current_op}\")\n\n    @staticmethod\n    def transform(expression):\n        expr = re.sub(r'\\s+', '', expression)\n        expr = re.sub(r'=$', '', expr)\n\n        for i in range(len(expr)):\n            if expr[i] == '-':\n                if i == 0:\n                    expr = expr[:i] + '~' + expr[i + 1:]\n                else:\n                    prev_c = expr[i - 1]\n                    if prev_c in '+-*/(' or (prev_c in 'Ee' and i > 1 and expr[i - 2].isdigit()):\n                        expr = expr[:i] + '~' + expr[i + 1:]\n\n        if expr[0] == '~' and len(expr) > 1 and expr[1] == '(':\n            expr = '-' + expr\n            return '0' + expr\n        else:\n            return expr\n",
  "FitnessTracker": "class FitnessTracker:\n    BMI_std = {\n        \"male\": [20.0, 25.0],\n        \"female\": [19.0, 24.0]\n    }\n\n    def __init__(self, height, weight, age, sex):\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n\n    def get_BMI(self):\n        return self.weight / (self.height * self.height)\n\n    def condition_judge(self):\n        BMI = self.get_BMI()\n        BMI_range = self.BMI_std[self.sex]\n        if BMI > BMI_range[1]:\n            return 1\n        elif BMI < BMI_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        condition = self.condition_judge()\n        if condition == 1:\n            calorie_intake = BMR * 1.2\n        elif condition == -1:\n            calorie_intake = BMR * 1.6\n        else:\n            calorie_intake = BMR * 1.4\n        return calorie_intake\n",
  "GomokuGame": "from typing import Optional, List, Tuple\n\nclass GomokuGame:\n    def __init__(self, board_size: int):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row: int, col: int) -> bool:\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self) -> Optional[str]:\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def get_board(self) -> List[List[str]]:\n        return self.board\n\n    def _check_five_in_a_row(self, row: int, col: int, direction: Tuple[int, int]) -> bool:\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5\n",
  "Hotel": "class Hotel:\n    def __init__(self, name, rooms):\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        if room_type not in self.available_rooms:\n            return \"False.\"\n\n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return str(self.available_rooms[room_type])\n        else:\n            return \"False.\"\n\n    def check_in(self, room_type, room_number, name):\n        if room_type not in self.booked_rooms:\n            return False\n\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                del self.booked_rooms[room_type][name]\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n            return True\n        return False\n\n    def check_out(self, room_type, room_number):\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        return self.available_rooms.get(room_type, 0)\n",
  "HRManagementSystem": "from typing import Optional, Dict, Any, Union\n\nclass HRManagementSystem:\n    def __init__(self):\n        self.employees: Dict[int, Dict[str, Union[str, int]]] = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                \"name\": name,\n                \"position\": position,\n                \"department\": department,\n                \"salary\": salary\n            }\n            return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: Dict[str, Union[str, int]]) -> bool:\n        if employee_id not in self.employees:\n            return False\n\n        for key in employee_info:\n            if key not in self.employees[employee_id]:\n                return False\n\n        for key, value in employee_info.items():\n            self.employees[employee_id][key] = value\n\n        return True\n\n    def get_employee(self, employee_id: int) -> Optional[Dict[str, Union[str, int]]]:\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> Dict[int, Dict[str, Union[str, int]]]:\n        employee_data = {}\n\n        for employee_id, employee_info in self.employees.items():\n            employee_details = {\"employee_ID\": employee_id}\n            employee_details.update(employee_info)\n            employee_data[employee_id] = employee_details\n\n        return employee_data\n",
  "Interpolation": "class Interpolation:\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for k in range(len(x_interp)):\n            xi = x_interp[k]\n            yi = y_interp[k]\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j + 1] - yi) +\n                                  z01 * (x[i + 1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp\n",
  "IPAddress": "import re\n\nclass IPAddress:\n    def __init__(self, ip_address: str):\n        self.ip_address = ip_address\n\n    def is_valid(self) -> bool:\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not self.is_valid_octet(octet):\n                return False\n        return True\n\n    def get_octets(self) -> list:\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self) -> str:\n        if self.is_valid():\n            octets = self.get_octets()\n            binary_octets = [f\"{int(octet):08b}\" for octet in octets]\n            return '.'.join(binary_octets)\n        else:\n            return \"\"\n\n    def is_valid_octet(self, octet: str) -> bool:\n        if not octet or len(octet) > 3 or not octet.isdigit():\n            return False\n        value = int(octet)\n        return 0 <= value <= 255\n",
  "IpUtil": "import socket\n\nclass IpUtil:\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        if ip_address == \"0.0.0.0\":\n            try:\n                return socket.gethostname()\n            except socket.error:\n                return \"\"\n        \n        try:\n            result = socket.gethostbyaddr(ip_address)\n            return result[0]\n        except socket.herror:\n            return \"\"\n",
  "JobMarketplace": "class Job:\n    def __init__(self, job_title, company, requirements):\n        self.job_title = job_title\n        self.company = company\n        self.requirements = requirements\n\n    def __eq__(self, other):\n        return (self.job_title == other.job_title and\n                self.company == other.company and\n                self.requirements == other.requirements)\n\n\nclass Resume:\n    def __init__(self, name, skills, experience):\n        self.name = name\n        self.skills = skills\n        self.experience = experience\n\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.skills == other.skills and\n                self.experience == other.experience)\n\n\nclass JobMarketplace:\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        self.job_listings.append(Job(job_title, company, requirements))\n\n    def remove_job(self, job):\n        self.job_listings = [j for j in self.job_listings if j != job]\n\n    def submit_resume(self, name, skills, experience):\n        self.resumes.append(Resume(name, skills, experience))\n\n    def withdraw_resume(self, resume):\n        self.resumes = [r for r in self.resumes if r != resume]\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        for job_listing in self.job_listings:\n            if (criteria in job_listing.job_title or\n                    any(criteria in requirement for requirement in job_listing.requirements)):\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job.requirements):\n                applicants.append(resume)\n        return applicants\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        return all(skill in resume.skills for skill in requirements)\n",
  "JSONProcessor": "import json\nimport os\n\nclass JSONProcessor:\n\n    def read_json(self, file_path):\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n                if data is None:\n                    return -1\n                return 1, data\n        except (FileNotFoundError, json.JSONDecodeError):\n            return -1, None\n\n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, indent=4)\n                return 1\n        except IOError:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        result, data = self.read_json(file_path)\n\n        if result != 1:\n            return 0\n\n        if remove_key in data:\n            del data[remove_key]\n            return self.write_json(data, file_path)\n        else:\n            return 0\n",
  "KappaCalculator": "import numpy as np\n\nclass KappaCalculator:\n    @staticmethod\n    def kappa(test_data, k):\n        data_mat = np.array(test_data)\n\n        P0 = np.trace(data_mat)\n\n        xsum = np.sum(data_mat, axis=1)\n        ysum = np.sum(data_mat, axis=0)\n        total_sum = np.sum(data_mat)\n\n        Pe = (np.dot(ysum, xsum)) / (total_sum * total_sum)\n        P0 /= total_sum\n\n        cohens_coefficient = (P0 - Pe) / (1 - Pe)\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(test_data, N, k, n):\n        data_mat = np.array(test_data)\n\n        sum_total = 0.0\n        P0 = 0.0\n\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum_total += data_mat[i, j]\n                temp += data_mat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n\n        P0 /= N\n\n        ysum = np.sum(data_mat, axis=0)\n        ysum = (ysum / sum_total) ** 2\n\n        Pe = np.sum(ysum)\n\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans\n",
  "LongestWord": "import re\n\nclass LongestWord:\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word: str):\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence: str) -> str:\n        longest_word = \"\"\n        lower_sentence = sentence.lower()\n\n        \n        lower_sentence = re.sub(r'[^\\w\\s]', '', lower_sentence)\n\n        \n        for word in lower_sentence.split():\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n\n        return longest_word\n\n    def get_word_list(self) -> list:\n        return self.word_list\n",
  "MahjongConnect": "import random\nfrom typing import List, Tuple, Set\n\nclass MahjongConnect:\n    def __init__(self, board_size: Tuple[int, int], icons: List[str]):\n        self.BOARD_SIZE = board_size\n        self.ICONS = icons\n        self.board = self.create_board()\n\n    def create_board(self) -> List[List[str]]:\n        new_board = [['' for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        for i in range(self.BOARD_SIZE[0]):\n            for j in range(self.BOARD_SIZE[1]):\n                new_board[i][j] = random.choice(self.ICONS)\n        return new_board\n\n    def is_valid_move(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and\n                0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        if pos1 == pos2:\n            return False\n\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        visited: Set[Tuple[int, int]] = set()\n        stack: List[Tuple[int, int]] = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + direction[0], y + direction[1]\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> None:\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self) -> bool:\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n",
  "Manacher": "class Manacher:\n    def __init__(self, input_string: str):\n        self.input_string = input_string\n\n    def palindromic_length(self, center: int, diff: int, string: str) -> int:\n        if (center - diff == -1) or (center + diff == len(string)) or (string[center - diff] != string[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self) -> str:\n        max_length = 0\n        new_input_string = '|'.join(self.input_string)\n        output_string = ''\n\n        for i in range(len(new_input_string)):\n            length = self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        for i in range(start - max_length, start + max_length + 1):\n            if new_input_string[i] != '|':\n                output_string += new_input_string[i]\n\n        return output_string\n",
  "MetricsCalculator": "class MetricsCalculator:\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        for predicted, true_label in zip(predicted_labels, true_labels):\n            if predicted == 1 and true_label == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true_label == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true_label == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true_label == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision_value = self.precision(predicted_labels, true_labels)\n        recall_value = self.recall(predicted_labels, true_labels)\n        if precision_value + recall_value == 0.0:\n            return 0.0\n        return 2.0 * precision_value * recall_value / (precision_value + recall_value)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n",
  "MetricsCalculator2": "from typing import List, Tuple\nfrom itertools import accumulate\n\nclass MetricsCalculator2:\n    @staticmethod\n    def mrr(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        sum_mrr = 0.0\n        individual_mrr = []\n\n        for vec, k in data:\n            if k <= 0 or not vec:\n                individual_mrr.append(0.0)\n            else:\n                mrr = MetricsCalculator2._calculate_mrr(vec, k)\n                individual_mrr.append(mrr)\n                sum_mrr += mrr\n\n        average_mrr = sum_mrr / len(data) if data else 0.0\n        return average_mrr, individual_mrr\n\n    @staticmethod\n    def map(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        separate_result = []\n\n        for sub_list, total_num in data:\n            if total_num == 0:\n                separate_result.append(0.0)\n                continue\n\n            len_sub_list = len(sub_list)\n            ranking_array = [1.0 / i for i in range(1, len_sub_list + 1)]\n\n            right_ranking_list = [0.0] * len_sub_list\n            count = 1\n\n            for i in range(len_sub_list):\n                if sub_list[i] != 0:\n                    right_ranking_list[i] = count\n                    count += 1\n\n            ap = sum(x * y for x, y in zip(right_ranking_list, ranking_array)) / total_num\n            separate_result.append(ap)\n\n        mean_ap = sum(separate_result) / len(separate_result) if separate_result else 0.0\n        return mean_ap, separate_result\n\n    @staticmethod\n    def _calculate_mrr(vec: List[int], k: int) -> float:\n        try:\n            index = vec.index(1)\n            return 1.0 / (index + 1)\n        except ValueError:\n            return 0.0\n",
  "MovieBookingSystem": "from datetime import datetime, time\nfrom typing import List, Tuple, Dict\n\nclass MovieBookingSystem:\n    def __init__(self):\n        self.movies: List[Dict] = []\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': self.parse_time(start_time),\n            'end_time': self.parse_time(end_time),\n            'seats': [[0] * n for _ in range(n)]\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name: str, seats_to_book: List[Tuple[int, int]]) -> str:\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    row, col = seat\n                    if 0 <= row < len(movie['seats']) and 0 <= col < len(movie['seats'][row]):\n                        if movie['seats'][row][col] == 0:\n                            movie['seats'][row][col] = 1\n                        else:\n                            return \"Booking failed.\"\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time: str, end_time: str) -> List[str]:\n        start = self.parse_time(start_time)\n        end = self.parse_time(end_time)\n\n        available_movies = []\n        for movie in self.movies:\n            if self.is_time_in_range(start, end, movie['start_time']) and self.is_time_in_range(start, end, movie['end_time']):\n                available_movies.append(movie['name'])\n        return available_movies\n\n    @staticmethod\n    def parse_time(time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise RuntimeError(\"Failed to parse time\")\n\n    @staticmethod\n    def is_time_in_range(start: time, end: time, check: time) -> bool:\n        start_seconds = start.hour * 3600 + start.minute * 60\n        end_seconds = end.hour * 3600 + end.minute * 60\n        check_seconds = check.hour * 3600 + check.minute * 60\n        return start_seconds <= check_seconds <= end_seconds\n",
  "MovieTicketDB": "import sqlite3\n\nclass MovieTicketDB:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.db = None\n        self.connect()\n        self.create_table()\n\n    def __del__(self):\n        self.close_connection()\n\n    def connect(self):\n        try:\n            self.db = sqlite3.connect(self.db_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Unable to open database: {e}\")\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\"\n        try:\n            cursor = self.db.cursor()\n            cursor.execute(create_table_sql)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        insert_sql = \"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\"\n        try:\n            cursor = self.db.cursor()\n            cursor.execute(insert_sql, (movie_name, theater_name, seat_number, customer_name))\n            self.db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert ticket: {e}\")\n\n    def search_tickets_by_customer(self, customer_name):\n        search_sql = \"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\"\n        try:\n            cursor = self.db.cursor()\n            cursor.execute(search_sql, (customer_name,))\n            results = [list(row) for row in cursor.fetchall()]\n            return results\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to search tickets: {e}\")\n\n    def delete_ticket(self, ticket_id):\n        delete_sql = \"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\"\n        try:\n            cursor = self.db.cursor()\n            cursor.execute(delete_sql, (ticket_id,))\n            self.db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete ticket: {e}\")\n\n    def close_connection(self):\n        if self.db:\n            self.db.close()\n            self.db = None\n",
  "MusicPlayer": "import random\nfrom typing import List\n\nclass MusicPlayer:\n    def __init__(self):\n        self.playlist: List[str] = []\n        self.current_song: str = \"\"\n        self.volume: int = 50\n        random.seed()\n\n    def add_song(self, song: str) -> None:\n        self.playlist.append(song)\n\n    def remove_song(self, song: str) -> None:\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self) -> str:\n        if self.playlist:\n            if self.current_song and self.current_song in self.playlist:\n                return self.current_song\n            else:\n                self.current_song = self.playlist[0]\n                return self.current_song\n        return \"\"\n\n    def stop(self) -> bool:\n        if self.current_song:\n            self.current_song = \"\"\n            return True\n        return False\n\n    def switch_song(self) -> bool:\n        if self.current_song and self.current_song in self.playlist:\n            index = self.playlist.index(self.current_song)\n            if index + 1 < len(self.playlist):\n                self.current_song = self.playlist[index + 1]\n                return True\n        return False\n\n    def previous_song(self) -> bool:\n        if self.current_song and self.current_song in self.playlist:\n            index = self.playlist.index(self.current_song)\n            if index > 0:\n                self.current_song = self.playlist[index - 1]\n                return True\n        return False\n\n    def set_volume(self, volume: int) -> bool:\n        if self.is_valid_volume(volume):\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self) -> bool:\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n\n    def is_valid_volume(self, volume: int) -> bool:\n        return 0 <= volume <= 100\n",
  "NLPDataProcessor": "class NLPDataProcessor:\n    def construct_stop_word_list(self):\n        return [\"a\", \"an\", \"the\"]\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        answer = []\n\n        for str_ in string_list:\n            string_split = []\n            words = str_.split()\n\n            for word in words:\n                if word not in stop_word_list:\n                    string_split.append(word)\n\n            answer.append(string_split)\n\n        return answer\n\n    def process(self, string_list):\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n",
  "NLPDataProcessor2": "import re\nfrom collections import defaultdict\n\nclass NLPDataProcessor2:\n    def process_data(self, string_list):\n        words_list = []\n        word_regex = re.compile(r'\\s+')\n\n        for str in string_list:\n            processed_string = self.to_lowercase(self.remove_non_alpha(str))\n            words = [match for match in word_regex.split(processed_string) if match]\n            words_list.append(words)\n\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = defaultdict(int)\n        first_appear = {}\n        js = 0\n\n        for words in words_list:\n            for word in words:\n                if word not in word_frequency:\n                    js += 1\n                    first_appear[word] = js\n                word_frequency[word] += 1\n\n        sorted_word_frequency = sorted(word_frequency.items(), key=lambda x: (-x[1], first_appear[x[0]]))\n\n        top_5_word_frequency = dict(sorted_word_frequency[:5])\n\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n\n    @staticmethod\n    def to_lowercase(str):\n        return ''.join(char.lower() for char in str)\n\n    @staticmethod\n    def remove_non_alpha(str):\n        return ''.join(char if char.isalpha() or char.isspace() else '' for char in str)\n",
  "NumberConverter": "class NumberConverter:\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        binary_num = bin(decimal_num)[2:]\n        return binary_num if binary_num else \"0\"\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        return int(hex_num, 16)\n",
  "NumberWordFormatter": "class NumberWordFormatter:\n    def __init__(self):\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\", \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        if isinstance(x, int):\n            x = str(x)\n        elif isinstance(x, float):\n            x = str(x)\n        elif x is None:\n            return \"\"\n        else:\n            x = str(x)\n\n        lstr = x.split('.')[0]\n        rstr = x.split('.')[1] if '.' in x else \"\"\n        lstr = lstr[::-1]\n\n        if len(lstr) % 3 == 1:\n            lstr += \"00\"\n        elif len(lstr) % 3 == 2:\n            lstr += \"0\"\n\n        a = [\"\"] * 5\n        lm = \"\"\n\n        for i in range(len(lstr) // 3):\n            a[i] = lstr[3 * i + 2] + lstr[3 * i + 1] + lstr[3 * i]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = \" AND CENTS \" + self.trans_two(rstr) + \" \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            nowpos = len(lm.rstrip()) - 1\n            lm = lm[:nowpos + 1]\n            return lm + \" \" + xs + \"ONLY\"\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return self.NUMBER[int(s[0])] + \" HUNDRED\"\n        else:\n            return self.NUMBER[int(s[0])] + \" HUNDRED AND \" + self.trans_two(s[1:])\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]\n",
  "NumericEntityUnescaper": "class NumericEntityUnescaper:\n    def __init__(self):\n        pass\n\n    def replace(self, input_str):\n        out = []\n        pos = 0\n        length = len(input_str)\n        if not input_str:\n            return \"\"\n        \n        while pos < length - 2:\n            if input_str[pos] == '&' and input_str[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n\n                if start < length and input_str[start] in ('x', 'X'):\n                    start += 1\n                    is_hex = True\n\n                if start == length:\n                    return ''.join(out)\n\n                end = start\n                while end < length and self.is_hex_char(input_str[end]):\n                    end += 1\n\n                if end < length and input_str[end] == ';':\n                    try:\n                        number_str = input_str[start:end]\n                        if is_hex:\n                            entity_value = int(number_str, 16)\n                        else:\n                            entity_value = int(number_str)\n\n                        out.append(chr(entity_value))\n                        pos = end + 1\n                        continue\n                    except ValueError:\n                        return ''.join(out)\n\n            out.append(input_str[pos])\n            pos += 1\n\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(c):\n        return c.isdigit() or ('a' <= c.lower() <= 'f')\n",
  "Order": "class Dish:\n    def __init__(self, dish, price, count):\n        self.dish = dish\n        self.price = price\n        self.count = count\n\n\nclass Order:\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        for menu_dish in self.menu:\n            if dish.dish == menu_dish.dish:\n                if menu_dish.count < dish.count:\n                    return False\n                else:\n                    menu_dish.count -= dish.count\n                    break\n        else:\n            return False\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            discount = self.sales.get(dish.dish, 1)\n            total += dish.price * dish.count * discount\n        return total\n\n    def checkout(self):\n        if not self.selected_dishes:\n            return 0\n        total = self.calculate_total()\n        self.selected_dishes.clear()\n        return total\n",
  "PageUtil": "from typing import List, Dict, Union\n\nclass PageUtil:\n    def __init__(self, data: List[int], page_size: int):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + self.page_size - 1) // self.page_size\n\n    def get_page(self, page_number: int) -> List[int]:\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number: int) -> Dict[str, Union[int, List[int], bool]]:\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        return page_info\n\n    def search(self, keyword: str) -> Dict[str, Union[str, int, List[int]]]:\n        results = [item for item in self.data if keyword in str(item)]\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        return search_info\n",
  "PersonRequest": "class PersonRequest:\n    def __init__(self, name: str, sex: str, phone_number: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        if not name or len(name) > 33:\n            return \"\"\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in {\"Man\", \"Woman\", \"UGM\"}:\n            return \"\"\n        return sex\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        if not phone_number or len(phone_number) != 11 or not self._is_all_digits(phone_number):\n            return \"\"\n        return phone_number\n\n    @staticmethod\n    def _is_all_digits(s: str) -> bool:\n        return s.isdigit()\n",
  "PushBoxGame": "class PushBoxGame:\n    def __init__(self, map=None):\n        self.map = map if map is not None else []\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self._is_game_over = False\n        self.init_game()\n\n    def get_map(self):\n        return self.map\n\n    def is_game_over(self):\n        return self._is_game_over\n\n    def get_player_col(self):\n        return self.player_col\n\n    def get_player_row(self):\n        return self.player_row\n\n    def get_targets(self):\n        return self.targets\n\n    def get_boxes(self):\n        return self.boxes\n\n    def get_target_count(self):\n        return self.target_count\n\n    def init_game(self):\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif self.map[row][col] == 'G':\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif self.map[row][col] == 'X':\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        box_on_target_count = sum(1 for box in self.boxes if box in self.targets)\n        if box_on_target_count == self.target_count:\n            self._is_game_over = True\n        return self._is_game_over\n\n    def move(self, direction):\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        if direction == 'w':\n            new_player_row -= 1\n        elif direction == 's':\n            new_player_row += 1\n        elif direction == 'a':\n            new_player_col -= 1\n        elif direction == 'd':\n            new_player_col += 1\n\n        if self.map[new_player_row][new_player_col] != '#':\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                if self.map[new_box_row][new_box_col] != '#':\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        return self.check_win()\n",
  "RegexUtils": "import re\nfrom typing import List\n\nclass RegexUtils:\n    def match(self, pattern: str, text: str) -> bool:\n        return re.search(pattern, text) is not None\n\n    def findall(self, pattern: str, text: str) -> List[str]:\n        return re.findall(pattern, text)\n\n    def split(self, pattern: str, text: str) -> List[str]:\n        result = re.split(pattern, text)\n        if text and (not result or result[0] != text):\n            result.append(\"\")\n        return result\n\n    def sub(self, pattern: str, replacement: str, text: str) -> str:\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self) -> str:\n        return r\"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\"\n\n    def generate_phone_number_pattern(self) -> str:\n        return r\"\\b\\d{3}-\\d{3}-\\d{4}\\b\"\n\n    def generate_split_sentences_pattern(self) -> str:\n        return r\"[.!?][\\s]{1,2}(?=[A-Z])\"\n\n    def split_sentences(self, text: str) -> List[str]:\n        pattern = self.generate_split_sentences_pattern()\n        sentences = self.split(pattern, text)\n        if sentences and not sentences[0]:\n            sentences.pop(0)\n        if sentences and not sentences[-1]:\n            sentences.pop()\n        return sentences\n\n    def validate_phone_number(self, phone_number: str) -> bool:\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text: str) -> List[str]:\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)\n",
  "RPGCharacter": "class RPGCharacter:\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        while amount != 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n\n    def is_alive(self):\n        return self.hp > 0\n\n    def get_hp(self):\n        return self.hp\n\n    def get_exp(self):\n        return self.exp\n\n    def get_attack_power(self):\n        return self.attack_power\n\n    def get_defense(self):\n        return self.defense\n\n    def get_level(self):\n        return self.level\n\n    def set_hp(self, x):\n        self.hp = x\n",
  "Server": "class Server:\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        if addr in self.white_list:\n            return []\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return self.white_list\n        else:\n            return []\n\n    def recv(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return -1\n        addr = int(info[\"addr\"])\n        content = info[\"content\"]\n\n        if addr not in self.white_list:\n            return 0\n        else:\n            self.receive_struct = {\"addr\": str(addr), \"content\": content}\n            return 1\n\n    def send(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n        return \"\"\n\n    def show(self, type):\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return {}\n",
  "ShoppingCart": "class ShoppingCart:\n    def __init__(self):\n        self.items = {}\n\n    def add_item(self, item, price, quantity=1):\n        if item in self.items:\n            self.items[item] = (price, quantity)\n        else:\n            self.items[item] = (price, quantity)\n\n    def remove_item(self, item, quantity=1):\n        if item in self.items:\n            self.items[item] = (self.items[item][0], self.items[item][1] - quantity)\n            if self.items[item][1] <= 0:\n                del self.items[item]\n\n    def view_items(self):\n        return self.items\n\n    def total_price(self):\n        total = 0.0\n        for price, quantity in self.items.values():\n            total += price * quantity\n        return total\n",
  "SignInSystem": "class SignInSystem:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username: str) -> bool:\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username: str) -> bool:\n        if username not in self.users:\n            return False\n        else:\n            return self.users[username]\n\n    def all_signed_in(self) -> bool:\n        for signed_in in self.users.values():\n            if not signed_in:\n                return False\n        return True\n\n    def all_not_signed_in(self) -> list[str]:\n        not_signed_in_users = []\n        for username, signed_in in self.users.items():\n            if not signed_in:\n                not_signed_in_users.append(username)\n        return not_signed_in_users\n",
  "Snake": "import random\nfrom typing import List, Tuple\n\nclass Snake:\n    def __init__(self, screen_width: int, screen_height: int, block_size: int, food_position: Tuple[int, int]):\n        self.length = 1\n        self.SCREEN_WIDTH = screen_width\n        self.SCREEN_HEIGHT = screen_height\n        self.BLOCK_SIZE = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction: Tuple[int, int]) -> None:\n        cur = self.positions[0]\n        x, y = direction\n\n        new_pos = (\n            (cur[0] + x * self.BLOCK_SIZE) % self.SCREEN_WIDTH,\n            (cur[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT\n        )\n\n        if new_pos == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new_pos in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_pos)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self) -> None:\n        random.seed()\n        while True:\n            self.food_position = (\n                (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1)) * self.BLOCK_SIZE,\n                (random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1)) * self.BLOCK_SIZE\n            )\n            if self.food_position not in self.positions:\n                break\n\n    def reset(self) -> None:\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self) -> None:\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n\n    def get_length(self) -> int:\n        return self.length\n\n    def get_positions(self) -> List[Tuple[int, int]]:\n        return self.positions\n\n    def get_score(self) -> int:\n        return self.score\n\n    def get_food_position(self) -> Tuple[int, int]:\n        return self.food_position\n\n    def get_SCREEN_WIDTH(self) -> int:\n        return self.SCREEN_WIDTH\n\n    def get_SCREEN_HEIGHT(self) -> int:\n        return self.SCREEN_HEIGHT\n\n    def get_BLOCK_SIZE(self) -> int:\n        return self.BLOCK_SIZE\n",
  "SplitSentence": "import re\n\nclass SplitSentence:\n    def split_sentences(self, sentences_string):\n        sentences = []\n        regex = re.compile(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s')\n        splits = regex.split(sentences_string)\n\n        for sentence in splits:\n            sentence = sentence.rstrip()\n            if sentence:\n                sentences.append(sentence)\n\n        return sentences\n\n    def count_words(self, sentence):\n        cleaned_sentence = ''.join(c for c in sentence if c.isalpha() or c.isspace())\n        words = cleaned_sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count\n",
  "SQLGenerator": "class SQLGenerator:\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=\"\"):\n        if fields is None:\n            fields_str = \"*\"\n        else:\n            fields_str = \", \".join(fields)\n\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join(f\"'{value}'\" for value in data.values())\n\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        set_clause = \", \".join(f\"{key} = '{value}'\" for key, value in data.items())\n\n        sql = f\"UPDATE {self.table_name} SET {set_clause}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def delete_query(self, condition):\n        sql = f\"DELETE FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n",
  "SQLQueryBuilder": "class SQLQueryBuilder:\n    @staticmethod\n    def select(table, columns=[\"*\"], where=[]):\n        query = []\n        if columns == [\"*\"]:\n            query.append(\"SELECT *\")\n        else:\n            query.append(\"SELECT \" + \", \".join(columns))\n        query.append(f\"FROM {table}\")\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n            query.append(f\"WHERE {conditions}\")\n        return \" \".join(query)\n\n    @staticmethod\n    def insert(table, data):\n        columns = \", \".join(key for key, _ in data)\n        values = \", \".join(f\"'{value}'\" for _, value in data)\n        return f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n    @staticmethod\n    def delete_(table, where=[]):\n        query = [f\"DELETE FROM {table}\"]\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n            query.append(f\"WHERE {conditions}\")\n        return \" \".join(query)\n\n    @staticmethod\n    def update(table, data, where=[]):\n        updates = \", \".join(f\"{key}='{value}'\" for key, value in data)\n        query = [f\"UPDATE {table} SET {updates}\"]\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n            query.append(f\"WHERE {conditions}\")\n        return \" \".join(query)\n",
  "Statistics3": "import math\nfrom collections import Counter\nfrom statistics import mean as stats_mean\n\nclass Statistics3:\n    @staticmethod\n    def mean(data):\n        if not data:\n            return float('nan')\n        return sum(data) / len(data)\n\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2.0\n\n    @staticmethod\n    def mode(data):\n        counts = Counter(data)\n        max_count = max(counts.values())\n        return [value for value, count in counts.items() if count == max_count]\n\n    @staticmethod\n    def correlation(x, y):\n        if len(x) != len(y):\n            raise ValueError(\"Vectors must be of the same length\")\n\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator_x = math.sqrt(sum((xi - mean_x) ** 2 for xi in x))\n        denominator_y = math.sqrt(sum((yi - mean_y) ** 2 for yi in y))\n\n        denominator = denominator_x * denominator_y\n        if denominator == 0:\n            return float('nan')\n        return numerator / denominator\n\n    @staticmethod\n    def correlation_matrix(data):\n        num_cols = len(data[0])\n        matrix = [[0.0] * num_cols for _ in range(num_cols)]\n\n        for i in range(num_cols):\n            for j in range(num_cols):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                matrix[i][j] = Statistics3.correlation(column1, column2)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return float('nan')\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean_value = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation == float('nan') or std_deviation == 0:\n            return [float('nan')] * len(data)\n        return [(x - mean_value) / std_deviation for x in data]\n",
  "StockPortfolioTracker": "from dataclasses import dataclass\nfrom typing import List, Tuple\n\n@dataclass\nclass Stock:\n    name: str\n    price: float\n    quantity: int\n\n    def __eq__(self, other):\n        return self.name == other.name and self.price == other.price and self.quantity == other.quantity\n\n@dataclass\nclass StockSummary:\n    name: str\n    value: float\n\n    def __eq__(self, other):\n        return self.name == other.name and self.value == other.value\n\nclass StockPortfolioTracker:\n    def __init__(self, cash_balance: float):\n        self.portfolio: List[Stock] = []\n        self.cash_balance: float = cash_balance\n\n    def add_stock(self, stock: Stock):\n        for pf in self.portfolio:\n            if pf.name == stock.name:\n                pf.quantity += stock.quantity\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock: Stock) -> bool:\n        for i, pf in enumerate(self.portfolio):\n            if pf.name == stock.name and pf.quantity >= stock.quantity:\n                pf.quantity -= stock.quantity\n                if pf.quantity == 0:\n                    del self.portfolio[i]\n                return True\n        return False\n\n    def buy_stock(self, stock: Stock) -> bool:\n        if stock.price * stock.quantity > self.cash_balance:\n            return False\n        else:\n            self.add_stock(stock)\n            self.cash_balance -= stock.price * stock.quantity\n            return True\n\n    def sell_stock(self, stock: Stock) -> bool:\n        if not self.remove_stock(stock):\n            return False\n        self.cash_balance += stock.price * stock.quantity\n        return True\n\n    def calculate_portfolio_value(self) -> float:\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock.price * stock.quantity\n        return total_value\n\n    def get_portfolio_summary(self) -> Tuple[float, List[StockSummary]]:\n        summary = [StockSummary(stock.name, self.get_stock_value(stock)) for stock in self.portfolio]\n        return self.calculate_portfolio_value(), summary\n\n    def get_stock_value(self, stock: Stock) -> float:\n        return stock.price * stock.quantity\n\n    def get_portfolio(self) -> List[Stock]:\n        return self.portfolio\n\n    def get_cash_balance(self) -> float:\n        return self.cash_balance\n\n    def set_portfolio(self, portfolio: List[Stock]):\n        self.portfolio = portfolio\n",
  "StudentDatabaseProcessor": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        self.execute_query(create_table_query, [])\n\n    def insert_student(self, student_data):\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        params = [\n            student_data[\"name\"],\n            student_data[\"age\"],\n            student_data[\"gender\"],\n            student_data[\"grade\"]\n        ]\n        self.execute_query(insert_query, params)\n\n    def search_student_by_name(self, name):\n        select_query = \"\"\"\n        SELECT * FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        results = self.query_result(select_query, params)\n\n        students = []\n        for row in results:\n            student = {\n                \"id\": row[0],\n                \"name\": row[1],\n                \"age\": row[2],\n                \"gender\": row[3],\n                \"grade\": row[4]\n            }\n            students.append(student)\n\n        return students\n\n    def delete_student_by_name(self, name):\n        delete_query = \"\"\"\n        DELETE FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        self.execute_query(delete_query, params)\n\n    def execute_query(self, query, params):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(query, params)\n        conn.commit()\n        conn.close()\n\n    def query_result(self, query, params):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(query, params)\n        results = cursor.fetchall()\n        conn.close()\n        return results\n",
  "TextFileProcessor": "import json\nimport re\n\nclass TextFileProcessor:\n    def __init__(self, filename):\n        self.filename_ = filename\n\n    def read_file_as_json(self):\n        with open(self.filename_, 'r') as file:\n            return json.load(file)\n\n    def read_file(self):\n        with open(self.filename_, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self.filename_, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        result = ''.join(filter(str.isalpha, content))\n        self.write_file(result)\n        return result\n",
  "Thermostat": "class Thermostat:\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, new_mode):\n        if new_mode in [\"heat\", \"cool\"]:\n            self.mode = new_mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = \"heat\"\n        else:\n            self.mode = \"cool\"\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == \"cool\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == \"heat\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == \"heat\":\n            while self.current_temperature < self.target_temperature:\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time\n",
  "TicTacToe": "class TicTacToe:\n    def __init__(self, N=3):\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        for row in self.board:\n            if row[0] != ' ' and row[0] == row[1] == row[2]:\n                return row[0]\n\n        for col in range(3):\n            if self.board[0][col] != ' ' and self.board[0][col] == self.board[1][col] == self.board[2][col]:\n                return self.board[0][col]\n\n        if self.board[0][0] != ' ' and self.board[0][0] == self.board[1][1] == self.board[2][2]:\n            return self.board[0][0]\n\n        if self.board[0][2] != ' ' and self.board[0][2] == self.board[1][1] == self.board[2][0]:\n            return self.board[0][2]\n\n        return '\\0'\n\n    def is_board_full(self):\n        for row in self.board:\n            if ' ' in row:\n                return False\n        return True\n\n    def get_current_player(self):\n        return self.current_player\n",
  "TimeUtils": "from datetime import datetime, timedelta\n\nclass TimeUtils:\n    def __init__(self):\n        self.datetime = datetime.now()\n\n    def get_current_time(self) -> str:\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self) -> str:\n        return self.datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds: int) -> str:\n        self.datetime += timedelta(seconds=seconds)\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, str: str) -> datetime:\n        return datetime.strptime(str, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime: datetime) -> str:\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1: str, string_time2: str) -> int:\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return int((time2 - time1).total_seconds() / 60)\n\n    def get_format_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        dt = datetime(year, month, day, hour, minute, second)\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "TriCalculator": "import math\n\nclass TriCalculator:\n    PI = 3.14159265358979323846\n\n    def __init__(self):\n        pass\n\n    def round(self, value, precision):\n        factor = 10.0 ** precision\n        return round(value * factor) / factor\n\n    def cos(self, x):\n        result = self.taylor(x, 17)\n        print(f\"Taylor result for cos: {result}\")\n        return self.round(result, 10)\n\n    def factorial(self, a):\n        if a < 0:\n            return 0\n        if a == 0:\n            return 1\n        b = 1\n        for i in range(1, a + 1):\n            b *= i\n        return b\n\n    def taylor(self, x, n):\n        a = 0.0\n        x = x / 180.0 * self.PI\n        sign = 1\n\n        for k in range(n):\n            term = math.pow(x, 2 * k) / self.factorial(2 * k)\n            if k % 2 == 0:\n                a += term\n            else:\n                a -= term\n        return a\n\n    def sin(self, x):\n        x = x / 180.0 * self.PI\n        g = 0.0\n        t = x\n        n = 1\n\n        while abs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / ((2 * n - 1) * (2 * n - 2))\n        return self.round(g, 10)\n\n    def tan(self, x):\n        cosine = self.cos(x)\n        if abs(cosine) > 0.01:\n            result = self.sin(x) / cosine\n            return self.round(result, 10)\n        else:\n            return float('nan')\n",
  "TwentyFourPointGame": "import random\nimport math\nfrom collections import defaultdict\n\nclass TwentyFourPointGame:\n    def __init__(self):\n        self.nums = []\n        random.seed()\n\n    def generate_cards(self):\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums.clear()\n        self.generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == \"pass\":\n            return self.get_my_cards()\n\n        statistic = defaultdict(int)\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] += 1\n\n        nums_used = statistic.copy()\n\n        for num in self.nums:\n            if str(num) in nums_used and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return []\n\n        if all(value == 0 for value in nums_used.values()):\n            if self.evaluate_expression(expression):\n                return [1]\n            else:\n                return []\n        else:\n            return []\n\n    def evaluate_expression(self, expression):\n        try:\n            if not expression[0].isdigit() and expression[0] != '(':\n                raise ValueError\n            if not expression[-1].isdigit() and expression[-1] != ')':\n                raise ValueError\n            calculator = Calculator()\n            ans = calculator.calculate(expression)\n            return ans == 24.0\n        except Exception:\n            return False\n\n    def set_nums(self, now):\n        self.nums = now\n\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: math.pow(x, y)\n        }\n\n    def calculate(self, expression):\n        if not expression:\n            return 0.0\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = []\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer.append(ch)\n            else:\n                if num_buffer:\n                    operand_stack.append(float(''.join(num_buffer)))\n                    num_buffer.clear()\n\n                if ch in '+-*/^':\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(''.join(num_buffer)))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op):\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(op, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[op](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "URLHandler": "from urllib.parse import urlparse, parse_qs\n\nclass URLHandler:\n    def __init__(self, url):\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self) -> str:\n        return self.parsed_url.scheme\n\n    def get_host(self) -> str:\n        return self.parsed_url.netloc\n\n    def get_path(self) -> str:\n        return self.parsed_url.path\n\n    def get_query_params(self) -> dict:\n        query_params = parse_qs(self.parsed_url.query)\n        return {k: v[0] for k, v in query_params.items()}\n\n    def get_fragment(self) -> str:\n        return self.parsed_url.fragment\n",
  "UrlPath": "import urllib.parse\n\nclass UrlPath:\n    def __init__(self):\n        self.segments = []\n        self._with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        if path:\n            if path.endswith('/'):\n                self._with_end_tag = True\n\n            fixed_path = self.fix_path(path)\n            if fixed_path:\n                for segment in fixed_path.split('/'):\n                    decoded_seg = urllib.parse.unquote(segment)\n                    self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        if not path:\n            return \"\"\n\n        segment_str = path\n        if segment_str.startswith('/'):\n            segment_str = segment_str[1:]\n        if segment_str.endswith('/'):\n            segment_str = segment_str[:-1]\n        return segment_str\n\n    def get_segments(self):\n        return self.segments\n\n    def with_end_tag(self):\n        return self._with_end_tag\n",
  "UserLoginDB": "import sqlite3\nfrom typing import Optional, Tuple\n\nclass UserLoginDB:\n    def __init__(self, db_name: str):\n        self.connection = None\n        self.stmt = None\n        self.connection = sqlite3.connect(db_name)\n        self.create_table()\n\n    def __del__(self):\n        self.finalize_statement()\n        if self.connection:\n            self.connection.close()\n\n    def prepare_statement(self, query: str):\n        self.finalize_statement()\n        self.stmt = self.connection.prepare(query)\n\n    def finalize_statement(self):\n        if self.stmt:\n            self.stmt.close()\n            self.stmt = None\n\n    def insert_user(self, username: str, password: str):\n        self.prepare_statement(\"INSERT INTO users (username, password) VALUES (?, ?)\")\n        self.stmt.execute((username, password))\n        self.connection.commit()\n        self.finalize_statement()\n\n    def search_user_by_username(self, username: str) -> Optional[Tuple[str, str]]:\n        self.prepare_statement(\"SELECT username, password FROM users WHERE username = ?\")\n        self.stmt.execute((username,))\n        result = self.stmt.fetchone()\n        self.finalize_statement()\n        return result if result else None\n\n    def delete_user_by_username(self, username: str):\n        self.prepare_statement(\"DELETE FROM users WHERE username = ?\")\n        self.stmt.execute((username,))\n        self.connection.commit()\n        self.finalize_statement()\n\n    def validate_user_login(self, username: str, password: str) -> bool:\n        user = self.search_user_by_username(username)\n        return user and user[1] == password\n\n    def create_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT,\n            password TEXT\n        )\n        \"\"\"\n        self.connection.execute(create_table_query)\n        self.connection.commit()\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n",
  "VectorUtil": "import math\nfrom typing import List, Dict, Tuple\n\nclass VectorUtil:\n    @staticmethod\n    def norm(vec: Tuple[float, ...]) -> float:\n        return math.sqrt(sum(val * val for val in vec))\n\n    @staticmethod\n    def normalize(vec: Tuple[float, ...]) -> Tuple[float, ...]:\n        vec_norm = VectorUtil.norm(vec)\n        if vec_norm == 0.0:\n            return tuple(0.0 for _ in vec)\n        return tuple(val / vec_norm for val in vec)\n\n    @staticmethod\n    def similarity(vector_1: Tuple[float, ...], vector_2: Tuple[float, ...]) -> float:\n        norm_vec1 = VectorUtil.normalize(vector_1)\n        norm_vec2 = VectorUtil.normalize(vector_2)\n        return sum(norm_vec1[i] * norm_vec2[i] for i in range(len(vector_1)))\n\n    @staticmethod\n    def cosine_similarities(vector_1: Tuple[float, ...], vectors_all: List[Tuple[float, ...]]) -> List[float]:\n        norm_vec1 = VectorUtil.norm(vector_1)\n        similarities = []\n        for vec in vectors_all:\n            norm_vec_all = VectorUtil.norm(vec)\n            if norm_vec_all == 0.0:\n                similarities.append(0.0)\n                continue\n            dot_product = sum(vec[i] * vector_1[i] for i in range(len(vector_1)))\n            similarity = dot_product / (norm_vec1 * norm_vec_all)\n            similarities.append(similarity)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1: List[Tuple[float, ...]], vector_list_2: List[Tuple[float, ...]]) -> float:\n        if not vector_list_1 or not vector_list_2:\n            raise ValueError(\"At least one of the lists is empty.\")\n\n        mean_vec1 = [0.0] * len(vector_list_1[0])\n        mean_vec2 = [0.0] * len(vector_list_2[0])\n\n        for vec in vector_list_1:\n            for i in range(len(vec)):\n                mean_vec1[i] += vec[i]\n        for vec in vector_list_2:\n            for i in range(len(vec)):\n                mean_vec2[i] += vec[i]\n\n        for i in range(len(mean_vec1)):\n            mean_vec1[i] /= len(vector_list_1)\n            mean_vec2[i] /= len(vector_list_2)\n\n        return VectorUtil.similarity(tuple(mean_vec1), tuple(mean_vec2))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: Dict[str, float]) -> Dict[str, float]:\n        result = {}\n        count_list = list(number_dict.values())\n\n        a = [math.log((total_num + 1.0) / (count + 1.0)) for count in count_list]\n\n        for key, value in zip(number_dict.keys(), a):\n            result[key] = value\n\n        return result\n",
  "VendingMachine": "class VendingMachine:\n    def __init__(self):\n        self.inventory_ = {}\n        self.balance_ = 0.0\n\n    def add_item(self, item_name, price, quantity):\n        if not self.restock_item(item_name, quantity):\n            self.inventory_[item_name] = {\"price\": price, \"quantity\": float(quantity)}\n\n    def insert_coin(self, amount):\n        self.balance_ += amount\n        return self.balance_\n\n    def purchase_item(self, item_name):\n        if item_name in self.inventory_:\n            item = self.inventory_[item_name]\n            if item[\"quantity\"] > 0 and self.balance_ >= item[\"price\"]:\n                self.balance_ -= item[\"price\"]\n                item[\"quantity\"] -= 1\n                return self.balance_\n        return False\n\n    def restock_item(self, item_name, quantity):\n        if item_name in self.inventory_:\n            self.inventory_[item_name][\"quantity\"] += float(quantity)\n            return True\n        return False\n\n    def display_items(self):\n        if not self.inventory_:\n            return \"false\"\n\n        result = []\n        for item_name, details in self.inventory_.items():\n            result.append(f\"{item_name} - ${details['price']} [{details['quantity']}]\")\n        return \"\\n\".join(result)\n\n    def inventory(self):\n        return self.inventory_\n\n    def set_inventory(self, x):\n        self.inventory_ = x\n\n    def set_balance(self, y):\n        self.balance_ = y\n",
  "Warehouse": "class Warehouse:\n    def __init__(self):\n        self.inventory_ = {}\n        self.orders_ = {}\n\n    def add_product(self, product_id, name, quantity):\n        product = self.inventory_.setdefault(product_id, {})\n        if not product:\n            product[\"name\"] = name\n            product[\"quantity\"] = str(quantity)\n        else:\n            current_quantity = int(product[\"quantity\"])\n            product[\"quantity\"] = str(current_quantity + quantity)\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self.inventory_:\n            current_quantity = int(self.inventory_[product_id][\"quantity\"])\n            self.inventory_[product_id][\"quantity\"] = str(current_quantity + quantity)\n\n    def get_product_quantity(self, product_id):\n        if product_id in self.inventory_:\n            return int(self.inventory_[product_id].get(\"quantity\", 0))\n        return 0\n\n    def create_order(self, order_id, product_id, quantity):\n        available_quantity = self.get_product_quantity(product_id)\n        if available_quantity >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders_[order_id] = {\n                \"product_id\": str(product_id),\n                \"quantity\": str(quantity),\n                \"status\": \"Shipped\"\n            }\n            return True\n        return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders_:\n            self.orders_[order_id][\"status\"] = status\n            return True\n        return False\n\n    def track_order(self, order_id):\n        if order_id in self.orders_:\n            return self.orders_[order_id].get(\"status\", \"\")\n        return \"\"\n\n    def orders(self):\n        return self.orders_\n\n    def inventory(self):\n        return self.inventory_\n",
  "WeatherSystem": "class WeatherInfo:\n    def __init__(self, weather, temperature, temperature_units):\n        self.weather = weather\n        self.temperature = temperature\n        self.temperature_units = temperature_units\n\n\nclass WeatherSystem:\n    def __init__(self, city):\n        self.city = city\n        self.temperature = 0.0\n        self.weather = \"\"\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units=\"celsius\"):\n        self.weather_list = weather_list\n        info = self.weather_list.get(self.city)\n        if info is None:\n            return 0.0, \"\"\n        else:\n            self.temperature = info.temperature\n            self.weather = info.weather\n\n        if info.temperature_units != tmp_units:\n            if tmp_units == \"celsius\":\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == \"fahrenheit\":\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        self.city = city\n\n    def set_temperature(self, temperature):\n        self.temperature = temperature\n\n    def celsius_to_fahrenheit(self):\n        return (self.temperature * 9 / 5) + 32\n\n    def fahrenheit_to_celsius(self):\n        return (self.temperature - 32) * 5 / 9\n\n    def get_city(self):\n        return self.city\n",
  "Words2Numbers": "import re\nfrom collections import defaultdict\n\nclass Words2Numbers:\n    def __init__(self):\n        self.units = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                      \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\",\n                      \"eighteen\", \"nineteen\"]\n        \n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        \n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n        \n        self.numwords = defaultdict(tuple)\n        self.numwords[\"and\"] = (1, 0)\n        for idx, unit in enumerate(self.units):\n            self.numwords[unit] = (1, idx)\n        for idx, ten in enumerate(self.tens):\n            self.numwords[ten] = (1, idx * 10)\n        for idx, scale in enumerate(self.scales):\n            self.numwords[scale] = (10 ** (idx * 3), 0)\n        self.numwords[\"hundred\"] = (100, 0)\n        \n        self.ordinal_words = {\"first\": 1, \"second\": 2, \"third\": 3, \"fifth\": 5, \"eighth\": 8,\n                             \"ninth\": 9, \"twelfth\": 12}\n        \n        self.ordinal_endings = [(\"ieth\", \"y\"), (\"th\", \"\")]\n\n    def text2int(self, textnum):\n        text = textnum.replace('-', ' ')\n        current = 0\n        result = 0\n        curstring = \"\"\n\n        for word in text.split():\n            if word in self.ordinal_words:\n                scale = 1\n                increment = self.ordinal_words[word]\n                current = current * scale + increment\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                \n                if word in self.numwords:\n                    scale, increment = self.numwords[word]\n                    if scale == 1:\n                        current += increment\n                    else:\n                        current *= scale\n                        result += current\n                        current = 0\n                else:\n                    if current > 0:\n                        result += current\n                        current = 0\n                    curstring += word + \" \"\n        \n        if current > 0:\n            result += current\n        \n        curstring += str(result)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        text = textnum.replace('-', ' ')\n        \n        for word in text.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                \n                if word not in self.numwords:\n                    return False\n        \n        return True\n",
  "XMLProcessor": "import xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n    def __init__(self, file_name):\n        self.file_name = file_name\n        self.tree = None\n        self.root = None\n\n    def read_xml(self):\n        try:\n            self.tree = ET.parse(self.file_name)\n            self.root = self.tree.getroot()\n        except ET.ParseError:\n            print(f\"Error: Could not load XML file: {self.file_name}\")\n            return None\n        return self.root\n\n    def write_xml(self, file_name):\n        if self.tree is not None:\n            self.tree.write(file_name)\n            return True\n        return False\n\n    def process_xml_data(self, file_name):\n        if self.root is None:\n            print(\"Error: No root element found.\")\n            return False\n\n        for element in self.root.findall('item'):\n            text = element.text\n            if text:\n                upper_text = text.upper()\n                element.text = upper_text\n\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        if self.root is None:\n            return []\n\n        return self.root.findall(element_name)\n",
  "ZipFileProcessor": "import os\nimport zipfile\nfrom pathlib import Path\n\nclass ZipFileInfo:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n\nclass ZipFileProcessor:\n    def __init__(self, zip_file_path):\n        self.zip_file_path = zip_file_path\n\n    def read_zip_file(self):\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r'):\n                return ZipFileInfo(self.zip_file_path, 'r')\n        except zipfile.BadZipFile:\n            return ZipFileInfo(self.zip_file_path, 'invalid')\n\n    def extract_all(self, output_directory):\n        if not output_directory:\n            return False\n\n        if not self._create_directory_if_not_exists(output_directory):\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(output_directory)\n            return True\n        except Exception as e:\n            print(f\"Error extracting all files: {e}\")\n            return False\n\n    def extract_file(self, file_name, output_directory):\n        if not output_directory:\n            return False\n\n        if not self._create_directory_if_not_exists(output_directory):\n            print(f\"Failed to create output directory: {output_directory}\")\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                if file_name in zip_ref.namelist():\n                    zip_ref.extract(file_name, output_directory)\n                    return True\n                else:\n                    print(f\"File not found in zip: {file_name}\")\n                    return False\n        except Exception as e:\n            print(f\"Error extracting file: {e}\")\n            return False\n\n    def create_zip_file(self, files, output_zip_file):\n        try:\n            with zipfile.ZipFile(output_zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:\n                for file_path in files:\n                    zipf.write(file_path, os.path.basename(file_path))\n            return True\n        except Exception as e:\n            print(f\"Error creating zip file: {e}\")\n            return False\n\n    def _create_directory_if_not_exists(self, dir_path):\n        path = Path(dir_path)\n        if not path.exists():\n            path.mkdir(parents=True, exist_ok=True)\n        return path.exists()\n"
}
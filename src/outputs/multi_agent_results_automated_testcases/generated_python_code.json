{
  "AccessGatewayFilter": "import time\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    level: int\n    address: str\n\n@dataclass\nclass Authorization:\n    user: User\n    jwt: str\n\n@dataclass\nclass Request:\n    path: str\n    method: str\n    auth: Authorization\n\nclass AccessGatewayFilter:\n    def __init__(self):\n        pass\n\n    def filter(self, request: Request) -> bool:\n        request_uri = request.path\n        method = request.method\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n        return False\n\n    @staticmethod\n    def is_start_with(request_uri: str) -> bool:\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request: Request) -> Authorization:\n        token = request.auth\n        user = token.user\n\n        if token.jwt.startswith(user.name):\n            jwt_str_date = token.jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if (now - jwt_timestamp) >= 3 * 24 * 60 * 60:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return token\n\n    @staticmethod\n    def set_current_user_info_and_log(user: User):\n        current_time = int(time.time())\n        print(f\"{user.name} {user.address} {current_time}\")\n\n# Example usage:\n# user = User(name=\"JohnDoe\", level=3, address=\"123 Main St\")\n# auth = Authorization(user=user, jwt=\"JohnDoe1633072800\")  # Example JWT with timestamp\n# request = Request(path=\"/some/path\", method=\"GET\", auth=auth)\n# filter_instance = AccessGatewayFilter()\n# print(filter_instance.filter(request))\n",
  "AreaCalculator": "import math\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise ValueError(\"Height cannot be negative.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise ValueError(\"Inner radius cannot be greater than outer radius.\")\n        return math.pi * (outer_radius * outer_radius - inner_radius * inner_radius)\n\n# Note: Google Test (gtest) is a C++ testing framework. For Python, you would typically use unittest or pytest.\n# Example of using unittest for testing the AreaCalculator class:\n# import unittest\n#\n# class TestAreaCalculator(unittest.TestCase):\n#     def setUp(self):\n#         self.calculator = AreaCalculator(5)\n#\n#     def test_calculate_circle_area(self):\n#         self.assertAlmostEqual(self.calculator.calculate_circle_area(), 78.53981633974483)\n#\n#     def test_calculate_sphere_area(self):\n#         self.assertAlmostEqual(self.calculator.calculate_sphere_area(), 314.1592653589793)\n#\n#     def test_calculate_cylinder_area(self):\n#         self.assertAlmostEqual(self.calculator.calculate_cylinder_area(10), 471.23889803846896)\n#\n#     def test_calculate_sector_area(self):\n#         self.assertAlmostEqual(self.calculator.calculate_sector_area(math.pi), 39.269908169872416)\n#\n#     def test_calculate_annulus_area(self):\n#         self.assertAlmostEqual(self.calculator.calculate_annulus_area(3, 5), 50.26548245743669)\n#\n# if __name__ == '__main__':\n#     unittest.main()\n",
  "ArgumentParser": "import re\nfrom typing import Callable, Dict, Set, Tuple\n\n\nclass ArgumentParser:\n    def __init__(self):\n        self.arguments: Dict[str, str] = {}\n        self.required: Set[str] = set()\n        self.types: Dict[str, str] = {}\n        self.type_converters: Dict[str, Callable[[str], str]] = {}\n        self.initialize_converters()\n\n    def parse_arguments(self, command_string: str) -> Tuple[bool, Set[str]]:\n        words = command_string.split()\n        i = 0\n        while i < len(words):\n            word = words[i]\n            if word.startswith(\"--\"):\n                key_value = word[2:]\n                key, _, value = key_value.partition('=')\n                value = value if value else \"1\"\n                self.arguments[key] = self.convert_type(key, value)\n            elif word.startswith(\"-\"):\n                key = word[1:]\n                value = \"1\"\n                if i + 1 < len(words) and not words[i + 1].startswith('-'):\n                    value = words[i + 1]\n                    i += 1\n                self.arguments[key] = self.convert_type(key, value)\n            i += 1\n\n        missing_args = self.required - self.arguments.keys()\n        return len(missing_args) == 0, missing_args\n\n    def get_argument(self, key: str) -> str:\n        return self.arguments.get(key, \"\")\n\n    def add_argument(self, arg: str, required: bool = False, arg_type: str = \"string\"):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def convert_type(self, arg: str, value: str) -> str:\n        if arg not in self.types:\n            return value\n        converter = self.type_converters.get(self.types[arg])\n        if converter:\n            return converter(value)\n        return value\n\n    def initialize_converters(self):\n        self.type_converters[\"int\"] = lambda value: str(int(value)) if value.isdigit() else value\n        self.type_converters[\"bool\"] = lambda value: \"1\" if value.lower() in [\"true\", \"1\"] else \"0\"\n\n\n# Example usage:\n# parser = ArgumentParser()\n# parser.add_argument(\"verbose\", arg_type=\"bool\")\n# parser.add_argument(\"count\", required=True, arg_type=\"int\")\n# success, missing = parser.parse_arguments(\"--verbose=true -count 5\")\n# print(success, missing)\n# print(parser.get_argument(\"verbose\"))\n# print(parser.get_argument(\"count\"))\n",
  "ArrangementCalculator": "from typing import List\n\nclass ArrangementCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int = -1) -> int:\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m: int = -1) -> List[List[str]]:\n        result = []\n        if m == -1:\n            m = len(self.datas)\n\n        current = []\n        remaining = self.datas.copy()\n\n        self._permutations_recursive(current, remaining, m, result)\n\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            partial_result = self.select(i)\n            result.extend(partial_result)\n        return result\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n    def _permutations_recursive(self, current: List[str], remaining: List[str], m: int, result: List[List[str]]) -> None:\n        if len(current) == m:\n            result.append(current.copy())\n        else:\n            for i in range(len(remaining)):\n                new_current = current + [remaining[i]]\n                new_remaining = remaining[:i] + remaining[i+1:]\n                self._permutations_recursive(new_current, new_remaining, m, result)\n",
  "AssessmentSystem": "from typing import Optional, Dict, List\n\nclass Student:\n    def __init__(self, grade: int, major: str):\n        self.grade = grade\n        self.major = major\n        self.courses: Dict[str, int] = {}\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Student] = {}\n\n    def add_student(self, name: str, grade: int, major: str) -> None:\n        if name in self.students:\n            raise ValueError(f\"Student with name {name} already exists.\")\n        self.students[name] = Student(grade, major)\n\n    def add_course_score(self, name: str, course: str, score: int) -> None:\n        student = self.students.get(name)\n        if student is None:\n            raise ValueError(f\"No student found with name {name}.\")\n        student.courses[course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student.courses:\n            total_score = sum(student.courses.values())\n            return total_score / len(student.courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for name, student in self.students.items():\n            if any(score < 60 for score in student.courses.values()):\n                students_with_fail.append(name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            score = student.courses.get(course)\n            if score is not None:\n                total += score\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n",
  "AutomaticGuitarSimulator": "class PlayItem:\n    def __init__(self, chord, tune):\n        self.chord = chord\n        self.tune = tune\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        if not self.play_text:\n            return play_list\n\n        play_segments = self.play_text.split()\n        for play_seg in play_segments:\n            pos = 0\n            while pos < len(play_seg) and play_seg[pos].isalpha():\n                pos += 1\n\n            play_chord = play_seg[:pos]\n            play_value = play_seg[pos:]\n\n            item = PlayItem(play_chord, play_value)\n            play_list.append(item)\n\n            if display:\n                print(self.format_display(play_chord, play_value))\n        \n        return play_list\n\n    @staticmethod\n    def format_display(key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the AvgPartition class with a list of integers and a limit.\n        \n        :param lst: List of integers to be partitioned.\n        :param limit: The maximum number of partitions.\n        \"\"\"\n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        \"\"\"\n        Determine the number of elements per partition and the remainder.\n        \n        :return: A tuple containing the number of elements per partition and the remainder.\n        \"\"\"\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Retrieve a specific partition of the list based on the index.\n        \n        :param index: The index of the partition to retrieve.\n        :return: A list representing the partition.\n        \"\"\"\n        size, remainder = self.set_num()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index < remainder:\n            end += 1\n        return self.lst[start:end]\n\n# Example usage:\n# avg_partition = AvgPartition([1, 2, 3, 4, 5, 6, 7, 8], 3)\n# print(avg_partition.get(0))  # Output: [1, 2, 3]\n# print(avg_partition.get(1))  # Output: [4, 5, 6]\n# print(avg_partition.get(2))  # Output: [7, 8]\n",
  "BalancedBrackets": "class BalancedBrackets:\n    def __init__(self, expr: str):\n        self.expr = expr\n        self.stack = []\n        self.left_brackets = \"({[\"\n        self.right_brackets = \")}]\"\n\n    def clear_expr(self):\n        # Remove all characters that are not brackets\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets + self.right_brackets)\n\n    def check_balanced_brackets(self) -> bool:\n        self.clear_expr()\n        for brkt in self.expr:\n            if brkt in self.left_brackets:\n                self.stack.append(brkt)\n            else:\n                if not self.stack:\n                    return False\n                current_brkt = self.stack.pop()\n                if (current_brkt == '(' and brkt != ')') or \\\n                   (current_brkt == '{' and brkt != '}') or \\\n                   (current_brkt == '[' and brkt != ']'):\n                    return False\n        return not self.stack\n\n# Example usage:\n# checker = BalancedBrackets(\"{[()]}\")\n# print(checker.check_balanced_brackets())  # Output: True\n",
  "BankAccount": "class InvalidAmountError(Exception):\n    \"\"\"Exception raised for errors in the input amount.\"\"\"\n    def __init__(self, message=\"Invalid amount\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InsufficientBalanceError(Exception):\n    \"\"\"Exception raised when there is insufficient balance for a transaction.\"\"\"\n    def __init__(self, message=\"Insufficient balance\"):\n        self.message = message\n        super().__init__(self.message)\n\n\nclass BankAccount:\n    def __init__(self, balance=0):\n        if balance < 0:\n            raise InvalidAmountError(\"Initial balance cannot be negative.\")\n        self._balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise InvalidAmountError()\n        self._balance += amount\n        return self._balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise InvalidAmountError()\n        if amount > self._balance:\n            raise InsufficientBalanceError()\n        self._balance -= amount\n        return self._balance\n\n    def view_balance(self):\n        return self._balance\n\n    def transfer(self, other_account, amount):\n        if not isinstance(other_account, BankAccount):\n            raise TypeError(\"Transfer target must be an instance of BankAccount.\")\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n\n# Example usage:\n# account1 = BankAccount(100)\n# account2 = BankAccount(50)\n# account1.transfer(account2, 30)\n# print(account1.view_balance())  # Output: 70\n# print(account2.view_balance())  # Output: 80\n",
  "BigNumCalculator": "class BigNumCalculator:\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        max_length = max(len(num1), len(num2))\n        num1_padded = num1.zfill(max_length)\n        num2_padded = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = (ord(num1_padded[i]) - ord('0')) + (ord(num2_padded[i]) - ord('0')) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.append(chr(digit + ord('0')))\n\n        if carry > 0:\n            result.append(chr(carry + ord('0')))\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        num1_local = num1\n        num2_local = num2\n        negative = False\n\n        if len(num1_local) < len(num2_local) or (len(num1_local) == len(num2_local) and num1_local < num2_local):\n            num1_local, num2_local = num2_local, num1_local\n            negative = True\n\n        max_length = max(len(num1_local), len(num2_local))\n        num1_local = num1_local.zfill(max_length)\n        num2_local = num2_local.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = (ord(num1_local[i]) - ord('0')) - (ord(num2_local[i]) - ord('0')) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.append(chr(digit_diff + ord('0')))\n\n        result = ''.join(reversed(result)).lstrip('0')\n\n        if negative and result != '':\n            result = '-' + result\n\n        return result if result != '' else '0'\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        len1 = len(num1)\n        len2 = len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1 = i + j\n                p2 = i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        result_str = ''.join(map(str, result)).lstrip('0')\n        return result_str if result_str != '' else '0'\n",
  "BinaryDataProcessor": "class BinaryDataProcessor:\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        self.binary_string = ''.join(c for c in self.binary_string if c in ('0', '1'))\n\n    def calculate_binary_info(self):\n        if not self.binary_string:\n            return {\"Zeroes\": 0.0, \"Ones\": 0.0, \"Bit length\": 0.0}\n        \n        zeroes_count = self.binary_string.count('0')\n        ones_count = len(self.binary_string) - zeroes_count\n        total_length = len(self.binary_string)\n\n        zeroes_percentage = zeroes_count / total_length\n        ones_percentage = ones_count / total_length\n\n        return {\n            \"Zeroes\": zeroes_percentage,\n            \"Ones\": ones_percentage,\n            \"Bit length\": float(total_length)\n        }\n\n    def convert_to_ascii(self):\n        if len(self.binary_string) % 8 != 0:\n            raise ValueError(\"Binary string length is not a multiple of 8, cannot convert to ASCII.\")\n        \n        ascii_string = ''\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            ascii_string += chr(int(byte, 2))\n        return ascii_string\n\n    def convert_to_utf8(self):\n        return self.convert_to_ascii()\n\n# Example usage:\n# processor = BinaryDataProcessor(\"1100100011001001\")\n# print(processor.calculate_binary_info())\n# print(processor.convert_to_ascii())\n# print(processor.convert_to_utf8())\n",
  "BitStatusUtil": "class BitStatusUtil:\n    @staticmethod\n    def add(states, stat):\n        BitStatusUtil.check(states, stat)\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        BitStatusUtil.check(states, stat)\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        BitStatusUtil.check(states, stat)\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(*args):\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n\n# Example usage:\n# try:\n#     new_states = BitStatusUtil.add(2, 6)\n#     print(\"New states:\", new_states)\n#     print(\"Has status:\", BitStatusUtil.has(new_states, 6))\n#     updated_states = BitStatusUtil.remove(new_states, 6)\n#     print(\"Updated states:\", updated_states)\n# except ValueError as e:\n#     print(e)\n",
  "BlackjackGame": "import random\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        suits = [\"S\", \"C\", \"D\", \"H\"]\n        ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank == \"A\":\n                value += 11\n                num_aces += 1\n            else:\n                value += 10\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            return \"Player wins\" if player_value <= dealer_value else \"Dealer wins\"\n        elif player_value > 21:\n            return \"Dealer wins\"\n        elif dealer_value > 21:\n            return \"Player wins\"\n        else:\n            return \"Player wins\" if player_value > dealer_value else \"Dealer wins\"\n",
  "BookManagement": "class BookManagement:\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title: str, quantity: int = 1):\n        \"\"\"Add a book to the inventory with an optional quantity.\"\"\"\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title: str, quantity: int):\n        \"\"\"Remove a specified quantity of a book from the inventory.\"\"\"\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise RuntimeError(\"Insufficient quantity or book not found\")\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self) -> dict:\n        \"\"\"View the entire inventory.\"\"\"\n        return self.inventory.copy()\n\n    def view_book_quantity(self, title: str) -> int:\n        \"\"\"Check the quantity of a specific book in the inventory.\"\"\"\n        return self.inventory.get(title, 0)\n",
  "BookManagementDB": "import sqlite3\nfrom typing import List, Tuple\n\nclass BookManagementDB:\n    def __init__(self, db_name: str):\n        try:\n            self.connection = sqlite3.connect(db_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def __del__(self):\n        self.connection.close()\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS books (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            author TEXT NOT NULL,\n            available INTEGER NOT NULL\n        )\n        \"\"\"\n        try:\n            self.connection.execute(create_table_sql)\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def add_book(self, title: str, author: str):\n        insert_sql = \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\"\n        try:\n            self.connection.execute(insert_sql, (title, author))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def remove_book(self, book_id: int):\n        delete_sql = \"DELETE FROM books WHERE id = ?\"\n        try:\n            self.connection.execute(delete_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def borrow_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 0 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def return_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 1 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def search_books(self) -> List[Tuple[int, str, str, int]]:\n        select_sql = \"SELECT * FROM books\"\n        try:\n            cursor = self.connection.execute(select_sql)\n            books = [(row[0], row[1], row[2], row[3]) for row in cursor.fetchall()]\n            return books\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def get_connection(self):\n        return self.connection\n",
  "BoyerMooreSearch": "class BoyerMooreSearch:\n    def __init__(self, text: str, pattern: str):\n        self._text = text\n        self._pattern = pattern\n        self._text_len = len(text)\n        self._pat_len = len(pattern)\n\n    def match_in_pattern(self, c: str) -> int:\n        \"\"\"Returns the index of a character in the pattern from the end to the beginning, or -1 if the character does not exist.\"\"\"\n        for i in range(self._pat_len - 1, -1, -1):\n            if c == self._pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        \"\"\"Identifies the first mismatch between the pattern and the text starting from the end of the pattern, or -1 if there is no mismatch.\"\"\"\n        for i in range(self._pat_len - 1, -1, -1):\n            if self._pattern[i] != self._text[current_pos + i]:\n                return current_pos + i\n        return -1\n\n    def bad_character_heuristic(self) -> list[int]:\n        \"\"\"Finds all starting positions in the text where the pattern matches using the Boyer-Moore algorithm's bad character rule.\"\"\"\n        positions = []\n        i = 0\n        while i <= self._text_len - self._pat_len:\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                mismatched_char = self._text[mismatch_index]\n                match_index = self.match_in_pattern(mismatched_char)\n                if match_index == -1:\n                    i += (mismatch_index - i + 1)\n                else:\n                    i += (mismatch_index - match_index)\n        return positions\n",
  "Calculator": "import re\nfrom collections import deque\nfrom math import pow\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: pow(x, y)\n        }\n\n    def calculate(self, expression: str) -> float:\n        if not expression.strip():\n            return 0.0\n\n        operand_stack = deque()\n        operator_stack = deque()\n        num_buffer = []\n\n        tokens = re.findall(r'\\d+\\.\\d+|\\d+|[+\\-*/^()]', expression.replace(' ', ''))\n\n        for token in tokens:\n            if re.match(r'\\d+\\.\\d+|\\d+', token):\n                operand_stack.append(float(token))\n            elif token in self.operators:\n                while (operator_stack and operator_stack[-1] != '(' and\n                       self.precedence(operator_stack[-1]) >= self.precedence(token)):\n                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                operator_stack.append(token)\n            elif token == '(':\n                operator_stack.append(token)\n            elif token == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                operator_stack.pop()\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op: str) -> int:\n        return {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }.get(op, 0)\n\n    def apply_operator(self, operand_stack: deque, operator_stack: deque) -> (deque, deque):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        try:\n            result = self.operators[op](operand1, operand2)\n        except ZeroDivisionError:\n            raise ValueError(\"Division by zero encountered in the expression.\")\n\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "CalendarUtil": "import datetime\nfrom typing import List, Tuple\n\nclass CalendarUtil:\n    class Event:\n        def __init__(self, date: datetime.datetime, start_time: datetime.datetime, end_time: datetime.datetime, description: str):\n            self.date = date\n            self.start_time = start_time\n            self.end_time = end_time\n            self.description = description\n\n        def __eq__(self, other):\n            return (self.date == other.date and\n                    self.start_time == other.start_time and\n                    self.end_time == other.end_time and\n                    self.description == other.description)\n\n    def __init__(self):\n        self.events: List[CalendarUtil.Event] = []\n\n    def add_event(self, event: Event):\n        if event not in self.events:\n            self.events.append(event)\n\n    def remove_event(self, event: Event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date: datetime.datetime) -> List[Event]:\n        events_on_date = []\n        for event in self.events:\n            if event.date.date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time: datetime.datetime, end_time: datetime.datetime) -> bool:\n        for event in self.events:\n            if start_time < event.end_time and end_time > event.start_time:\n                return False\n        return True\n\n    def get_available_slots(self, date: datetime.datetime) -> List[Tuple[datetime.datetime, datetime.datetime]]:\n        available_slots = []\n        start_time = datetime.datetime.combine(date, datetime.time.min)\n        end_time = datetime.datetime.combine(date, datetime.time.max)\n\n        while start_time < end_time:\n            slot_end_time = start_time + datetime.timedelta(hours=1)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time = slot_end_time\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events: int) -> List[Event]:\n        now = datetime.datetime.now()\n        upcoming_events = [event for event in self.events if event.start_time >= now]\n        return upcoming_events[:num_events]\n\ndef time_from_timestamp(timestamp: float) -> datetime.datetime:\n    return datetime.datetime.fromtimestamp(timestamp)\n",
  "CamelCaseMap": "class CamelCaseMap:\n    def __init__(self):\n        self.data = {}\n        self.insertion_order = []\n\n    @staticmethod\n    def to_camel_case(key: str) -> str:\n        camel_case_key = ''\n        capitalize = False\n        for char in key:\n            if char == '_':\n                capitalize = True\n            else:\n                camel_case_key += char.upper() if capitalize else char\n                capitalize = False\n        return camel_case_key\n\n    def convert_key(self, key: str) -> str:\n        return self.to_camel_case(key)\n\n    def set_item(self, key: str, value: str) -> None:\n        camel_key = self.convert_key(key)\n        if camel_key not in self.data:\n            self.insertion_order.append(camel_key)\n        self.data[camel_key] = value\n\n    def get_item(self, key: str) -> str:\n        camel_key = self.convert_key(key)\n        try:\n            return self.data[camel_key]\n        except KeyError:\n            raise KeyError(f\"Key '{key}' not found in the map.\")\n\n    def del_item(self, key: str) -> None:\n        camel_key = self.convert_key(key)\n        if camel_key in self.data:\n            del self.data[camel_key]\n            self.insertion_order.remove(camel_key)\n\n    def len(self) -> int:\n        return len(self.data)\n\n    def __iter__(self):\n        return iter(self.insertion_order)\n\n# Example usage:\n# camel_case_map = CamelCaseMap()\n# camel_case_map.set_item('first_name', 'John')\n# camel_case_map.set_item('last_name', 'Doe')\n# print(camel_case_map.get_item('first_name'))  # Output: John\n# print(camel_case_map.len())  # Output: 2\n# camel_case_map.del_item('last_name')\n# print(camel_case_map.len())  # Output: 1\n",
  "ChandrasekharSieve": "class ChandrasekharSieve:\n    def __init__(self, n):\n        if n < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def get_primes(self):\n        return self.primes\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        return [i for i in range(2, self.n + 1) if sieve[i]]\n\n# Example usage:\n# sieve = ChandrasekharSieve(30)\n# print(sieve.get_primes())\n",
  "Chat": "from datetime import datetime\nfrom collections import defaultdict\n\nclass Chat:\n    class Message:\n        def __init__(self, sender, receiver, message, timestamp):\n            self.sender = sender\n            self.receiver = receiver\n            self.message = message\n            self.timestamp = timestamp\n\n    def __init__(self):\n        self.users = defaultdict(list)\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = self.get_current_time()\n        message_info = self.Message(sender, receiver, message, timestamp)\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        return self.users.get(username, [])\n\n    def get_users(self):\n        return dict(self.users)\n\n    @staticmethod\n    def get_current_time():\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "ClassRegistrationSystem": "class Student:\n    def __init__(self, name, major):\n        self.name = name\n        self.major = major\n\n    def get_name(self):\n        return self.name\n\n    def get_major(self):\n        return self.major\n\n    def set_name(self, name):\n        self.name = name\n\n    def set_major(self, major):\n        self.major = major\n\n    def __eq__(self, other):\n        return self.name == other.name and self.major == other.major\n\n\nclass ClassRegistrationSystem:\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, new_student):\n        if any(student.get_name() == new_student.get_name() for student in self.students):\n            return 0\n        self.students.append(new_student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        if class_name not in self.students_registration_classes[student_name]:\n            self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        return [student.get_name() for student in self.students if student.get_major() == major]\n\n    def get_all_majors(self):\n        return list(set(student.get_major() for student in self.students))\n\n    def get_most_popular_class_in_major(self, major):\n        class_count = {}\n        for student in self.students:\n            if student.get_major() == major:\n                student_name = student.get_name()\n                if student_name in self.students_registration_classes:\n                    for class_name in self.students_registration_classes[student_name]:\n                        if class_name in class_count:\n                            class_count[class_name] += 1\n                        else:\n                            class_count[class_name] = 1\n\n        most_popular_class = None\n        max_count = 0\n        for class_name, count in class_count.items():\n            if count > max_count:\n                most_popular_class = class_name\n                max_count = count\n\n        return most_popular_class\n",
  "Classroom": "import datetime\nimport sys\n\nclass Course:\n    def __init__(self, name, start_time, end_time):\n        self.name = name\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.start_time == other.start_time and\n                self.end_time == other.end_time)\n\nclass Classroom:\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_tm = self.string_to_tm(check_time)\n\n        for course in self.courses:\n            start_tm = self.string_to_tm(course.start_time)\n            end_tm = self.string_to_tm(course.end_time)\n\n            if not all([check_tm, start_tm, end_tm]):\n                sys.stderr.write(\"Time conversion failed\\n\")\n                return False\n\n            if self.is_time_conflict(check_tm, check_tm, start_tm, end_tm):\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        new_start_tm = self.string_to_tm(new_course.start_time)\n        new_end_tm = self.string_to_tm(new_course.end_time)\n\n        if not all([new_start_tm, new_end_tm]):\n            sys.stderr.write(\"Time conversion failed\\n\")\n            return True\n\n        for course in self.courses:\n            start_tm = self.string_to_tm(course.start_time)\n            end_tm = self.string_to_tm(course.end_time)\n\n            if not all([start_tm, end_tm]):\n                sys.stderr.write(\"Time conversion failed\\n\")\n                return True\n\n            if self.is_time_conflict(start_tm, end_tm, new_start_tm, new_end_tm):\n                return False\n        return True\n\n    def has_course(self, course):\n        return course in self.courses\n\n    def string_to_tm(self, time_str):\n        try:\n            return datetime.datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(f\"Invalid time format: {time_str}\")\n\n    def is_time_conflict(self, start1, end1, start2, end2):\n        # Convert time objects to datetime objects for comparison\n        dummy_date = datetime.date(1, 1, 1)\n        dt1_start = datetime.datetime.combine(dummy_date, start1)\n        dt1_end = datetime.datetime.combine(dummy_date, end1)\n        dt2_start = datetime.datetime.combine(dummy_date, start2)\n        dt2_end = datetime.datetime.combine(dummy_date, end2)\n\n        return (dt1_start <= dt2_end and dt1_end >= dt2_start)\n\n# Example usage:\n# classroom = Classroom(1)\n# course1 = Course(\"Math\", \"09:00\", \"10:00\")\n# classroom.add_course(course1)\n# print(classroom.is_free_at(\"09:30\"))  # Should print False\n# print(classroom.check_course_conflict(Course(\"Science\", \"10:00\", \"11:00\")))  # Should print True\n",
  "CombinationCalculator": "import math\nfrom itertools import combinations\nfrom typing import List\n\nclass CombinationCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m < 0 or m > n:\n            return 0\n        if m == 0 or n == m:\n            return 1\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> float:\n        if n < 0:\n            return float('nan')\n        if n > 63:\n            return float('inf')\n        return (1 << n) - 1 if n != 63 else float('inf')\n\n    def select(self, m: int) -> List[List[str]]:\n        if m < 0 or m > len(self.datas):\n            return []\n        return [list(comb) for comb in combinations(self.datas, m)]\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n# Example usage:\n# calculator = CombinationCalculator([\"a\", \"b\", \"c\"])\n# print(calculator.count(3, 2))  # Output: 3\n# print(calculator.count_all(3))  # Output: 7\n# print(calculator.select(2))    # Output: [['a', 'b'], ['a', 'c'], ['b', 'c']]\n# print(calculator.select_all()) # Output: [['a'], ['b'], ['c'], ['a', 'b'], ['a', 'c'], ['b', 'c'], ['a', 'b', 'c']]\n",
  "ComplexCalculator": "import cmath\n\nclass ComplexCalculator:\n    @staticmethod\n    def add(c1: complex, c2: complex) -> complex:\n        return complex(c1.real + c2.real, c1.imag + c2.imag)\n\n    @staticmethod\n    def subtract(c1: complex, c2: complex) -> complex:\n        return complex(c1.real - c2.real, c1.imag - c2.imag)\n\n    @staticmethod\n    def multiply(c1: complex, c2: complex) -> complex:\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1: complex, c2: complex) -> complex:\n        if c2 == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        denominator = c2.real * c2.real + c2.imag * c2.imag\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)\n",
  "CookiesUtil": "import json\nimport os\n\nclass CookiesUtil:\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response):\n        if 'cookies' in response:\n            self.cookies = response['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        cookies_data = {}\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n        except FileNotFoundError:\n            print(f\"Error: The file {self.cookies_file} does not exist.\", file=os.sys.stderr)\n        except json.JSONDecodeError as e:\n            print(f\"Error reading JSON file: {e}\", file=os.sys.stderr)\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n        \n        return cookies_data\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file, indent=4)\n            return True\n        except IOError as e:\n            print(f\"Error writing JSON file: {e}\", file=os.sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n            return False\n\n    def set_cookies(self, request):\n        cookies_str = '; '.join(f\"{key}={value}\" for key, value in self.cookies.items())\n        request['cookies'] = cookies_str\n",
  "CSVProcessor": "import csv\nimport os\n\nclass CSVProcessor:\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        try:\n            with open(file_name, mode='r', newline='', encoding='utf-8') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = [row for row in reader]\n            return title, data\n        except FileNotFoundError:\n            print(f\"Error: The file {file_name} was not found.\")\n            return [], []\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return [], []\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, mode='w', newline='', encoding='utf-8') as file:\n                writer = csv.writer(file)\n                for row in data:\n                    writer.writerow(row)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing to the file {file_name}: {e}\")\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        if not title or not data:\n            return 0\n        if N >= len(title):\n            print(f\"Error: Column index {N} does not exist.\")\n            return 0\n\n        # Process the specified column\n        for row in data:\n            if N < len(row):\n                row[N] = row[N].upper()\n\n        # Write the processed data to a new file\n        base_name, ext = os.path.splitext(save_file_name)\n        new_file_name = f\"{base_name}_process{ext}\"\n        return self.write_csv([title] + data, new_file_name)\n\n# Example usage:\n# processor = CSVProcessor()\n# processor.process_csv_data(1, 'example.csv')\n",
  "CurrencyConverter": "class CurrencyConverter:\n    def __init__(self):\n        self.rates = {\n            \"USD\": 1.0,\n            \"EUR\": 0.85,\n            \"GBP\": 0.72,\n            \"JPY\": 110.15,\n            \"CAD\": 1.23,\n            \"AUD\": 1.34,\n            \"CNY\": 6.40,\n        }\n        self.currency_order = [\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CNY\"]\n\n    def convert(self, amount, from_currency, to_currency):\n        if from_currency == to_currency:\n            return amount\n\n        if from_currency not in self.rates or to_currency not in self.rates:\n            raise ValueError(\"Unsupported currency\")\n\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n    def get_supported_currencies(self):\n        return self.currency_order\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        self.currency_order.append(currency)\n        return True\n\n    def update_currency_rate(self, currency, new_rate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return True\n",
  "DatabaseProcessor": "import sqlite3\n\nclass DatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def _open_database(self):\n        try:\n            return sqlite3.connect(self.database_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def create_table(self, table_name, key1='key1', key2='key2'):\n        db = self._open_database()\n        try:\n            cursor = db.cursor()\n            create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n            cursor.execute(create_table_query)\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n        finally:\n            db.close()\n\n    def insert_into_database(self, table_name, data):\n        db = self._open_database()\n        try:\n            cursor = db.cursor()\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.executemany(insert_query, [(item['name'], int(item['age'])) for item in data])\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert data: {e}\")\n        finally:\n            db.close()\n\n    def search_database(self, table_name, name):\n        db = self._open_database()\n        result = []\n        try:\n            cursor = db.cursor()\n            query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n            cursor.execute(query, (name,))\n            result = [list(row) for row in cursor.fetchall()]\n        except sqlite3.Error as e:\n            print(f\"Failed to search database: {e}\")\n        finally:\n            db.close()\n        return result\n\n    def delete_from_database(self, table_name, name):\n        db = self._open_database()\n        try:\n            cursor = db.cursor()\n            delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n            cursor.execute(delete_query, (name,))\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete data: {e}\")\n        finally:\n            db.close()\n",
  "DataStatistics": "class DataStatistics:\n    def mean(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        total_sum = sum(data)\n        return round(total_sum / len(data), 2)\n\n    def median(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        else:\n            return sorted_data[mid]\n\n    def mode(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        \n        count_map = {}\n        for num in data:\n            count_map[num] = count_map.get(num, 0) + 1\n        \n        max_count = max(count_map.values())\n        modes = [num for num, count in count_map.items() if count == max_count]\n        \n        return modes\n",
  "DataStatistics2": "import math\nfrom typing import List\n\nclass DataStatistics2:\n    def __init__(self, data: List[float]):\n        self.data = data\n\n    def get_sum(self) -> float:\n        return sum(self.data)\n\n    def get_min(self) -> float:\n        return min(self.data) if self.data else float('inf')\n\n    def get_max(self) -> float:\n        return max(self.data) if self.data else float('-inf')\n\n    def get_variance(self) -> float:\n        if not self.data:\n            return 0.0\n        mean = self.get_sum() / len(self.data)\n        variance = sum((x - mean) ** 2 for x in self.data) / len(self.data)\n        return round(variance, 2)\n\n    def get_std_deviation(self) -> float:\n        variance = self.get_variance()\n        std_dev = math.sqrt(variance)\n        return round(std_dev, 2)\n\n    def get_correlation(self) -> float:\n        if len(self.data) < 2:\n            return 1.0\n        mean = self.get_sum() / len(self.data)\n        sum_prod = sum_sq = 0.0\n        for value in self.data:\n            diff = value - mean\n            sum_prod += diff * diff\n            sum_sq += diff * diff\n        # Since sum_prod and sum_sq are the same in this context, correlation would be 1.0\n        # unless there's another dataset to compare against. Assuming single dataset context.\n        return 1.0 if sum_sq == 0 else sum_prod / sum_sq\n\n# Note: The get_correlation method in the original C++ code seems incorrect as it compares\n# the dataset with itself, resulting in a correlation of 1.0 unless the dataset is constant.\n# In a typical scenario, correlation is calculated between two datasets.\n",
  "DataStatistics4": "import math\nfrom typing import List\nimport numpy as np\n\nclass DataStatistics4:\n    @staticmethod\n    def correlation_coefficient(data1: List[float], data2: List[float]) -> float:\n        \"\"\"\n        Calculate the correlation coefficient between two sets of numerical data.\n        \n        Parameters:\n        data1 (List[float]): First set of numerical data.\n        data2 (List[float]): Second set of numerical data.\n        \n        Returns:\n        float: Correlation coefficient.\n        \n        Raises:\n        ValueError: If the input vectors have different lengths.\n        \"\"\"\n        if len(data1) != len(data2):\n            raise ValueError(\"Input vectors must have the same length.\")\n        \n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n        \n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator1 = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)))\n        denominator2 = math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n        \n        denominator = denominator1 * denominator2\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data: List[float]) -> float:\n        \"\"\"\n        Calculate the skewness of a set of numerical data.\n        \n        Parameters:\n        data (List[float]): Set of numerical data.\n        \n        Returns:\n        float: Skewness of the data.\n        \"\"\"\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n        \n        if std_deviation == 0:\n            return 0.0\n        \n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3)\n        return skewness\n\n    @staticmethod\n    def kurtosis(data: List[float]) -> float:\n        \"\"\"\n        Calculate the kurtosis of a set of numerical data.\n        \n        Parameters:\n        data (List[float]): Set of numerical data.\n        \n        Returns:\n        float: Kurtosis of the data.\n        \"\"\"\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_dev = math.sqrt(variance)\n        \n        if std_dev == 0:\n            return float('nan')\n        \n        fourth_moment = sum((x - mean) ** 4 for x in data) / n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3.0\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data: List[float], mu: float, sigma: float) -> List[float]:\n        \"\"\"\n        Compute the probability density function (PDF) values for a given set of numerical data\n        based on specified mean (mu) and standard deviation (sigma).\n        \n        Parameters:\n        data (List[float]): Set of numerical data.\n        mu (float): Mean of the distribution.\n        sigma (float): Standard deviation of the distribution.\n        \n        Returns:\n        List[float]: PDF values for the data.\n        \"\"\"\n        pi = math.pi\n        pdf_values = [(1 / (sigma * math.sqrt(2 * pi))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n",
  "DecryptionUtils": "class DecryptionUtils:\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        shift = shift % 26\n        plaintext = []\n        for c in ciphertext:\n            if c.isalpha():\n                base = 'A' if c.isupper() else 'a'\n                shifted_char = chr((ord(c) - ord(base) - shift + 26) % 26 + ord(base))\n                plaintext.append(shifted_char)\n            else:\n                plaintext.append(c)\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = []\n        key_length = len(self.key)\n        key_index = 0\n\n        for c in ciphertext:\n            if c.isalpha():\n                shift = ord(self.key[key_index % key_length].lower()) - ord('a')\n                base = 'a' if c.islower() else 'A'\n                decrypted_char = chr((ord(c.lower()) - ord('a') - shift + 26) % 26 + ord(base))\n                decrypted_text.append(decrypted_char)\n                key_index += 1\n            else:\n                decrypted_text.append(c)\n        return ''.join(decrypted_text)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        if rails <= 1:\n            return encrypted_text\n\n        n = len(encrypted_text)\n        fence = [['\\n'] * n for _ in range(rails)]\n\n        direction = -1\n        row = 0\n        col = 0\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = '*'\n            col += 1\n            row += direction\n\n        index = 0\n        for r in range(rails):\n            for c in range(n):\n                if fence[r][c] == '*':\n                    fence[r][c] = encrypted_text[index]\n                    index += 1\n\n        direction = -1\n        row = 0\n        col = 0\n        plain_text = []\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text.append(fence[row][col])\n            col += 1\n            row += direction\n\n        return ''.join(plain_text)\n",
  "DiscountStrategy": "class DiscountStrategy:\n    class PromoType:\n        FidelityPromo = 'fidelity'\n        BulkItemPromo = 'bulk_item'\n        LargeOrderPromo = 'large_order'\n        NoPromo = 'no_promo'\n\n    def __init__(self, customer, cart, promo=PromoType.NoPromo):\n        self.customer = customer\n        self.cart = cart\n        self.promo = promo\n\n    def total(self):\n        total = 0.0\n        for item in self.cart:\n            try:\n                quantity = item.get(\"quantity\", 0)\n                price = item.get(\"price\", 0)\n                total += quantity * price\n            except KeyError:\n                print(\"Error: Missing 'quantity' or 'price' in cart item.\")\n        return total\n\n    def due(self):\n        return self.total() - self.promotion()\n\n    def promotion(self):\n        if self.promo == self.PromoType.FidelityPromo:\n            return self.fidelity_discount()\n        elif self.promo == self.PromoType.BulkItemPromo:\n            return self.bulk_item_discount()\n        elif self.promo == self.PromoType.LargeOrderPromo:\n            return self.large_order_discount()\n        else:\n            return 0.0\n\n    def fidelity_discount(self):\n        try:\n            fidelity = self.customer.get(\"fidelity\", 0)\n            if fidelity >= 1000.0:\n                return 0.05 * self.total()\n        except KeyError:\n            print(\"Error: Missing 'fidelity' in customer information.\")\n        return 0.0\n\n    def bulk_item_discount(self):\n        discount = 0.0\n        for item in self.cart:\n            try:\n                quantity = item.get(\"quantity\", 0)\n                price = item.get(\"price\", 0)\n                if quantity >= 20:\n                    discount += quantity * price * 0.1\n            except KeyError:\n                print(\"Error: Missing 'quantity' or 'price' in cart item.\")\n        return discount\n\n    def large_order_discount(self):\n        num_items = len(self.cart)\n        if num_items >= 10:\n            return 0.07 * self.total()\n        return 0.0\n",
  "EightPuzzle": "from collections import deque\nimport copy\n\nclass EightPuzzle:\n    def __init__(self, initial_state=None):\n        self.initial_state = initial_state if initial_state else []\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return -1, -1\n\n    def move(self, state, direction):\n        i, j = self.find_blank(state)\n        new_state = copy.deepcopy(state)\n\n        if direction == \"up\" and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == \"down\" and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == \"left\" and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == \"right\" and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        moves = []\n        i, j = self.find_blank(state)\n\n        if i > 0:\n            moves.append(\"up\")\n        if i < 2:\n            moves.append(\"down\")\n        if j > 0:\n            moves.append(\"left\")\n        if j < 2:\n            moves.append(\"right\")\n\n        return moves\n\n    def solve(self):\n        open_list = deque([(self.initial_state, [])])\n        closed_list = set()\n\n        while open_list:\n            current_state, path = open_list.popleft()\n            closed_list.add(tuple(map(tuple, current_state)))\n\n            if current_state == self.goal_state:\n                return path\n\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if tuple(map(tuple, new_state)) not in closed_list:\n                    new_path = path + [move]\n                    open_list.append((new_state, new_path))\n\n        return []\n\n    def __eq__(self, other):\n        if isinstance(other, EightPuzzle):\n            return self.initial_state == other.initial_state\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        return f\"EightPuzzle(initial_state={self.initial_state})\"\n\n    def reinitialize(self, initial_state):\n        self.initial_state = initial_state\n",
  "EmailClient": "import time\nfrom datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr, capacity):\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def get_current_time(self):\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": str(size),\n                \"time\": self.get_current_time(),\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        if not self.inbox:\n            return {}\n        for email in self.inbox:\n            if email[\"state\"] == \"unread\":\n                email[\"state\"] = \"read\"\n                return email\n        return {}\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return occupied_size + size > self.capacity\n\n    def get_occupied_size(self):\n        return sum(int(email[\"size\"]) for email in self.inbox)\n\n    def clear_inbox(self, size):\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            freed_space += int(self.inbox[0][\"size\"])\n            self.inbox.pop(0)\n",
  "EncryptionUtils": "class EncryptionUtils:\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        ciphertext = []\n        for ch in plaintext:\n            if ch.isalpha():\n                ascii_offset = 65 if ch.isupper() else 97\n                shifted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ascii_offset)\n                ciphertext.append(shifted_char)\n            else:\n                ciphertext.append(ch)\n        return ''.join(ciphertext)\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = []\n        key_length = len(self.key)\n        for i, ch in enumerate(plain_text):\n            if ch.isalpha():\n                shift = ord(self.key[i % key_length].lower()) - ord('a')\n                encrypted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text.append(encrypted_char.upper() if ch.isupper() else encrypted_char)\n            else:\n                encrypted_text.append(ch)\n        return ''.join(encrypted_text)\n\n    def rail_fence_cipher(self, plain_text, rails):\n        if rails <= 0:\n            raise ValueError(\"Rails must be greater than zero.\")\n        \n        fence = [''] * rails\n        direction = -1\n        row = 0\n\n        for ch in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row] += ch\n            row += direction\n\n        return ''.join(fence)\n",
  "ExcelProcessor": "import pandas as pd\nfrom openpyxl import Workbook\nfrom openpyxl.utils.exceptions import InvalidFileException\nimport os\n\nclass ExcelProcessor:\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        try:\n            # Validate file extension\n            if not file_name.endswith('.xlsx'):\n                raise ValueError(\"File must be an Excel file with .xlsx extension.\")\n            \n            # Read the Excel file\n            df = pd.read_excel(file_name, dtype=str)\n            data = df.values.tolist()\n            \n            # Convert data types appropriately\n            for row in data:\n                for i in range(len(row)):\n                    try:\n                        row[i] = int(row[i])\n                    except ValueError:\n                        pass\n            \n            return data\n        except FileNotFoundError:\n            print(f\"Error: The file {file_name} was not found.\")\n            return []\n        except InvalidFileException:\n            print(f\"Error: The file {file_name} is not a valid Excel file.\")\n            return []\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return []\n\n    def write_excel(self, data, file_name):\n        try:\n            # Create a workbook and select the active worksheet\n            wb = Workbook()\n            ws = wb.active\n            \n            # Write data to the worksheet\n            for row in data:\n                ws.append(row)\n            \n            # Save the workbook\n            wb.save(file_name)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing to the file {file_name}: {e}\")\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if not data or N >= len(data[0]):\n            print(\"Error: Data is empty or column index is out of bounds.\")\n            return 0, \"\"\n\n        new_data = []\n        for row in data:\n            new_row = row.copy()\n            value = row[N]\n            if isinstance(value, str):\n                if not value[0].isdigit():\n                    new_value = value.upper()\n                else:\n                    new_value = value[0]\n            elif isinstance(value, int):\n                new_value = value\n            else:\n                print(f\"Unexpected data type in column {N}: {type(value)}\")\n                continue\n            \n            new_row.append(new_value)\n            new_data.append(new_row)\n\n        base_name, ext = os.path.splitext(save_file_name)\n        new_file_name = f\"{base_name}_process{ext}\"\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name\n\n# Example usage:\n# processor = ExcelProcessor()\n# success, new_file_name = processor.process_excel_data(2, 'example.xlsx')\n# print(f\"Processed file saved as {new_file_name} with success status {success}.\")\n",
  "ExpressionCalculator": "import re\nfrom collections import deque\nfrom math import fmod\n\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n        self.postfix_stack = deque()\n\n    def calculate(self, expression: str) -> float:\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        reversed_postfix_stack = deque(reversed(self.postfix_stack))\n\n        while reversed_postfix_stack:\n            current_op = reversed_postfix_stack.pop()\n\n            if not self.is_operator(current_op):\n                current_op = re.sub(r'~', '-', current_op)\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = re.sub(r'~', '-', first_value)\n                second_value = re.sub(r'~', '-', second_value)\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(result_stack.pop())\n\n    def prepare(self, expression: str):\n        op_stack = deque([','])\n        arr = expression\n        current_index = 0\n        count = 0\n        self.postfix_stack.clear()\n\n        for i, char in enumerate(arr):\n            current_op = arr[i]\n\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(arr[current_index:current_index + count])\n                peek_op = op_stack[-1]\n\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(op_stack.pop())\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(op_stack.pop())\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index:current_index + count])):\n            self.postfix_stack.append(arr[current_index:current_index + count])\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(op_stack.pop())\n\n    @staticmethod\n    def is_operator(c: str) -> bool:\n        operators = {'+', '-', '*', '/', '(', ')', '%'}\n        return c in operators\n\n    def compare(self, cur: str, peek: str) -> bool:\n        cur_op = '/' if cur == '%' else cur\n        peek_op = '/' if peek == '%' else peek\n        return self.operat_priority[ord(peek_op) - 40] >= self.operat_priority[ord(cur_op) - 40]\n\n    @staticmethod\n    def _calculate(first_value: str, second_value: str, current_op: str) -> float:\n        f = float(first_value)\n        s = float(second_value)\n\n        if current_op == '+':\n            return f + s\n        elif current_op == '-':\n            return f - s\n        elif current_op == '*':\n            return f * s\n        elif current_op == '/':\n            if s == 0:\n                raise ZeroDivisionError(\"Division by zero\")\n            return f / s\n        elif current_op == '%':\n            return fmod(f, s)\n\n        raise ValueError(f\"Unexpected operator: {current_op}\")\n\n    @staticmethod\n    def transform(expression: str) -> str:\n        expr = re.sub(r'\\s+', '', expression)\n        expr = re.sub(r'=$', '', expr)\n\n        for i in range(len(expr)):\n            if expr[i] == '-':\n                if i == 0:\n                    expr = expr[:i] + '~' + expr[i + 1:]\n                else:\n                    prev_c = expr[i - 1]\n                    if prev_c in '+-*/(' or prev_c in 'Ee':\n                        expr = expr[:i] + '~' + expr[i + 1:]\n\n        if expr.startswith('~') and len(expr) > 1 and expr[1] == '(':\n            expr = '-' + expr\n            return \"0\" + expr\n        else:\n            return expr\n",
  "FitnessTracker": "class FitnessTracker:\n    BMI_std = {\n        \"male\": [20.0, 25.0],\n        \"female\": [19.0, 24.0]\n    }\n\n    def __init__(self, height, weight, age, sex):\n        self._height = height\n        self._weight = weight\n        self._age = age\n        self._sex = sex.lower()\n\n    def get_bmi(self):\n        try:\n            return self._weight / (self._height * self._height)\n        except ZeroDivisionError:\n            print(\"Height cannot be zero.\")\n            return None\n\n    def condition_judge(self):\n        bmi = self.get_bmi()\n        if bmi is None:\n            return None\n        bmi_range = self.BMI_std.get(self._sex, [0.0, 0.0])\n        if bmi > bmi_range[1]:\n            return 1\n        elif bmi < bmi_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        if self._sex not in self.BMI_std:\n            print(\"Invalid sex provided.\")\n            return None\n\n        bmr = (10 * self._weight + 6.25 * self._height - 5 * self._age +\n               (5 if self._sex == \"male\" else -161))\n\n        condition = self.condition_judge()\n        if condition is None:\n            return None\n\n        activity_factors = {1: 1.2, -1: 1.6, 0: 1.4}\n        return bmr * activity_factors[condition]\n\n\n# Example usage:\n# tracker = FitnessTracker(1.75, 70, 30, \"male\")\n# print(\"BMI:\", tracker.get_bmi())\n# print(\"Condition:\", tracker.condition_judge())\n# print(\"Calorie Intake:\", tracker.calculate_calorie_intake())\n",
  "GomokuGame": "class GomokuGame:\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def get_board(self):\n        return self.board\n\n    def _check_five_in_a_row(self, row, col, direction):\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5\n",
  "Hotel": "class Hotel:\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize a new hotel with a name and initial room availability.\n\n        :param name: Name of the hotel\n        :param rooms: Dictionary with room types as keys and number of available rooms as values\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Book rooms for a guest.\n\n        :param room_type: Type of room to book\n        :param room_number: Number of rooms to book\n        :param name: Name of the guest\n        :return: Success message or available room count if less than requested\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return \"False.\"\n\n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            if name in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] += room_number\n            else:\n                self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return str(self.available_rooms[room_type])\n        else:\n            return \"False.\"\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check-in guests who have already booked rooms.\n\n        :param room_type: Type of room to check-in\n        :param room_number: Number of rooms to check-in\n        :param name: Name of the guest\n        :return: True if check-in is successful, False otherwise\n        \"\"\"\n        if room_type not in self.booked_rooms:\n            return False\n\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                del self.booked_rooms[room_type][name]\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n            return True\n        return False\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check-out guests and make rooms available again.\n\n        :param room_type: Type of room to check-out\n        :param room_number: Number of rooms to check-out\n        \"\"\"\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms for a specific room type.\n\n        :param room_type: Type of room\n        :return: Number of available rooms\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n",
  "HRManagementSystem": "from typing import Dict, Optional, Union\n\nclass HRManagementSystem:\n    def __init__(self):\n        self.employees: Dict[int, Dict[str, Union[str, int]]] = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                \"name\": name,\n                \"position\": position,\n                \"department\": department,\n                \"salary\": salary\n            }\n            return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: Dict[str, Union[str, int]]) -> bool:\n        if employee_id not in self.employees:\n            return False\n\n        valid_keys = self.employees[employee_id].keys()\n        if not all(key in valid_keys for key in employee_info.keys()):\n            return False\n\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id: int) -> Optional[Dict[str, Union[str, int]]]:\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> Dict[int, Dict[str, Union[str, int]]]:\n        return {employee_id: {**employee_info, \"employee_ID\": employee_id} for employee_id, employee_info in self.employees.items()}\n",
  "Interpolation": "import numpy as np\n\nclass Interpolation:\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Perform linear interpolation on a set of 1D data points.\n\n        Parameters:\n        x (list or np.ndarray): Sorted list of x-coordinates of known data points.\n        y (list or np.ndarray): List of y-coordinates of known data points.\n        x_interp (list or np.ndarray): List of x-coordinates where interpolation is needed.\n\n        Returns:\n        list: List of interpolated y-values corresponding to x_interp.\n        \"\"\"\n        if not x or not y or not x_interp:\n            raise ValueError(\"Input vectors must not be empty.\")\n        if len(x) != len(y):\n            raise ValueError(\"The length of x and y must be the same.\")\n        \n        x = np.array(x)\n        y = np.array(y)\n        x_interp = np.array(x_interp)\n        \n        y_interp = []\n        for xi in x_interp:\n            if x[0] <= xi <= x[-1]:\n                idx = np.searchsorted(x, xi) - 1\n                yi = y[idx] + (y[idx + 1] - y[idx]) * (xi - x[idx]) / (x[idx + 1] - x[idx])\n                y_interp.append(yi)\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Perform bilinear interpolation on a set of 2D data points.\n\n        Parameters:\n        x (list or np.ndarray): Sorted list of x-coordinates of known data points.\n        y (list or np.ndarray): Sorted list of y-coordinates of known data points.\n        z (list of lists or np.ndarray): 2D array of z-coordinates of known data points.\n        x_interp (list or np.ndarray): List of x-coordinates where interpolation is needed.\n        y_interp (list or np.ndarray): List of y-coordinates where interpolation is needed.\n\n        Returns:\n        list: List of interpolated z-values corresponding to x_interp and y_interp.\n        \"\"\"\n        if not x or not y or not z or not x_interp or not y_interp:\n            raise ValueError(\"Input vectors must not be empty.\")\n        if len(x) != len(z) or len(y) != len(z[0]):\n            raise ValueError(\"The dimensions of x, y, and z must be compatible.\")\n        \n        x = np.array(x)\n        y = np.array(y)\n        z = np.array(z)\n        x_interp = np.array(x_interp)\n        y_interp = np.array(y_interp)\n        \n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            if x[0] <= xi <= x[-1] and y[0] <= yi <= y[-1]:\n                i = np.searchsorted(x, xi) - 1\n                j = np.searchsorted(y, yi) - 1\n                \n                z00 = z[i, j]\n                z01 = z[i, j + 1]\n                z10 = z[i + 1, j]\n                z11 = z[i + 1, j + 1]\n                \n                zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                      z10 * (xi - x[i]) * (y[j + 1] - yi) +\n                      z01 * (x[i + 1] - xi) * (yi - y[j]) +\n                      z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                z_interp.append(zi)\n        return z_interp\n",
  "IPAddress": "class IPAddress:\n    def __init__(self, ip_address: str):\n        self.ip_address = ip_address\n\n    def is_valid(self) -> bool:\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n\n        for octet in octets:\n            if not self._is_valid_octet(octet):\n                return False\n        return True\n\n    def get_octets(self) -> list:\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self) -> str:\n        if self.is_valid():\n            octets = self.get_octets()\n            binary_octets = [f\"{int(octet):08b}\" for octet in octets]\n            return '.'.join(binary_octets)\n        else:\n            return \"\"\n\n    def _is_valid_octet(self, octet: str) -> bool:\n        if not octet.isdigit() or not (0 <= int(octet) <= 255):\n            return False\n        # Check for leading zeros\n        if octet != '0' and octet.startswith('0'):\n            return False\n        return True\n",
  "IpUtil": "import socket\nimport ipaddress\n\nclass IpUtil:\n    @staticmethod\n    def is_valid_ipv4(ip_address: str) -> bool:\n        try:\n            ipaddress.IPv4Address(ip_address)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address: str) -> bool:\n        try:\n            ipaddress.IPv6Address(ip_address)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address: str) -> str:\n        if ip_address == \"0.0.0.0\":\n            try:\n                return socket.gethostname()\n            except socket.error:\n                return \"\"\n\n        try:\n            # Check if the IP is valid before attempting to get the hostname\n            if IpUtil.is_valid_ipv4(ip_address):\n                return socket.gethostbyaddr(ip_address)[0]\n            elif IpUtil.is_valid_ipv6(ip_address):\n                # For IPv6, socket.gethostbyaddr does not support it directly,\n                # so we need to handle it differently if needed.\n                # This example assumes only IPv4 is used for hostname lookup.\n                return \"\"\n        except (socket.herror, socket.gaierror):\n            pass\n\n        return \"\"\n\n# Example usage:\n# print(IpUtil.is_valid_ipv4(\"192.168.1.1\"))\n# print(IpUtil.is_valid_ipv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"))\n# print(IpUtil.get_hostname(\"192.168.1.1\"))\n# print(IpUtil.get_hostname(\"0.0.0.0\"))\n",
  "JobMarketplace": "class Job:\n    def __init__(self, job_title, company, requirements):\n        self.job_title = job_title\n        self.company = company\n        self.requirements = requirements\n\n    def __eq__(self, other):\n        return (self.job_title == other.job_title and\n                self.company == other.company and\n                self.requirements == other.requirements)\n\n\nclass Resume:\n    def __init__(self, name, skills, experience):\n        self.name = name\n        self.skills = skills\n        self.experience = experience\n\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.skills == other.skills and\n                self.experience == other.experience)\n\n\nclass JobMarketplace:\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        self.job_listings.append(Job(job_title, company, requirements))\n\n    def remove_job(self, job):\n        self.job_listings = [j for j in self.job_listings if j != job]\n\n    def submit_resume(self, name, skills, experience):\n        self.resumes.append(Resume(name, skills, experience))\n\n    def withdraw_resume(self, resume):\n        self.resumes = [r for r in self.resumes if r != resume]\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        for job in self.job_listings:\n            if criteria in job.job_title or any(criteria in req for req in job.requirements):\n                matching_jobs.append(job)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        return [resume for resume in self.resumes if self.matches_requirements(resume, job.requirements)]\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        return all(skill in resume.skills for skill in requirements)\n",
  "JSONProcessor": "import json\nimport os\n\nclass JSONProcessor:\n    \n    def read_json(self, file_path):\n        \"\"\"\n        Reads a JSON file from the specified file path and stores its contents in a JSON object.\n        \n        :param file_path: Path to the JSON file.\n        :return: Status code indicating success (1) or failure (0 or -1).\n        \"\"\"\n        try:\n            if not os.path.exists(file_path):\n                return 0\n            \n            with open(file_path, 'r') as file:\n                data = json.load(file)\n                if not data:\n                    return -1\n                self.json_data = data\n                return 1\n        except Exception as e:\n            print(f\"Error reading JSON file: {e}\")\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Writes a JSON object to the specified file path in a formatted manner with an indentation of 4 spaces.\n        \n        :param data: JSON data to write.\n        :param file_path: Path to the JSON file.\n        :return: Status code indicating success (1) or failure (-1).\n        \"\"\"\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, indent=4)\n            return 1\n        except Exception as e:\n            print(f\"Error writing JSON file: {e}\")\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Processes a JSON file by removing a specified key if it exists within the JSON structure.\n        \n        :param file_path: Path to the JSON file.\n        :param remove_key: Key to be removed from the JSON data.\n        :return: Status code indicating whether the specified key was successfully removed (1) or not (0).\n        \"\"\"\n        result = self.read_json(file_path)\n        if result != 1:\n            return 0\n        \n        if remove_key in self.json_data:\n            del self.json_data[remove_key]\n            return self.write_json(self.json_data, file_path)\n        else:\n            return 0\n",
  "KappaCalculator": "import numpy as np\n\nclass KappaCalculator:\n    @staticmethod\n    def kappa(test_data, k):\n        data_mat = np.array(test_data)\n\n        P0 = np.trace(data_mat)\n        xsum = np.sum(data_mat, axis=1)\n        ysum = np.sum(data_mat, axis=0)\n        total_sum = np.sum(data_mat)\n\n        Pe = np.dot(ysum, xsum) / (total_sum ** 2)\n        P0 /= total_sum\n\n        cohens_coefficient = (P0 - Pe) / (1 - Pe)\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(test_data, N, k, n):\n        data_mat = np.array(test_data)\n\n        sum_values = 0.0\n        P0 = 0.0\n\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum_values += data_mat[i, j]\n                temp += data_mat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n\n        P0 /= N\n\n        ysum = np.sum(data_mat, axis=0)\n        ysum = (ysum / sum_values) ** 2\n\n        Pe = np.sum(ysum)\n\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans\n\n# Example usage:\n# testData = [[...], [...], ...]  # Replace with actual data\n# k = number_of_categories\n# N = number_of_subjects\n# n = number_of_ratings_per_subject\n# print(KappaCalculator.kappa(testData, k))\n# print(KappaCalculator.fleiss_kappa(testData, N, k, n))\n",
  "LongestWord": "import re\n\nclass LongestWordFinder:\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word: str):\n        \"\"\"Add an individual word to the list of known words.\"\"\"\n        self.word_list.append(word.lower())\n\n    def find_longest_word(self, sentence: str) -> str:\n        \"\"\"Find the longest word in the sentence that is also in the list of known words.\"\"\"\n        longest_word = \"\"\n        \n        # Convert sentence to lowercase and remove punctuation\n        lower_sentence = re.sub(r'[^\\w\\s]', '', sentence).lower()\n        \n        # Split the sentence into words\n        words = lower_sentence.split()\n        \n        for word in words:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        \n        return longest_word\n\n    def get_word_list(self) -> list:\n        \"\"\"Retrieve the current list of known words.\"\"\"\n        return self.word_list\n",
  "MahjongConnect": "import random\nfrom typing import List, Tuple, Set\n\nclass MahjongConnect:\n    def __init__(self, board_size: Tuple[int, int], icons: List[str]):\n        self.BOARD_SIZE = board_size\n        self.ICONS = icons\n        self.board = self.create_board()\n\n    def create_board(self) -> List[List[str]]:\n        new_board = [['' for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        for i in range(self.BOARD_SIZE[0]):\n            for j in range(self.BOARD_SIZE[1]):\n                new_board[i][j] = random.choice(self.ICONS)\n        return new_board\n\n    def is_valid_move(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within bounds\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and\n                0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        # Check if positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if icons at positions are the same\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a path between the positions\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        visited: Set[Tuple[int, int]] = set()\n        stack: List[Tuple[int, int]] = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Explore neighbors\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + direction[0], y + direction[1]\n                if (0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1] and\n                        (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]):\n                    stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> None:\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self) -> bool:\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n",
  "Manacher": "class Manacher:\n    def __init__(self, input_string):\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, str_):\n        if (center - diff == -1) or (center + diff == len(str_)) or (str_[center - diff] != str_[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, str_)\n\n    def palindromic_string(self):\n        if not self.input_string:\n            return \"\"\n\n        # Transform the input string to include separators\n        new_input_string = \"|\".join(self.input_string) + \"|\"\n        max_length = 0\n        start = 0\n\n        # Find the longest palindromic substring\n        for i in range(len(new_input_string)):\n            length = self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Extract the longest palindromic substring from the transformed string\n        output_string = \"\"\n        for i in range(start - max_length, start + max_length + 1):\n            if new_input_string[i] != '|':\n                output_string += new_input_string[i]\n\n        return output_string\n\n# Example usage:\n# manacher = Manacher(\"babad\")\n# print(manacher.palindromic_string())  # Output could be \"bab\" or \"aba\"\n",
  "MetricsCalculator": "class MetricsCalculator:\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Predicted and true labels must be of the same length.\")\n        \n        for predicted, true_label in zip(predicted_labels, true_labels):\n            if predicted == 1 and true_label == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true_label == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true_label == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true_label == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision_value = self.precision(predicted_labels, true_labels)\n        recall_value = self.recall(predicted_labels, true_labels)\n        if precision_value + recall_value == 0.0:\n            return 0.0\n        return 2.0 * precision_value * recall_value / (precision_value + recall_value)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n",
  "MetricsCalculator2": "from typing import List, Tuple\n\nclass MetricsCalculator:\n    @staticmethod\n    def mrr(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        sum_mrr = 0.0\n        individual_mrr = []\n\n        for vec, k in data:\n            if k <= 0 or not vec:\n                individual_mrr.append(0.0)\n            else:\n                mrr_value = MetricsCalculator._calculate_mrr(vec)\n                individual_mrr.append(mrr_value)\n                sum_mrr += mrr_value\n\n        average_mrr = sum_mrr / len(data) if data else 0.0\n        return average_mrr, individual_mrr\n\n    @staticmethod\n    def map(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        separate_result = []\n\n        for sub_list, total_num in data:\n            if total_num == 0:\n                separate_result.append(0.0)\n                continue\n\n            ap = MetricsCalculator._calculate_map(sub_list)\n            separate_result.append(ap)\n\n        mean_ap = sum(separate_result) / len(separate_result) if separate_result else 0.0\n        return mean_ap, separate_result\n\n    @staticmethod\n    def _calculate_mrr(vec: List[int]) -> float:\n        try:\n            rank = vec.index(1) + 1\n            return 1.0 / rank\n        except ValueError:\n            return 0.0\n\n    @staticmethod\n    def _calculate_map(vec: List[int]) -> float:\n        sum_precision = 0.0\n        relevant_count = 0\n\n        for i, value in enumerate(vec):\n            if value == 1:\n                relevant_count += 1\n                sum_precision += relevant_count / (i + 1)\n\n        return sum_precision / relevant_count if relevant_count > 0 else 0.0\n",
  "MovieBookingSystem": "from datetime import datetime, time\nfrom typing import List, Tuple, Dict\n\nclass MovieBookingSystem:\n    def __init__(self):\n        self.movies: List[Dict[str, any]] = []\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': self.parse_time(start_time),\n            'end_time': self.parse_time(end_time),\n            'seats': [[0 for _ in range(n)] for _ in range(n)]\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name: str, seats_to_book: List[Tuple[int, int]]) -> str:\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    row, col = seat\n                    if 0 <= row < len(movie['seats']) and 0 <= col < len(movie['seats'][row]):\n                        if movie['seats'][row][col] == 0:\n                            movie['seats'][row][col] = 1\n                        else:\n                            return \"Booking failed.\"\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time: str, end_time: str) -> List[str]:\n        start = self.parse_time(start_time)\n        end = self.parse_time(end_time)\n\n        available_movies = []\n        for movie in self.movies:\n            if self.is_time_in_range(start, end, movie['start_time']) and self.is_time_in_range(start, end, movie['end_time']):\n                available_movies.append(movie['name'])\n        return available_movies\n\n    @staticmethod\n    def parse_time(time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(\"Failed to parse time\")\n\n    @staticmethod\n    def is_time_in_range(start: time, end: time, check: time) -> bool:\n        start_seconds = start.hour * 3600 + start.minute * 60\n        end_seconds = end.hour * 3600 + end.minute * 60\n        check_seconds = check.hour * 3600 + check.minute * 60\n        return start_seconds <= check_seconds <= end_seconds\n",
  "MovieTicketDB": "import sqlite3\n\nclass MovieTicketDB:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connection = None\n        self.connect()\n        self.create_table()\n\n    def __del__(self):\n        self.close_connection()\n\n    def connect(self):\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Unable to open database: {e}\")\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS tickets (\n            id INTEGER PRIMARY KEY,\n            movie_name TEXT,\n            theater_name TEXT,\n            seat_number TEXT,\n            customer_name TEXT\n        )\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(create_table_sql)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        insert_sql = \"\"\"\n        INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(insert_sql, (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert ticket: {e}\")\n\n    def search_tickets_by_customer(self, customer_name):\n        search_sql = \"\"\"\n        SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(search_sql, (customer_name,))\n            results = cursor.fetchall()\n            return [list(row) for row in results]\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to search tickets: {e}\")\n\n    def delete_ticket(self, ticket_id):\n        delete_sql = \"\"\"\n        DELETE FROM tickets WHERE id = ?\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(delete_sql, (ticket_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete ticket: {e}\")\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n",
  "MusicPlayer": "import random\nfrom typing import List\n\nclass MusicPlayer:\n    def __init__(self):\n        self.playlist: List[str] = []\n        self.current_song: str = \"\"\n        self.volume: int = 50\n\n    def add_song(self, song: str) -> None:\n        \"\"\"Add a song to the playlist.\"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song: str) -> None:\n        \"\"\"Remove a song from the playlist and stop playing it if it's the current song.\"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self) -> str:\n        \"\"\"Play the first song in the playlist or continue playing the current song.\"\"\"\n        if self.playlist:\n            if not self.current_song:\n                self.current_song = self.playlist[0]\n            elif self.current_song not in self.playlist:\n                self.current_song = self.playlist[0]\n            return self.current_song\n        return \"\"\n\n    def stop(self) -> bool:\n        \"\"\"Stop playing the current song.\"\"\"\n        if self.current_song:\n            self.current_song = \"\"\n            return True\n        return False\n\n    def switch_song(self) -> bool:\n        \"\"\"Switch to the next song in the playlist.\"\"\"\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index + 1 < len(self.playlist):\n                self.current_song = self.playlist[current_index + 1]\n                return True\n        return False\n\n    def previous_song(self) -> bool:\n        \"\"\"Switch to the previous song in the playlist.\"\"\"\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n        return False\n\n    def set_volume(self, volume: int) -> bool:\n        \"\"\"Set the volume if it's within the valid range.\"\"\"\n        if self._is_valid_volume(volume):\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self) -> bool:\n        \"\"\"Shuffle the playlist.\"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n\n    def _is_valid_volume(self, volume: int) -> bool:\n        \"\"\"Check if the volume is within the valid range.\"\"\"\n        return 0 <= volume <= 100\n",
  "NLPDataProcessor": "class NLPDataProcessor:\n    def __init__(self):\n        pass\n\n    def construct_stop_word_list(self):\n        \"\"\"Constructs a predefined list of stop words.\"\"\"\n        return [\"a\", \"an\", \"the\"]\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Removes stop words from a list of strings.\n\n        Args:\n            string_list (list of str): List of strings to process.\n            stop_word_list (list of str): List of stop words to remove.\n\n        Returns:\n            list of list of str: A list of lists, where each inner list contains the words from the corresponding input string with stop words removed.\n        \"\"\"\n        answer = []\n\n        for string in string_list:\n            string_split = []\n            words = string.split()\n\n            for word in words:\n                if word not in stop_word_list:\n                    string_split.append(word)\n\n            answer.append(string_split)\n\n        return answer\n\n    def process(self, string_list):\n        \"\"\"\n        Main processing method that constructs the stop word list and applies it to remove stop words from the input list of strings.\n\n        Args:\n            string_list (list of str): List of strings to process.\n\n        Returns:\n            list of list of str: Processed list of strings with stop words removed.\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n",
  "NLPDataProcessor2": "import re\nfrom collections import defaultdict, Counter, OrderedDict\n\nclass NLPDataProcessor:\n    def __init__(self):\n        self.first_appear = {}\n\n    def to_lowercase(self, string):\n        return string.lower()\n\n    def remove_non_alpha(self, string):\n        return re.sub(r'[^a-z\\s]', '', string)\n\n    def process_data(self, string_list):\n        words_list = []\n        for string in string_list:\n            processed_string = self.remove_non_alpha(self.to_lowercase(string))\n            words = [word for word in processed_string.split() if word]\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = defaultdict(int)\n        self.first_appear.clear()\n        js = 0\n        for words in words_list:\n            for word in words:\n                if word not in word_frequency:\n                    js += 1\n                    self.first_appear[word] = js\n                word_frequency[word] += 1\n\n        # Sort by frequency, then by first appearance\n        sorted_word_frequency = sorted(\n            word_frequency.items(),\n            key=lambda x: (-x[1], self.first_appear[x[0]])\n        )\n\n        # Get the top 5 words\n        top_5_word_frequency = OrderedDict(sorted_word_frequency[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n\n# Example usage:\n# processor = NLPDataProcessor()\n# result = processor.process([\"Hello, World!\", \"This is a test. Hello again!\"])\n# print(result)\n",
  "NumberConverter": "class NumberConverter:\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        if decimal_num == 0:\n            return \"0\"\n        binary_num = bin(decimal_num)[2:]  # Convert to binary and remove the '0b' prefix\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        return oct(decimal_num)[2:]  # Convert to octal and remove the '0o' prefix\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        return hex(decimal_num)[2:]  # Convert to hexadecimal and remove the '0x' prefix\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        return int(hex_num, 16)\n",
  "NumberWordFormatter": "class NumberWordFormatter:\n    def __init__(self):\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\", \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        if x is None:\n            return self.format(None)\n        elif isinstance(x, int):\n            return self.format(str(x))\n        elif isinstance(x, float):\n            return self.format(str(x))\n        elif isinstance(x, str):\n            return self._format_string(x)\n        else:\n            raise ValueError(\"Unsupported type\")\n\n    def _format_string(self, x):\n        lstr = x.split('.')[0]\n        rstr = x.split('.')[1] if '.' in x else \"\"\n        lstr = lstr[::-1]\n\n        if len(lstr) % 3 == 1:\n            lstr += \"00\"\n        elif len(lstr) % 3 == 2:\n            lstr += \"0\"\n\n        a = [\"\"] * 5\n        lm = \"\"\n\n        for i in range(len(lstr) // 3):\n            a[i] = lstr[3 * i + 2] + lstr[3 * i + 1] + lstr[3 * i]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = \"AND CENTS \" + self.trans_two(rstr) + \" \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            lm = lm.rstrip()\n            return lm + \" \" + xs + \"ONLY\"\n\n    def trans_two(self, s):\n        if len(s) == 1:\n            s = \"0\" + s\n\n        if s[0] == '0':\n            return self.NUMBER[int(s[1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return self.NUMBER[int(s[0])] + \" HUNDRED\"\n        else:\n            return self.NUMBER[int(s[0])] + \" HUNDRED AND \" + self.trans_two(s[1:])\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]\n",
  "NumericEntityUnescaper": "class NumericEntityUnescaper:\n    def __init__(self):\n        pass\n\n    def replace(self, input_string: str) -> str:\n        if not input_string:\n            return \"\"\n\n        out = []\n        pos = 0\n        length = len(input_string)\n\n        while pos < length - 2:\n            if input_string[pos] == '&' and input_string[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n\n                if start < length and input_string[start] in ('x', 'X'):\n                    start += 1\n                    is_hex = True\n\n                if start == length:\n                    break\n\n                end = start\n                while end < length and self.is_hex_char(input_string[end]):\n                    end += 1\n\n                if end < length and input_string[end] == ';':\n                    try:\n                        number_str = input_string[start:end]\n                        entity_value = int(number_str, 16) if is_hex else int(number_str)\n\n                        out.append(chr(entity_value))\n                        pos = end + 1\n                        continue\n                    except ValueError:\n                        pass\n\n            out.append(input_string[pos])\n            pos += 1\n\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(c: str) -> bool:\n        return c.isdigit() or ('a' <= c.lower() <= 'f')\n",
  "Order": "class Dish:\n    def __init__(self, name, price, count):\n        self.name = name\n        self.price = price\n        self.count = count\n\n\nclass Order:\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish, quantity):\n        for menu_dish in self.menu:\n            if dish.name == menu_dish.name:\n                if menu_dish.count < quantity:\n                    return False\n                else:\n                    menu_dish.count -= quantity\n                    new_selected_dish = Dish(dish.name, dish.price, quantity)\n                    self.selected_dishes.append(new_selected_dish)\n                    return True\n        return False\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            discount = self.sales.get(dish.name, 1.0)  # Default to no discount if not found\n            total += dish.price * dish.count * discount\n        return total\n\n    def checkout(self):\n        if not self.selected_dishes:\n            return 0\n        total = self.calculate_total()\n        self.selected_dishes.clear()\n        return total\n",
  "PageUtil": "from typing import List, Dict, Union\n\nclass PageUtil:\n    def __init__(self, data: List[int], page_size: int):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + self.page_size - 1) // self.page_size\n\n    def get_page(self, page_number: int) -> List[int]:\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number: int) -> Dict[str, Union[int, List[int], bool]]:\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        return page_info\n\n    def search(self, keyword: str) -> Dict[str, Union[str, int, List[int]]]:\n        results = [item for item in self.data if keyword in str(item)]\n\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        return search_info\n",
  "PersonRequest": "class PersonRequest:\n    def __init__(self, name: str, sex: str, phone_number: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        if not name or len(name) > 33:\n            return \"\"\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in {\"Man\", \"Woman\", \"UGM\"}:\n            return \"\"\n        return sex\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        if not phone_number or len(phone_number) != 11 or not self._is_all_digits(phone_number):\n            return \"\"\n        return phone_number\n\n    @staticmethod\n    def _is_all_digits(s: str) -> bool:\n        return s.isdigit()\n",
  "PushBoxGame": "class PushBoxGame:\n    def __init__(self, map=None):\n        self.map = map if map is not None else []\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self._is_game_over = False\n        self.init_game()\n\n    def get_map(self) -> list:\n        return self.map\n\n    def is_game_over(self) -> bool:\n        return self._is_game_over\n\n    def get_player_col(self) -> int:\n        return self.player_col\n\n    def get_player_row(self) -> int:\n        return self.player_row\n\n    def get_targets(self) -> list:\n        return self.targets\n\n    def get_boxes(self) -> list:\n        return self.boxes\n\n    def get_target_count(self) -> int:\n        return self.target_count\n\n    def check_win(self) -> bool:\n        box_on_target_count = sum(1 for box in self.boxes if box in self.targets)\n        if box_on_target_count == self.target_count:\n            self._is_game_over = True\n        return self._is_game_over\n\n    def move(self, direction: str) -> bool:\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        if direction == 'w':\n            new_player_row -= 1\n        elif direction == 's':\n            new_player_row += 1\n        elif direction == 'a':\n            new_player_col -= 1\n        elif direction == 'd':\n            new_player_col += 1\n\n        if self.map[new_player_row][new_player_col] != '#':\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                if self.map[new_box_row][new_box_col] != '#':\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        return self.check_win()\n\n    def init_game(self):\n        for row, line in enumerate(self.map):\n            for col, char in enumerate(line):\n                if char == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif char == 'G':\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif char == 'X':\n                    self.boxes.append((row, col))\n",
  "RegexUtils": "import re\nfrom typing import List\n\nclass RegexUtils:\n    def match(self, pattern: str, text: str) -> bool:\n        \"\"\"Check if a given text matches a specified regex pattern.\"\"\"\n        return re.search(pattern, text) is not None\n\n    def findall(self, pattern: str, text: str) -> List[str]:\n        \"\"\"Find all occurrences of a regex pattern within a given text.\"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern: str, text: str) -> List[str]:\n        \"\"\"Split a given text based on a specified regex pattern.\"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern: str, replacement: str, text: str) -> str:\n        \"\"\"Replace all occurrences of a regex pattern in a given text with a specified replacement string.\"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self) -> str:\n        \"\"\"Generate a regex pattern for matching email addresses.\"\"\"\n        return r\"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\"\n\n    def generate_phone_number_pattern(self) -> str:\n        \"\"\"Generate a regex pattern for matching phone numbers in the format \"XXX-XXX-XXXX\".\"\"\"\n        return r\"\\b\\d{3}-\\d{3}-\\d{4}\\b\"\n\n    def generate_split_sentences_pattern(self) -> str:\n        \"\"\"Generate a regex pattern for splitting sentences based on punctuation marks followed by spaces and an uppercase letter.\"\"\"\n        return r\"[.!?][\\s]{1,2}(?=[A-Z])\"\n\n    def split_sentences(self, text: str) -> List[str]:\n        \"\"\"Split a given text into sentences using the generated sentence split pattern.\"\"\"\n        pattern = self.generate_split_sentences_pattern()\n        sentences = self.split(pattern, text)\n\n        # Remove empty strings from the beginning and end of the list\n        if sentences and sentences[0] == \"\":\n            sentences.pop(0)\n        if sentences and sentences[-1] == \"\":\n            sentences.pop()\n\n        return sentences\n\n    def validate_phone_number(self, phone_number: str) -> bool:\n        \"\"\"Validate if a given phone number matches the standard phone number format.\"\"\"\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text: str) -> List[str]:\n        \"\"\"Extract all email addresses from a given text using the generated email pattern.\"\"\"\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)\n",
  "RPGCharacter": "class RPGCharacter:\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        while amount > 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n\n    def is_alive(self):\n        return self.hp > 0\n\n    def get_hp(self):\n        return self.hp\n\n    def get_exp(self):\n        return self.exp\n\n    def get_attack_power(self):\n        return self.attack_power\n\n    def get_defense(self):\n        return self.defense\n\n    def get_level(self):\n        return self.level\n\n    def set_hp(self, x):\n        self.hp = x\n",
  "Server": "class Server:\n    def __init__(self):\n        self.white_list = set()\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        if addr in self.white_list:\n            return []\n        else:\n            self.white_list.add(addr)\n            return list(self.white_list)\n\n    def del_white_list(self, addr):\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return list(self.white_list)\n        else:\n            return []\n\n    def recv(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return -1\n        addr = int(info[\"addr\"])\n        content = info[\"content\"]\n\n        if addr not in self.white_list:\n            return 0\n        else:\n            self.receive_struct = {\"addr\": str(addr), \"content\": content}\n            return 1\n\n    def send(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n        return \"\"\n\n    def show(self, type):\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return {}\n",
  "ShoppingCart": "from threading import Lock\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.lock = Lock()\n\n    def add_item(self, item: str, price: float, quantity: int = 1):\n        with self.lock:\n            if quantity <= 0:\n                raise ValueError(\"Quantity must be positive.\")\n            if price < 0:\n                raise ValueError(\"Price cannot be negative.\")\n            if item in self.items:\n                # Update the price and quantity\n                self.items[item] = (price, self.items[item][1] + quantity)\n            else:\n                # Add new item\n                self.items[item] = (price, quantity)\n\n    def remove_item(self, item: str, quantity: int = 1):\n        with self.lock:\n            if quantity <= 0:\n                raise ValueError(\"Quantity must be positive.\")\n            if item in self.items:\n                current_quantity = self.items[item][1]\n                new_quantity = current_quantity - quantity\n                if new_quantity > 0:\n                    self.items[item] = (self.items[item][0], new_quantity)\n                else:\n                    del self.items[item]\n\n    def view_items(self) -> dict:\n        with self.lock:\n            return self.items.copy()\n\n    def total_price(self) -> float:\n        with self.lock:\n            total = 0.0\n            for price, quantity in self.items.values():\n                total += price * quantity\n            return total\n",
  "SignInSystem": "class SignInSystem:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username: str) -> bool:\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username: str) -> bool:\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        return all(signed_in for signed_in in self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        return [username for username, signed_in in self.users.items() if not signed_in]\n",
  "Snake": "import random\nfrom typing import List, Tuple\n\nclass Snake:\n    def __init__(self, screen_width: int, screen_height: int, block_size: int, food_position: Tuple[int, int]):\n        self.length = 1\n        self.SCREEN_WIDTH = screen_width\n        self.SCREEN_HEIGHT = screen_height\n        self.BLOCK_SIZE = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction: Tuple[int, int]) -> None:\n        cur_x, cur_y = self.positions[0]\n        dx, dy = direction\n\n        new_pos = (\n            (cur_x + dx * self.BLOCK_SIZE) % self.SCREEN_WIDTH,\n            (cur_y + dy * self.BLOCK_SIZE) % self.SCREEN_HEIGHT\n        )\n\n        if new_pos == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new_pos in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_pos)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self) -> None:\n        while True:\n            self.food_position = (\n                random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE,\n                random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE\n            )\n            if self.food_position not in self.positions:\n                break\n\n    def reset(self) -> None:\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self) -> None:\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n\n    def get_length(self) -> int:\n        return self.length\n\n    def get_positions(self) -> List[Tuple[int, int]]:\n        return self.positions\n\n    def get_score(self) -> int:\n        return self.score\n\n    def get_food_position(self) -> Tuple[int, int]:\n        return self.food_position\n\n    def get_screen_width(self) -> int:\n        return self.SCREEN_WIDTH\n\n    def get_screen_height(self) -> int:\n        return self.SCREEN_HEIGHT\n\n    def get_block_size(self) -> int:\n        return self.BLOCK_SIZE\n",
  "SplitSentence": "import re\n\nclass SplitSentence:\n    def split_sentences(self, sentences_string):\n        # Regular expression to split sentences, considering abbreviations and acronyms\n        regex = r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s'\n        sentences = re.split(regex, sentences_string)\n        \n        # Remove empty strings and trailing spaces\n        sentences = [sentence.rstrip() for sentence in sentences if sentence.strip()]\n        \n        return sentences\n\n    def count_words(self, sentence):\n        # Remove non-alphabetic characters except spaces\n        cleaned_sentence = ''.join(char if char.isalpha() or char.isspace() else ' ' for char in sentence)\n        \n        # Count words\n        words = cleaned_sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        \n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n        \n        return max_count\n\n# Example usage:\n# splitter = SplitSentence()\n# text = \"This is a test. It should work well. Let's see how it handles abbreviations like Dr. Smith.\"\n# print(splitter.process_text_file(text))  # Output: 5\n",
  "SQLGenerator": "class SQLGenerator:\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=\"\"):\n        if fields is None:\n            fields_str = \"*\"\n        else:\n            fields_str = \", \".join(fields)\n\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join(f\"'{value}'\" for value in data.values())\n\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        set_clause = \", \".join(f\"{key} = '{value}'\" for key, value in data.items())\n\n        sql = f\"UPDATE {self.table_name} SET {set_clause}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def delete_query(self, condition):\n        sql = f\"DELETE FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n",
  "SQLQueryBuilder": "class SQLQueryBuilder:\n    @staticmethod\n    def select(table, columns=None, where=None):\n        if columns is None:\n            columns = [\"*\"]\n        if where is None:\n            where = []\n\n        query = \"SELECT \"\n        if columns == [\"*\"]:\n            query += \"*\"\n        else:\n            query += \", \".join(columns)\n        \n        query += f\" FROM {table}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def insert(table, data):\n        if not data:\n            raise ValueError(\"Data must be provided for an INSERT query.\")\n        \n        columns = \", \".join(item[0] for item in data)\n        values = \", \".join(f\"'{item[1]}'\" for item in data)\n        \n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n        return query\n\n    @staticmethod\n    def delete_(table, where=None):\n        if where is None:\n            where = []\n        \n        query = f\"DELETE FROM {table}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        if not data:\n            raise ValueError(\"Data must be provided for an UPDATE query.\")\n        if where is None:\n            where = []\n        \n        set_clause = \", \".join(f\"{key}='{value}'\" for key, value in data)\n        query = f\"UPDATE {table} SET {set_clause}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n",
  "Statistics3": "import math\nfrom collections import Counter\nfrom statistics import mean as stats_mean, median as stats_median, stdev as stats_stdev\nimport numpy as np\n\nclass Statistics3:\n    @staticmethod\n    def mean(data):\n        if not data:\n            return float('nan')\n        return stats_mean(data)\n\n    @staticmethod\n    def median(data):\n        if not data:\n            return float('nan')\n        return stats_median(data)\n\n    @staticmethod\n    def mode(data):\n        if not data:\n            return []\n        counter = Counter(data)\n        max_count = max(counter.values())\n        return [k for k, v in counter.items() if v == max_count]\n\n    @staticmethod\n    def correlation(x, y):\n        if len(x) != len(y):\n            raise ValueError(\"Vectors must be of the same length\")\n        if not x or not y:\n            return float('nan')\n        \n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator_x = math.sqrt(sum((xi - mean_x) ** 2 for xi in x))\n        denominator_y = math.sqrt(sum((yi - mean_y) ** 2 for yi in y))\n        \n        if denominator_x == 0 or denominator_y == 0:\n            return float('nan')\n        return numerator / (denominator_x * denominator_y)\n\n    @staticmethod\n    def correlation_matrix(data):\n        if not data or not all(len(row) == len(data[0]) for row in data):\n            raise ValueError(\"All datasets must have the same length\")\n        \n        num_cols = len(data[0])\n        matrix = [[0.0] * num_cols for _ in range(num_cols)]\n        \n        for i in range(num_cols):\n            for j in range(num_cols):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                matrix[i][j] = Statistics3.correlation(column1, column2)\n        \n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        if len(data) < 2:\n            return float('nan')\n        return stats_stdev(data)\n\n    @staticmethod\n    def z_score(data):\n        if len(data) < 2:\n            return [float('nan')] * len(data)\n        mean_value = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation == 0:\n            return [float('nan')] * len(data)\n        return [(x - mean_value) / std_deviation for x in data]\n",
  "StockPortfolioTracker": "class Stock:\n    def __init__(self, name, price, quantity):\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n\n    def __eq__(self, other):\n        return self.name == other.name and self.price == other.price and self.quantity == other.quantity\n\n\nclass StockSummary:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __eq__(self, other):\n        return self.name == other.name and self.value == other.value\n\n\nclass StockPortfolioTracker:\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        for pf in self.portfolio:\n            if pf.name == stock.name:\n                pf.quantity += stock.quantity\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        for i, pf in enumerate(self.portfolio):\n            if pf.name == stock.name and pf.quantity >= stock.quantity:\n                pf.quantity -= stock.quantity\n                if pf.quantity == 0:\n                    del self.portfolio[i]\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        if stock.price * stock.quantity > self.cash_balance:\n            return False\n        else:\n            self.add_stock(stock)\n            self.cash_balance -= stock.price * stock.quantity\n            return True\n\n    def sell_stock(self, stock):\n        if not self.remove_stock(stock):\n            return False\n        self.cash_balance += stock.price * stock.quantity\n        return True\n\n    def calculate_portfolio_value(self):\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock.price * stock.quantity\n        return total_value\n\n    def get_portfolio_summary(self):\n        summary = [StockSummary(stock.name, self.get_stock_value(stock)) for stock in self.portfolio]\n        return self.calculate_portfolio_value(), summary\n\n    def get_stock_value(self, stock):\n        return stock.price * stock.quantity\n\n    def get_portfolio(self):\n        return self.portfolio\n\n    def get_cash_balance(self):\n        return self.cash_balance\n\n    def set_portfolio(self, portfolio):\n        self.portfolio = portfolio\n",
  "StudentDatabaseProcessor": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        self.execute_query(create_table_query, [])\n\n    def insert_student(self, student_data):\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        params = [\n            student_data['name'],\n            student_data['age'],\n            student_data['gender'],\n            student_data['grade']\n        ]\n        self.execute_query(insert_query, params)\n\n    def search_student_by_name(self, name):\n        select_query = \"\"\"\n        SELECT * FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        results = self.query_result(select_query, params)\n\n        students = []\n        for row in results:\n            student = {\n                'id': str(row[0]),\n                'name': row[1],\n                'age': str(row[2]),\n                'gender': row[3],\n                'grade': str(row[4])\n            }\n            students.append(student)\n        return students\n\n    def delete_student_by_name(self, name):\n        delete_query = \"\"\"\n        DELETE FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        self.execute_query(delete_query, params)\n\n    def execute_query(self, query, params):\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(query, params)\n                conn.commit()\n        except sqlite3.Error as e:\n            print(f\"An error occurred: {e}\")\n\n    def query_result(self, query, params):\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(query, params)\n                results = cursor.fetchall()\n                return results\n        except sqlite3.Error as e:\n            print(f\"An error occurred: {e}\")\n            return []\n\n# Example usage:\n# db_processor = StudentDatabaseProcessor('students.db')\n# db_processor.create_student_table()\n# db_processor.insert_student({'name': 'John Doe', 'age': 20, 'gender': 'Male', 'grade': 95})\n# students = db_processor.search_student_by_name('John Doe')\n# print(students)\n# db_processor.delete_student_by_name('John Doe')\n",
  "TextFileProcessor": "import json\nimport re\n\nclass TextFileProcessor:\n    def __init__(self, filename):\n        self.filename = filename\n\n    def read_file_as_json(self):\n        try:\n            with open(self.filename, 'r', encoding='utf-8') as file:\n                return json.load(file)\n        except (FileNotFoundError, json.JSONDecodeError) as e:\n            print(f\"Error reading file as JSON: {e}\")\n            return {}\n\n    def read_file(self):\n        try:\n            with open(self.filename, 'r', encoding='utf-8') as file:\n                return file.read()\n        except FileNotFoundError as e:\n            print(f\"Error reading file: {e}\")\n            return \"\"\n\n    def write_file(self, content):\n        try:\n            with open(self.filename, 'w', encoding='utf-8') as file:\n                file.write(content)\n        except IOError as e:\n            print(f\"Error writing to file: {e}\")\n\n    def process_file(self):\n        content = self.read_file()\n        # Using regular expression to filter out non-alphabetic characters\n        result = re.sub(r'[^a-zA-Z]', '', content)\n        self.write_file(result)\n        return result\n",
  "Thermostat": "class Thermostat:\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n        self.auto_check_conflict()\n\n    def get_target_temperature(self):\n        \"\"\"Retrieve the target temperature.\"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"Set a new target temperature.\"\"\"\n        self.target_temperature = temperature\n        self.auto_check_conflict()\n\n    def get_mode(self):\n        \"\"\"Retrieve the current mode.\"\"\"\n        return self.mode\n\n    def set_mode(self, new_mode):\n        \"\"\"Set the mode to either 'heat' or 'cool'. Returns True if successful.\"\"\"\n        if new_mode in [\"heat\", \"cool\"]:\n            self.mode = new_mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        \"\"\"Automatically set the mode based on current and target temperatures.\"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = \"heat\"\n        else:\n            self.mode = \"cool\"\n\n    def auto_check_conflict(self):\n        \"\"\"Check for conflicts between current temperature and mode. Adjust mode if necessary.\"\"\"\n        if self.current_temperature > self.target_temperature:\n            if self.mode != \"cool\":\n                self.auto_set_mode()\n                return False\n        elif self.current_temperature < self.target_temperature:\n            if self.mode != \"heat\":\n                self.auto_set_mode()\n                return False\n        return True\n\n    def simulate_operation(self):\n        \"\"\"Simulate adjusting the current temperature to match the target temperature.\"\"\"\n        self.auto_set_mode()\n        use_time = 0\n        while self.current_temperature != self.target_temperature:\n            if self.mode == \"heat\":\n                self.current_temperature += 1\n            else:\n                self.current_temperature -= 1\n            use_time += 1\n        return use_time\n",
  "TicTacToe": "class TicTacToe:\n    def __init__(self, N=3):\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if 0 <= row < len(self.board) and 0 <= col < len(self.board[0]):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                self.current_player = 'O' if self.current_player == 'X' else 'X'\n                return True\n        return False\n\n    def check_winner(self):\n        n = len(self.board)\n        \n        # Check rows and columns\n        for i in range(n):\n            if self.board[i][0] != ' ' and all(self.board[i][j] == self.board[i][0] for j in range(n)):\n                return self.board[i][0]\n            if self.board[0][i] != ' ' and all(self.board[j][i] == self.board[0][i] for j in range(n)):\n                return self.board[0][i]\n        \n        # Check diagonals\n        if self.board[0][0] != ' ' and all(self.board[i][i] == self.board[0][0] for i in range(n)):\n            return self.board[0][0]\n        if self.board[0][n-1] != ' ' and all(self.board[i][n-1-i] == self.board[0][n-1] for i in range(n)):\n            return self.board[0][n-1]\n        \n        return '\\0'\n\n    def is_board_full(self):\n        return all(all(cell != ' ' for cell in row) for row in self.board)\n\n    def get_current_player(self):\n        return self.current_player\n",
  "TimeUtils": "from datetime import datetime, timedelta, time\nimport time as time_module\n\nclass TimeUtils:\n    def __init__(self):\n        self.datetime = datetime.now()\n\n    def get_current_time(self) -> str:\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self) -> str:\n        return self.datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds: int) -> str:\n        new_datetime = self.datetime + timedelta(seconds=seconds)\n        self.datetime = new_datetime\n        return new_datetime.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, str_time: str) -> time_module.struct_time:\n        return time_module.strptime(str_time, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime_obj: time_module.struct_time) -> str:\n        return time_module.strftime(\"%Y-%m-%d %H:%M:%S\", datetime_obj)\n\n    def get_minutes(self, string_time1: str, string_time2: str) -> int:\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        time_t1 = time_module.mktime(time1)\n        time_t2 = time_module.mktime(time2)\n        return int((time_t2 - time_t1) / 60)\n\n    def get_format_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        dt = datetime(year, month, day, hour, minute, second)\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "TriCalculator": "import math\n\nclass TrigonometricCalculator:\n    def __init__(self):\n        self.PI = 3.14159265358979323846\n\n    def round_value(self, value, precision):\n        factor = 10.0 ** precision\n        return round(value * factor) / factor\n\n    def cos(self, x):\n        result = self.taylor(x, 17)\n        print(f\"Taylor result for cos: {result}\")\n        return self.round_value(result, 10)\n\n    def factorial(self, a):\n        if a < 0:\n            return 0\n        if a == 0:\n            return 1\n        b = 1\n        for i in range(1, a + 1):\n            b *= i\n        return b\n\n    def taylor(self, x, n):\n        a = 0.0\n        x = x / 180.0 * self.PI\n        sign = 1\n\n        for k in range(n):\n            term = math.pow(x, 2 * k) / self.factorial(2 * k)\n            if k % 2 == 0:\n                a += term\n            else:\n                a -= term\n        return a\n\n    def sin(self, x):\n        x = x / 180.0 * self.PI\n        g = 0.0\n        t = x\n        n = 1\n\n        while abs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / ((2 * n - 1) * (2 * n - 2))\n        return self.round_value(g, 10)\n\n    def tan(self, x):\n        cosine = self.cos(x)\n        if abs(cosine) > 0.01:\n            result = self.sin(x) / cosine\n            return self.round_value(result, 10)\n        else:\n            return float('nan')\n\n# Example usage:\n# calculator = TrigonometricCalculator()\n# print(calculator.cos(60))\n# print(calculator.sin(30))\n# print(calculator.tan(45))\n",
  "TwentyFourPointGame": "import random\nimport re\nfrom collections import defaultdict\nfrom operator import add, sub, mul, truediv, pow\n\nclass TwentyFourPointGame:\n    def __init__(self):\n        self.nums = []\n        self.generate_cards()\n\n    def get_my_cards(self):\n        self.generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == \"pass\":\n            return self.get_my_cards()\n\n        # Count occurrences of digits in the expression\n        statistic = defaultdict(int)\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[int(c)] += 1\n\n        # Check if all used numbers are within the allowed set and not overused\n        nums_used = statistic.copy()\n        for num in self.nums:\n            if nums_used[num] > 0:\n                nums_used[num] -= 1\n            else:\n                return []\n\n        if all(count == 0 for count in nums_used.values()):\n            if self.evaluate_expression(expression):\n                return [1]\n            else:\n                return []\n        else:\n            return []\n\n    def evaluate_expression(self, expression):\n        try:\n            # Validate expression starts and ends with a digit or parenthesis\n            if not (expression[0].isdigit() or expression[0] == '('):\n                raise ValueError(\"Invalid expression start\")\n            if not (expression[-1].isdigit() or expression[-1] == ')'):\n                raise ValueError(\"Invalid expression end\")\n\n            calculator = Calculator()\n            result = calculator.calculate(expression)\n\n            return abs(result - 24.0) < 1e-6  # Allowing for floating-point precision issues\n        except Exception:\n            return False\n\n    def set_nums(self, now):\n        self.nums = now\n\n    def generate_cards(self):\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n        assert len(self.nums) == 4\n\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': add,\n            '-': sub,\n            '*': mul,\n            '/': truediv,\n            '^': pow\n        }\n\n    def calculate(self, expression):\n        if not expression:\n            return 0.0\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer += ch\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if ch in self.operators:\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()  # Remove '('\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op):\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(op, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[op](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "URLHandler": "from urllib.parse import urlparse, parse_qs, unquote\n\nclass URLHandler:\n    def __init__(self, url):\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self) -> str:\n        return self.parsed_url.scheme\n\n    def get_host(self) -> str:\n        return self.parsed_url.netloc\n\n    def get_path(self) -> str:\n        return self.parsed_url.path\n\n    def get_query_params(self) -> dict:\n        # Using parse_qs to handle URL-encoded characters\n        query_params = parse_qs(self.parsed_url.query)\n        # Convert lists to single values if there's only one value\n        return {k: v[0] if len(v) == 1 else v for k, v in query_params.items()}\n\n    def get_fragment(self) -> str:\n        return self.parsed_url.fragment\n\n# Example usage:\n# handler = URLHandler(\"https://example.com/path?param1=value1&param2=value2#fragment\")\n# print(handler.get_scheme())  # Output: https\n# print(handler.get_host())    # Output: example.com\n# print(handler.get_path())    # Output: /path\n# print(handler.get_query_params())  # Output: {'param1': 'value1', 'param2': 'value2'}\n# print(handler.get_fragment())  # Output: fragment\n",
  "UrlPath": "import urllib.parse\n\nclass UrlPath:\n    def __init__(self):\n        self.segments = []\n        self._with_end_tag = False\n\n    def add(self, segment: str):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path: str, charset: str):\n        if not path:\n            return\n\n        if path.endswith('/'):\n            self._with_end_tag = True\n\n        fixed_path = self.fix_path(path)\n        if fixed_path:\n            for segment in fixed_path.split('/'):\n                # Decode percent-encoded characters\n                decoded_seg = urllib.parse.unquote(segment)\n                self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path: str) -> str:\n        if not path:\n            return \"\"\n\n        segment_str = path\n        if segment_str.startswith('/'):\n            segment_str = segment_str[1:]\n        if segment_str.endswith('/'):\n            segment_str = segment_str[:-1]\n        return segment_str\n\n    def get_segments(self) -> list:\n        return self.segments\n\n    def with_end_tag(self) -> bool:\n        return self._with_end_tag\n",
  "UserLoginDB": "import sqlite3\nfrom contextlib import closing\n\nclass UserLoginDB:\n    def __init__(self, db_name):\n        self.connection = None\n        self.stmt = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.create_table()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Cannot open database: {e}\")\n\n    def __del__(self):\n        self.finalize_statement()\n        if self.connection:\n            self.connection.close()\n\n    def prepare_statement(self, query):\n        self.finalize_statement()\n        try:\n            self.stmt = self.connection.prepare(query)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to prepare statement: {e}\")\n\n    def finalize_statement(self):\n        if self.stmt:\n            self.stmt.close()\n            self.stmt = None\n\n    def insert_user(self, username, password):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to insert user: {e}\")\n\n    def search_user_by_username(self, username):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n                row = cursor.fetchone()\n                return (row[0], row[1]) if row else None\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to search user: {e}\")\n\n    def delete_user_by_username(self, username):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to delete user: {e}\")\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        return user is not None and user[1] == password\n\n    def create_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT,\n            password TEXT\n        )\n        \"\"\"\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(create_table_query)\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Cannot create table: {e}\")\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n",
  "VectorUtil": "import math\nfrom typing import List, Dict, Tuple\n\nclass VectorUtil:\n    @staticmethod\n    def norm(vector: Tuple[float, ...]) -> float:\n        return math.sqrt(sum(val * val for val in vector))\n\n    @staticmethod\n    def normalize(vector: Tuple[float, ...]) -> Tuple[float, ...]:\n        vec_norm = VectorUtil.norm(vector)\n        if vec_norm == 0.0:\n            return tuple(0.0 for _ in vector)\n        return tuple(val / vec_norm for val in vector)\n\n    @staticmethod\n    def similarity(vector_1: Tuple[float, ...], vector_2: Tuple[float, ...]) -> float:\n        norm_vec1 = VectorUtil.normalize(vector_1)\n        norm_vec2 = VectorUtil.normalize(vector_2)\n        dot_product = sum(norm_vec1[i] * norm_vec2[i] for i in range(len(vector_1)))\n        return dot_product\n\n    @staticmethod\n    def cosine_similarities(vector_1: Tuple[float, ...], vectors_all: List[Tuple[float, ...]]) -> List[float]:\n        norm_vec1 = VectorUtil.norm(vector_1)\n        similarities = []\n        for vec in vectors_all:\n            norm_vec_all = VectorUtil.norm(vec)\n            if norm_vec_all == 0.0:\n                similarities.append(0.0)\n                continue\n            dot_product = sum(vec[i] * vector_1[i] for i in range(len(vector_1)))\n            similarity = dot_product / (norm_vec1 * norm_vec_all)\n            similarities.append(similarity)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1: List[Tuple[float, ...]], vector_list_2: List[Tuple[float, ...]]) -> float:\n        if not vector_list_1 or not vector_list_2:\n            raise ValueError(\"At least one of the lists is empty.\")\n\n        mean_vec1 = tuple(sum(vec[i] for vec in vector_list_1) / len(vector_list_1) for i in range(len(vector_list_1[0])))\n        mean_vec2 = tuple(sum(vec[i] for vec in vector_list_2) / len(vector_list_2) for i in range(len(vector_list_2[0])))\n\n        return VectorUtil.similarity(mean_vec1, mean_vec2)\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: Dict[str, float]) -> Dict[str, float]:\n        result = {}\n        for key, count in number_dict.items():\n            idf_value = math.log((total_num + 1.0) / (count + 1.0))\n            result[key] = idf_value\n        return result\n",
  "VendingMachine": "class VendingMachine:\n    def __init__(self):\n        self.inventory_ = {}\n        self.balance_ = 0.0\n\n    def add_item(self, item_name: str, price: float, quantity: int):\n        if not self.restock_item(item_name, quantity):\n            self.inventory_[item_name] = {\"price\": price, \"quantity\": float(quantity)}\n\n    def insert_coin(self, amount: float) -> float:\n        self.balance_ += amount\n        return self.balance_\n\n    def purchase_item(self, item_name: str) -> float:\n        if item_name in self.inventory_:\n            item = self.inventory_[item_name]\n            if item[\"quantity\"] > 0 and self.balance_ >= item[\"price\"]:\n                self.balance_ -= item[\"price\"]\n                item[\"quantity\"] -= 1\n                return self.balance_\n        return 0.0  # Return 0.0 to indicate failure\n\n    def restock_item(self, item_name: str, quantity: int) -> bool:\n        if item_name in self.inventory_:\n            self.inventory_[item_name][\"quantity\"] += float(quantity)\n            return True\n        return False\n\n    def display_items(self) -> str:\n        if not self.inventory_:\n            return \"No items available\"\n\n        output = []\n        for item_name, details in self.inventory_.items():\n            output.append(f\"{item_name} - ${details['price']} [{int(details['quantity'])}]\")\n        return \"\\n\".join(output)\n\n    def inventory(self) -> dict:\n        return self.inventory_\n\n    def set_inventory(self, x: dict):\n        self.inventory_ = x\n\n    def set_balance(self, y: float):\n        self.balance_ = y\n",
  "Warehouse": "class Warehouse:\n    def __init__(self):\n        self.inventory_ = {}\n        self.orders_ = {}\n\n    def add_product(self, product_id, name, quantity):\n        if product_id not in self.inventory_:\n            self.inventory_[product_id] = {\"name\": name, \"quantity\": quantity}\n        else:\n            self.inventory_[product_id][\"quantity\"] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self.inventory_:\n            self.inventory_[product_id][\"quantity\"] += quantity\n\n    def get_product_quantity(self, product_id):\n        return self.inventory_.get(product_id, {}).get(\"quantity\", 0)\n\n    def create_order(self, order_id, product_id, quantity):\n        available_quantity = self.get_product_quantity(product_id)\n        if available_quantity >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders_[order_id] = {\n                \"product_id\": product_id,\n                \"quantity\": quantity,\n                \"status\": \"Shipped\"\n            }\n            return True\n        return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders_:\n            self.orders_[order_id][\"status\"] = status\n            return True\n        return False\n\n    def track_order(self, order_id):\n        return self.orders_.get(order_id, {}).get(\"status\", \"\")\n\n    def inventory(self):\n        return self.inventory_\n\n    def orders(self):\n        return self.orders_\n",
  "WeatherSystem": "class WeatherInfo:\n    def __init__(self, weather, temperature, temperature_units):\n        self.weather = weather\n        self.temperature = temperature\n        self.temperature_units = temperature_units\n\n\nclass WeatherSystem:\n    def __init__(self, city):\n        self.city = city\n        self.temperature = 0.0\n        self.weather = \"\"\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units=\"celsius\"):\n        self.weather_list = weather_list\n        weather_info = self.weather_list.get(self.city)\n        if weather_info is None:\n            return 0.0, \"\"\n\n        self.temperature = weather_info.temperature\n        self.weather = weather_info.weather\n\n        if weather_info.temperature_units != tmp_units:\n            if tmp_units == \"celsius\":\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == \"fahrenheit\":\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        self.city = city\n\n    def set_temperature(self, temperature):\n        self.temperature = temperature\n\n    def celsius_to_fahrenheit(self):\n        return (self.temperature * 9 / 5) + 32\n\n    def fahrenheit_to_celsius(self):\n        return (self.temperature - 32) * 5 / 9\n\n    def get_city(self):\n        return self.city\n",
  "Words2Numbers": "class Words2Numbers:\n    def __init__(self):\n        self.units = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                      \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\",\n                      \"eighteen\", \"nineteen\"]\n        \n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        \n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n        \n        self.numwords = {}\n        self.numwords[\"and\"] = (1, 0)\n        for idx, unit in enumerate(self.units):\n            self.numwords[unit] = (1, idx)\n        for idx, ten in enumerate(self.tens):\n            self.numwords[ten] = (1, idx * 10)\n        for idx, scale in enumerate(self.scales):\n            self.numwords[scale] = (10 ** (idx * 3), 0)\n        self.numwords[\"hundred\"] = (100, 0)\n        \n        self.ordinal_words = {\"first\": 1, \"second\": 2, \"third\": 3, \"fifth\": 5, \"eighth\": 8,\n                             \"ninth\": 9, \"twelfth\": 12}\n        self.ordinal_endings = [(\"ieth\", \"y\"), (\"th\", \"\")]\n\n    def text2int(self, textnum):\n        text = textnum.replace('-', ' ')\n        current = 0\n        result = 0\n        curstring = \"\"\n\n        for word in text.split():\n            if word in self.ordinal_words:\n                scale = 1\n                increment = self.ordinal_words[word]\n                current = current * scale + increment\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word in self.numwords:\n                    scale, increment = self.numwords[word]\n                    if scale == 1:\n                        current += increment\n                    else:\n                        current *= scale\n                        result += current\n                        current = 0\n                else:\n                    if current > 0:\n                        result += current\n                        current = 0\n                    curstring += word + \" \"\n\n        if current > 0:\n            result += current\n\n        curstring += str(result)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        text = textnum.replace('-', ' ')\n        for word in text.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word not in self.numwords:\n                    return False\n        return True\n",
  "XMLProcessor": "import xml.etree.ElementTree as ET\nimport sys\n\nclass XMLProcessor:\n    def __init__(self, file_name):\n        self.file_name = file_name\n        self.tree = None\n        self.root = None\n\n    def read_xml(self):\n        try:\n            self.tree = ET.parse(self.file_name)\n            self.root = self.tree.getroot()\n        except ET.ParseError as e:\n            print(f\"Error: Could not load XML file: {self.file_name}\", file=sys.stderr)\n            return None\n        return self.root\n\n    def write_xml(self, file_name):\n        if self.tree is None:\n            print(\"Error: No XML document to write.\", file=sys.stderr)\n            return False\n        try:\n            self.tree.write(file_name, encoding='utf-8', xml_declaration=True)\n            return True\n        except IOError as e:\n            print(f\"Error: Could not write XML file: {file_name}\", file=sys.stderr)\n            return False\n\n    def process_xml_data(self, file_name):\n        if self.root is None:\n            print(\"Error: No root element found.\", file=sys.stderr)\n            return False\n\n        for element in self.root.findall('.//item'):\n            text = element.text\n            if text:\n                element.text = text.upper()\n\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        if self.root is None:\n            return []\n\n        return self.root.findall(f'.//{element_name}')\n\n# Example usage:\n# processor = XMLProcessor('example.xml')\n# processor.read_xml()\n# processor.process_xml_data('processed_example.xml')\n# elements = processor.find_element('item')\n",
  "ZipFileProcessor": "import os\nimport zipfile\nfrom pathlib import Path\n\nclass ZipFileInfo:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n\nclass ZipFileProcessor:\n    def __init__(self, zip_file_path):\n        self.zip_file_path = zip_file_path\n\n    def read_zip_file(self):\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                info = ZipFileInfo(self.zip_file_path, 'r')\n                return info\n        except Exception as e:\n            print(f\"Error reading zip file: {e}\")\n            return None\n\n    def extract_all(self, output_directory):\n        if not output_directory:\n            return False\n\n        if not self.create_directory_if_not_exists(output_directory):\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(output_directory)\n            return True\n        except Exception as e:\n            print(f\"Error extracting all files: {e}\")\n            return False\n\n    def extract_file(self, file_name, output_directory):\n        if not output_directory:\n            return False\n\n        if not self.create_directory_if_not_exists(output_directory):\n            print(f\"Failed to create output directory: {output_directory}\")\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                if file_name in zip_ref.namelist():\n                    zip_ref.extract(file_name, output_directory)\n                    return True\n                else:\n                    print(f\"File not found in zip: {file_name}\")\n                    return False\n        except Exception as e:\n            print(f\"Error extracting file: {e}\")\n            return False\n\n    def create_zip_file(self, files, output_zip_file):\n        try:\n            with zipfile.ZipFile(output_zip_file, 'w', zipfile.ZIP_DEFLATED) as zip_ref:\n                for file_path in files:\n                    zip_ref.write(file_path, os.path.basename(file_path))\n            return True\n        except Exception as e:\n            print(f\"Error creating zip file: {e}\")\n            return False\n\n    @staticmethod\n    def create_directory_if_not_exists(dir_path):\n        path = Path(dir_path)\n        if not path.exists():\n            path.mkdir(parents=True, exist_ok=True)\n        return path.exists()\n\n# Example usage:\n# processor = ZipFileProcessor('example.zip')\n# processor.extract_all('output_dir')\n# processor.extract_file('specific_file.txt', 'output_dir')\n# processor.create_zip_file(['file1.txt', 'file2.txt'], 'new_archive.zip')\n# info = processor.read_zip_file()\n"
}
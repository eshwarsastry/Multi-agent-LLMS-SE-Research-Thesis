{
  "AccessGatewayFilter": "import datetime\nimport time\n\nclass User:\n    def __init__(self, name, level, address):\n        self.name = name\n        self.level = level\n        self.address = address\n\nclass Authorization:\n    def __init__(self, user, jwt):\n        self.user = user\n        self.jwt = jwt\n\nclass Request:\n    def __init__(self, path, method, auth):\n        self.path = path\n        self.method = method\n        self.auth = auth\n\nclass AccessGatewayFilter:\n    def filter(self, request):\n        # Support both dict and object access\n        if isinstance(request, dict):\n            request_uri = request.get('path', '')\n            method = request.get('method', '')\n            auth = request.get('auth', Authorization(User(\"\", 0, \"\"), \"\"))\n        else:\n            request_uri = request.path\n            method = request.method\n            auth = request.auth\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(auth)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception:\n            return False\n        return False\n\n    def is_start_with(self, request_uri):\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, auth):\n        user = auth.user\n        jwt = auth.jwt\n\n        if jwt.startswith(user.name):\n            jwt_str_date = jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if now - jwt_timestamp >= 3 * 24 * 60 * 60:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return auth\n\n    def set_current_user_info_and_log(self, user):\n        print(f\"{user.name} {user.address} {int(time.time())}\")\n",
  "AreaCalculator": "import math\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise ValueError(\"Height cannot be negative.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise ValueError(\"Inner radius cannot be greater than outer radius.\")\n        return math.pi * (outer_radius * outer_radius - inner_radius * inner_radius)\n",
  "ArgumentParser": "class ArgumentParser:\n    def __init__(self):\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n        self.type_converters = {}\n        self.initialize_converters()\n\n    def parse_arguments(self, command_string: str) -> tuple[bool, set[str] | None]:\n        import shlex\n        words = shlex.split(command_string)\n\n        for i, word in enumerate(words):\n            if word.startswith(\"--\"):\n                key_value = word[2:]\n                key, _, value = key_value.partition('=')\n                value = value if value else \"1\"\n                self.arguments[key] = self.convert_type(key, value)\n            elif word.startswith(\"-\"):\n                key = word[1:]\n                if i + 1 < len(words) and not words[i + 1].startswith('-'):\n                    value = words[i + 1]\n                else:\n                    value = \"1\"\n                self.arguments[key] = self.convert_type(key, value)\n\n        missing_args = self.required - self.arguments.keys()\n        return (not missing_args, None if not missing_args else missing_args)\n\n    def get_argument(self, key: str):\n        value = self.arguments.get(key, \"\")\n        if isinstance(value, bool):\n            return value\n        elif isinstance(value, int):\n            return value\n        elif isinstance(value, str):\n            if value.isdigit():\n                return int(value)\n            elif value.lower() in [\"true\", \"1\"]:\n                return True\n            elif value.lower() in [\"false\", \"0\"]:\n                return False\n        return value\n\n    def add_argument(self, arg: str, required: bool = False, arg_type: str = \"string\"):\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def convert_type(self, arg: str, value: str):\n        if arg not in self.types:\n            return value\n        converter = self.type_converters.get(self.types[arg])\n        if converter:\n            try:\n                return converter(value)\n            except ValueError:\n                return value\n        return value\n\n    def initialize_converters(self):\n        self.type_converters[\"int\"] = lambda value: int(value)\n        self.type_converters[\"bool\"] = lambda value: value.lower() in [\"true\", \"1\"]\n        self.type_converters[\"string\"] = lambda value: value\n\n    # Alias for compatibility with tests expecting _convert_type\n    _convert_type = convert_type\n",
  "ArrangementCalculator": "class ArrangementCalculator:\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=-1):\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        elif m > n or m < 0 or n < 0:\n            raise ValueError(\"Invalid values for n or m\")\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        if n < 0:\n            raise ValueError(\"n must be non-negative\")\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m=-1):\n        if m == -1:\n            m = len(self.datas)\n        elif m > len(self.datas) or m < 0:\n            raise ValueError(\"Invalid value for m\")\n\n        result = []\n        self._permutations_recursive([], self.datas, m, result)\n        return result\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    @staticmethod\n    def factorial(n):\n        if n < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n    def _permutations_recursive(self, current, remaining, m, result):\n        if len(current) == m:\n            result.append(list(current))\n        else:\n            seen = set()\n            for i in range(len(remaining)):\n                if remaining[i] not in seen:\n                    seen.add(remaining[i])\n                    new_current = current + [remaining[i]]\n                    new_remaining = remaining[:i] + remaining[i+1:]\n                    self._permutations_recursive(new_current, new_remaining, m, result)\n",
  "AssessmentSystem": "from typing import Optional, Dict, List\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Dict[str, any]] = {}\n\n    def add_student(self, name: str, grade: int, major: str):\n        self.students[name] = {'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name: str, course: str, score: int):\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student['courses']:\n            total_score = sum(student['courses'].values())\n            return total_score / len(student['courses'])\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for student_name, student in self.students.items():\n            if any(score < 60 for score in student['courses'].values()):\n                students_with_fail.append(student_name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                total += student['courses'][course]\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name in self.students.keys():\n            gpa = self.get_gpa(name)\n            if gpa is not None and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n",
  "AutomaticGuitarSimulator": "class PlayItem:\n    def __init__(self, chord, tune):\n        self.Chord = chord\n        self.Tune = tune\n\n    def to_dict(self):\n        return {\"Chord\": self.Chord, \"Tune\": self.Tune}\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        # Adjusted to handle empty/whitespace-only input\n        if not self.play_text.strip():\n            return [PlayItem(\"\", \"\").to_dict()]\n\n        for play_seg in self.play_text.split():\n            pos = 0\n            while pos < len(play_seg) and play_seg[pos].isalpha():\n                pos += 1\n\n            play_chord = play_seg[:pos]\n            play_value = play_seg[pos:]\n\n            item = PlayItem(play_chord, play_value)\n            play_list.append(item.to_dict())\n\n            if display:\n                print(self.format_display(play_chord, play_value))\n        \n        return play_list\n\n    def format_display(self, key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n\n    def display(self, key, value):\n        return self.format_display(key, value)\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def setNum(self):\n        return self.set_num()\n\n    def get(self, index):\n        if self.limit <= 0:\n            return []\n        size, remainder = self.set_num()\n        if index < 0 or index >= self.limit:\n            return []\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index < remainder:\n            end += 1\n        return self.lst[start:end]\n",
  "BalancedBrackets": "class BalancedBrackets:\n    def __init__(self, expr: str):\n        self.expr = expr\n        self.stack = []\n        self.left_brackets = \"({[\"\n        self.right_brackets = \")}]\"\n\n    def clear_expr(self):\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets or c in self.right_brackets)\n\n    def check_balanced_brackets(self) -> bool:\n        self.clear_expr()\n        for brkt in self.expr:\n            if brkt in self.left_brackets:\n                self.stack.append(brkt)\n            else:\n                if not self.stack:\n                    return False\n                current_brkt = self.stack.pop()\n                if (current_brkt == '(' and brkt != ')') or \\\n                   (current_brkt == '{' and brkt != '}') or \\\n                   (current_brkt == '[' and brkt != ']'):\n                    return False\n        return not self.stack\n",
  "BankAccount": "class BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)\n",
  "BigNumCalculator": "class BigNumCalculator:\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        max_length = max(len(num1), len(num2))\n        num1_padded = num1.zfill(max_length)\n        num2_padded = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = (ord(num1_padded[i]) - ord('0')) + (ord(num2_padded[i]) - ord('0')) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.append(str(digit))\n\n        if carry > 0:\n            result.append(str(carry))\n\n        return ''.join(reversed(result))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        num1_local = num1\n        num2_local = num2\n        negative = False\n\n        if len(num1_local) < len(num2_local) or (len(num1_local) == len(num2_local) and num1_local < num2_local):\n            num1_local, num2_local = num2_local, num1_local\n            negative = True\n\n        max_length = max(len(num1_local), len(num2_local))\n        num1_local = num1_local.zfill(max_length)\n        num2_local = num2_local.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = (ord(num1_local[i]) - ord('0')) - (ord(num2_local[i]) - ord('0')) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.append(str(digit_diff))\n\n        result = ''.join(reversed(result)).lstrip('0')\n\n        if negative and result != '0':\n            result = '-' + result\n\n        return result\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        len1 = len(num1)\n        len2 = len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1 = i + j\n                p2 = i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        result_str = ''.join(map(str, result)).lstrip('0')\n        return result_str if result_str else '0'\n",
  "BinaryDataProcessor": "class BinaryDataProcessor:\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        self.binary_string = ''.join(c for c in self.binary_string if c in '01')\n\n    def calculate_binary_info(self):\n        zeroes_count = self.binary_string.count('0')\n        ones_count = len(self.binary_string) - zeroes_count\n        total_length = len(self.binary_string)\n\n        zeroes_percentage = zeroes_count / total_length if total_length > 0 else 0\n        ones_percentage = ones_count / total_length if total_length > 0 else 0\n\n        return {\n            \"Zeroes\": zeroes_percentage,\n            \"Ones\": ones_percentage,\n            \"Bit length\": total_length\n        }\n\n    def convert_to_ascii(self):\n        ascii_string = ''\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            if len(byte) == 8:  # Ensure we only process full bytes\n                ascii_string += chr(int(byte, 2))\n        return ascii_string\n\n    def convert_to_utf8(self):\n        return self.convert_to_ascii()\n",
  "BitStatusUtil": "class BitStatusUtil:\n    @staticmethod\n    def add(states: int, stat: int) -> int:\n        BitStatusUtil.check(states, stat)\n        return states | stat\n\n    @staticmethod\n    def has(states: int, stat: int) -> bool:\n        BitStatusUtil.check(states, stat)\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states: int, stat: int) -> int:\n        BitStatusUtil.check(states, stat)\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(*args: int):\n        for arg in args:\n            if isinstance(arg, list):\n                raise ValueError(\"Arguments should not be passed as lists. Pass them as individual integers.\")\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n",
  "BlackjackGame": "import random\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        deck = []\n        suits = [\"S\", \"C\", \"D\", \"H\"]\n        ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank in [\"J\", \"Q\", \"K\"]:\n                value += 10\n            elif rank == \"A\":\n                value += 11\n                num_aces += 1\n            else:\n                value += int(rank)\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            return \"Player wins\" if player_value <= dealer_value else \"Dealer wins\"\n        elif player_value > 21:\n            return \"Dealer wins\"\n        elif dealer_value > 21:\n            return \"Player wins\"\n        else:\n            return \"Player wins\" if player_value > dealer_value else \"Dealer wins\"\n",
  "BookManagement": "class BookManagement:\n    def __init__(self):\n        self.inventory = {}\n\n    def add_book(self, title: str, quantity: int = 1):\n        if not title:\n            raise ValueError(\"Book title cannot be empty\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n        \n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title: str, quantity: int):\n        if not title:\n            raise ValueError(\"Book title cannot be empty\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n        \n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise RuntimeError(\"Insufficient quantity or book not found\")\n        \n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self) -> dict:\n        return self.inventory.copy()\n\n    def view_book_quantity(self, title: str) -> int:\n        if not title:\n            raise ValueError(\"Book title cannot be empty\")\n        \n        return self.inventory.get(title, 0)\n",
  "BookManagementDB": "import sqlite3\nfrom typing import List, Tuple\n\nclass BookManagementDB:\n    def __init__(self, db_name: str):\n        self.connection = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.create_table()  # Ensure table is created upon initialization\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def __del__(self):\n        if self.connection:\n            self.connection.close()\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS books (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            author TEXT NOT NULL,\n            available INTEGER NOT NULL\n        )\n        \"\"\"\n        try:\n            self.connection.execute(create_table_sql)\n            self.connection.commit()  # Commit changes to ensure table creation\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def add_book(self, title: str, author: str):\n        insert_sql = \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\"\n        try:\n            self.connection.execute(insert_sql, (title, author))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def remove_book(self, book_id: int):\n        delete_sql = \"DELETE FROM books WHERE id = ?\"\n        try:\n            self.connection.execute(delete_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def borrow_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 0 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def return_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 1 WHERE id = ?\"\n        try:\n            self.connection.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def search_books(self) -> List[Tuple[int, str, str, int]]:\n        select_sql = \"SELECT * FROM books\"\n        try:\n            cursor = self.connection.execute(select_sql)\n            books = [(row[0], row[1], row[2], row[3]) for row in cursor.fetchall()]\n            return books\n        except sqlite3.Error as e:\n            raise RuntimeError(e)\n\n    def get_connection(self):\n        return self.connection\n",
  "BoyerMooreSearch": "class BoyerMooreSearch:\n    def __init__(self, text: str, pattern: str):\n        self.text = text\n        self.pattern = pattern\n        self.text_len = len(text)\n        self.pat_len = len(pattern)\n\n    def match_in_pattern(self, c: str) -> int:\n        for i in range(self.pat_len - 1, -1, -1):\n            if c == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        for i in range(self.pat_len - 1, -1, -1):\n            if self.pattern[i] != self.text[current_pos + i]:\n                return current_pos + i\n        return -1\n\n    def bad_character_heuristic(self) -> list[int]:\n        positions = []\n        i = 0\n        while i <= self.text_len - self.pat_len:\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                mismatched_char = self.text[mismatch_index]\n                match_index = self.match_in_pattern(mismatched_char)\n                if match_index == -1:\n                    i += (mismatch_index - i + 1)\n                else:\n                    i += (mismatch_index - match_index)\n        return positions\n",
  "Calculator": "import math\nfrom collections import deque\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: math.pow(x, y)\n        }\n\n    def calculate(self, expression: str) -> float:\n        if not expression.strip():\n            return 0.0\n\n        operand_stack = deque()\n        operator_stack = deque()\n        num_buffer = []\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer.append(ch)\n            elif ch.isspace():\n                continue\n            else:\n                if num_buffer:\n                    operand_stack.append(float(''.join(num_buffer)))\n                    num_buffer.clear()\n\n                if ch in self.operators:\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(''.join(num_buffer)))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op: str) -> int:\n        return {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }.get(op, 0)\n\n    def apply_operator(self, operand_stack: deque, operator_stack: deque) -> (deque, deque):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        try:\n            result = self.operators[op](operand1, operand2)\n        except ZeroDivisionError:\n            raise ValueError(\"Division by zero encountered in expression.\")\n        \n        operand_stack.append(result)\n\n        return operand_stack, operator_stack\n",
  "CalendarUtil": "from datetime import datetime, timedelta\n\nclass CalendarUtil:\n    class Event:\n        def __init__(self, date, start_time, end_time, description):\n            self.date = date\n            self.start_time = start_time\n            self.end_time = end_time\n            self.description = description\n\n        def __eq__(self, other):\n            return (self.date == other.date and\n                    self.start_time == other.start_time and\n                    self.end_time == other.end_time and\n                    self.description == other.description)\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        if event not in self.events:\n            self.events.append(event)\n\n    def remove_event(self, event):\n        self.events = [e for e in self.events if e != event]\n\n    def get_events(self, date):\n        events_on_date = []\n        for event in self.events:\n            if event.date.date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        for event in self.events:\n            if start_time < event.end_time and end_time > event.start_time:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        start_time = datetime.combine(date, datetime.min.time())\n        end_time = start_time + timedelta(days=1) - timedelta(seconds=1)\n\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(hours=1)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time = slot_end_time\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        now = datetime.now()\n        upcoming_events = sorted([event for event in self.events if event.start_time >= now], key=lambda x: x.start_time)\n        return upcoming_events[:num_events]\n\ndef time_from_timestamp(timestamp):\n    return datetime.fromtimestamp(timestamp)\n",
  "CamelCaseMap": "class CamelCaseMap:\n    def __init__(self):\n        self.data = {}\n        self.insertion_order = []\n\n    @staticmethod\n    def to_camel_case(key: str) -> str:\n        camel_case_key = []\n        capitalize = False\n        for char in key:\n            if char == '_':\n                capitalize = True\n            else:\n                camel_case_key.append(char.upper() if capitalize else char)\n                capitalize = False\n        return ''.join(camel_case_key)\n\n    def convert_key(self, key: str) -> str:\n        return self.to_camel_case(key)\n\n    def set_item(self, key: str, value: str) -> None:\n        camel_key = self.convert_key(key)\n        if camel_key not in self.data:\n            self.insertion_order.append(camel_key)\n        self.data[camel_key] = value\n\n    def get_item(self, key: str) -> str:\n        return self.data[self.convert_key(key)]\n\n    def del_item(self, key: str) -> None:\n        camel_key = self.convert_key(key)\n        if camel_key in self.data:\n            del self.data[camel_key]\n            self.insertion_order.remove(camel_key)\n\n    def len(self) -> int:\n        return len(self.data)\n\n    def __iter__(self):\n        return iter(self.insertion_order)\n",
  "ChandrasekharSieve": "class ChandrasekharSieve:\n    def __init__(self, n):\n        if n < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def get_primes(self):\n        return self.primes\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        return [i for i in range(2, self.n + 1) if sieve[i]]\n",
  "Chat": "from datetime import datetime\nfrom collections import defaultdict\n\nclass Chat:\n    class Message:\n        def __init__(self, sender, receiver, message, timestamp):\n            self.sender = sender\n            self.receiver = receiver\n            self.message = message\n            self.timestamp = timestamp\n\n    def __init__(self):\n        self.users = defaultdict(list)\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = self.get_current_time()\n        message_info = self.Message(sender, receiver, message, timestamp)\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        return self.users.get(username, [])\n\n    def get_users(self):\n        return dict(self.users)\n\n    @staticmethod\n    def get_current_time():\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "ClassRegistrationSystem": "class Student:\n    def __init__(self, name, major):\n        self.name = name\n        self.major = major\n\n    def get_name(self):\n        return self.name\n\n    def get_major(self):\n        return self.major\n\n    def set_name(self, name):\n        self.name = name\n\n    def set_major(self, major):\n        self.major = major\n\n    def __eq__(self, other):\n        return self.name == other.name and self.major == other.major\n\n\nclass ClassRegistrationSystem:\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, new_student):\n        # Convert dictionary input to Student instance if necessary\n        if isinstance(new_student, dict):\n            new_student = Student(new_student['name'], new_student['major'])\n        elif not isinstance(new_student, Student):\n            raise ValueError(\"new_student must be an instance of Student or a dictionary with 'name' and 'major' keys\")\n\n        if any(student.get_name() == new_student.get_name() for student in self.students):\n            return 0\n        self.students.append(new_student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        if class_name not in self.students_registration_classes[student_name]:\n            self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        return [student.get_name() for student in self.students if student.get_major() == major]\n\n    def get_all_major(self):  # Renamed to match the expected method name in tests\n        return list(set(student.get_major() for student in self.students))\n\n    def get_most_popular_class_in_major(self, major):\n        class_count = {}\n        for student in self.students:\n            if student.get_major() == major:\n                student_name = student.get_name()\n                if student_name in self.students_registration_classes:\n                    for class_name in self.students_registration_classes[student_name]:\n                        if class_name in class_count:\n                            class_count[class_name] += 1\n                        else:\n                            class_count[class_name] = 1\n\n        most_popular_class = None\n        max_count = 0\n        for class_name, count in class_count.items():\n            if count > max_count:\n                most_popular_class = class_name\n                max_count = count\n\n        return most_popular_class\n",
  "Classroom": "from datetime import datetime, time\nfrom typing import List, Union, Dict\n\nclass Course:\n    def __init__(self, name: str, start_time: str, end_time: str):\n        self.name = name\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def __eq__(self, other):\n        if isinstance(other, Course):\n            return (self.name == other.name and\n                    self.start_time == other.start_time and\n                    self.end_time == other.end_time)\n        return False\n\nclass Classroom:\n    def __init__(self, id: int):\n        self.id = id\n        self.courses: List[Union[Course, Dict]] = []\n\n    def add_course(self, course: Union[Course, Dict]):\n        if not self.has_course(course):\n            self.courses.append(course)\n\n    def remove_course(self, course: Union[Course, Dict]):\n        if self.has_course(course):\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time: str) -> bool:\n        check_time_obj = self.string_to_time(check_time)\n\n        for course in self.courses:\n            start_time_obj = self.string_to_time(self._get_course_time(course, 'start_time'))\n            end_time_obj = self.string_to_time(self._get_course_time(course, 'end_time'))\n\n            if check_time_obj >= start_time_obj and check_time_obj <= end_time_obj:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course: Union[Course, Dict]) -> bool:\n        new_start_time_obj = self.string_to_time(self._get_course_time(new_course, 'start_time'))\n        new_end_time_obj = self.string_to_time(self._get_course_time(new_course, 'end_time'))\n\n        for course in self.courses:\n            start_time_obj = self.string_to_time(self._get_course_time(course, 'start_time'))\n            end_time_obj = self.string_to_time(self._get_course_time(course, 'end_time'))\n\n            if self.is_time_conflict(start_time_obj, end_time_obj, new_start_time_obj, new_end_time_obj):\n                return False\n        return True\n\n    def has_course(self, course: Union[Course, Dict]) -> bool:\n        if isinstance(course, Course):\n            return course in self.courses\n        elif isinstance(course, dict):\n            return any(\n                c['name'] == course['name'] and\n                c['start_time'] == course['start_time'] and\n                c['end_time'] == course['end_time']\n                for c in self.courses\n            )\n        return False\n\n    @staticmethod\n    def string_to_time(time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(f\"Invalid time format: {time_str}\")\n\n    @staticmethod\n    def is_time_conflict(start1: time, end1: time, start2: time, end2: time) -> bool:\n        return (start1 <= end2 and end1 >= start2)\n\n    @staticmethod\n    def _get_course_time(course: Union[Course, Dict], time_type: str) -> str:\n        if isinstance(course, Course):\n            return getattr(course, time_type)\n        elif isinstance(course, dict):\n            return course.get(time_type, \"\")\n        else:\n            raise TypeError(\"Course must be either a Course instance or a dictionary.\")\n",
  "CombinationCalculator": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(m) * math.factorial(n - m))\n\n    @staticmethod\n    def count_all(n: int) -> float:\n        if n < 0:\n            return False  # Changed from float('nan') to False as per test results\n        if n > 63:\n            return False  # Changed from float('inf') to False as per test results\n        if n == 63:\n            return float('inf')  # Explicitly return infinity for n == 63\n        return (1 << n) - 1\n\n    def select(self, m: int) -> List[List[str]]:\n        result = []\n        if m < 0 or m > len(self.datas):\n            return result\n        result_list = [None] * m\n        self._select(0, result_list, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            combinations = self.select(i)\n            result.extend(combinations)\n        return result\n\n    def _select(self, data_index: int, result_list: List[str], result_index: int, result: List[List[str]]) -> None:\n        if result_index == len(result_list):\n            result.append(result_list.copy())\n            return\n\n        for i in range(data_index, len(self.datas) - (len(result_list) - result_index) + 1):\n            result_list[result_index] = self.datas[i]\n            self._select(i + 1, result_list, result_index + 1, result)\n",
  "ComplexCalculator": "import cmath\n\nclass ComplexCalculator:\n    @staticmethod\n    def add(c1: complex, c2: complex) -> complex:\n        return complex(c1.real + c2.real, c1.imag + c2.imag)\n\n    @staticmethod\n    def subtract(c1: complex, c2: complex) -> complex:\n        return complex(c1.real - c2.real, c1.imag - c2.imag)\n\n    @staticmethod\n    def multiply(c1: complex, c2: complex) -> complex:\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1: complex, c2: complex) -> complex:\n        if c2 == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        denominator = c2.real * c2.real + c2.imag * c2.imag\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)\n",
  "CookiesUtil": "import json\nimport os\n\nclass CookiesUtil:\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response):\n        if 'cookies' in response:\n            self.cookies = response['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        cookies_data = {}\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n        except FileNotFoundError:\n            print(f\"Error: The file {self.cookies_file} does not exist.\", file=os.sys.stderr)\n        except json.JSONDecodeError as e:\n            print(f\"Error reading JSON file: {e}\", file=os.sys.stderr)\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n        \n        return cookies_data\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file, indent=4)\n            return True\n        except IOError as e:\n            print(f\"Error writing JSON file: {e}\", file=os.sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n            return False\n\n    def set_cookies(self, request):\n        cookies_str = '; '.join(f\"{key}={value}\" for key, value in self.cookies.items())\n        request['cookies'] = cookies_str\n",
  "CSVProcessor": "import csv\nimport os\n\nclass CSVProcessor:\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        try:\n            with open(file_name, mode='r', newline='') as file:\n                reader = csv.reader(file)\n                title = next(reader, [])\n                data = [row for row in reader]\n            return title, data\n        except FileNotFoundError:\n            return [], []\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, mode='w', newline='') as file:\n                writer = csv.writer(file)\n                if data:\n                    writer.writerow(data[0])  # Write the header\n                    for row in data[1:]:\n                        writer.writerow(row)\n            return 1\n        except IOError:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        if not data or N >= len(data[0]):\n            return 0\n\n        # Process the specified column\n        for row in data:\n            if N < len(row):\n                row[N] = row[N].upper()\n\n        # Construct the new file name\n        base_name, ext = os.path.splitext(save_file_name)\n        new_file_name = f\"{base_name}_process{ext}\"\n\n        # Write the processed data to the new file\n        return self.write_csv([title] + data, new_file_name)\n",
  "CurrencyConverter": "class CurrencyConverter:\n    def __init__(self):\n        self.rates = {\n            \"USD\": 1.0,\n            \"EUR\": 0.85,\n            \"GBP\": 0.72,\n            \"JPY\": 110.15,\n            \"CAD\": 1.23,\n            \"AUD\": 1.34,\n            \"CNY\": 6.40,\n        }\n        self.currency_order = [\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CNY\"]\n\n    def convert(self, amount, from_currency, to_currency):\n        if from_currency == to_currency:\n            return amount\n\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n    def get_supported_currencies(self):\n        return self.currency_order\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        self.currency_order.append(currency)\n        return True\n\n    def update_currency_rate(self, currency, new_rate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return True\n",
  "DatabaseProcessor": "import sqlite3\n\nclass DatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def open_database(self):\n        try:\n            db = sqlite3.connect(self.database_name)\n            return db\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def create_table(self, table_name, key1, key2):\n        db = self.open_database()\n        try:\n            create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n            db.execute(create_table_query)\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n        finally:\n            db.close()\n\n    def insert_into_database(self, table_name, data):\n        db = self.open_database()\n        try:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor = db.cursor()\n            for item in data:\n                cursor.execute(insert_query, (item['name'], int(item['age'])))\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert data: {e}\")\n        finally:\n            db.close()\n\n    def search_database(self, table_name, name):\n        db = self.open_database()\n        result = []\n        try:\n            query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n            cursor = db.cursor()\n            cursor.execute(query, (name,))\n            for row in cursor.fetchall():\n                result.append(list(row))\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to search database: {e}\")\n        finally:\n            db.close()\n        return result\n\n    def delete_from_database(self, table_name, name):\n        db = self.open_database()\n        try:\n            delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n            cursor = db.cursor()\n            cursor.execute(delete_query, (name,))\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete data: {e}\")\n        finally:\n            db.close()\n",
  "DataStatistics": "class DataStatistics:\n    def mean(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        total_sum = sum(data)\n        return round(total_sum / len(data), 2)\n\n    def median(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        else:\n            return sorted_data[mid]\n\n    def mode(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        \n        count_map = {}\n        for num in data:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        max_count = max(count_map.values())\n        modes = [num for num, count in count_map.items() if count == max_count]\n        \n        return modes\n",
  "DataStatistics2": "import math\n\nclass DataStatistics2:\n    def __init__(self, data):\n        self.data = data\n\n    def get_sum(self):\n        return sum(self.data)\n\n    def get_min(self):\n        return min(self.data) if self.data else float('inf')\n\n    def get_max(self):\n        return max(self.data) if self.data else float('-inf')\n\n    def get_variance(self):\n        if not self.data:\n            return 0.0\n        mean = self.get_sum() / len(self.data)\n        variance = sum((x - mean) ** 2 for x in self.data) / len(self.data)\n        return round(variance, 2)\n\n    def get_std_deviation(self):\n        variance = self.get_variance()\n        std_dev = math.sqrt(variance)\n        return round(std_dev, 2)\n\n    def get_correlation(self):\n        if len(self.data) < 2:\n            return 1.0\n        mean = self.get_sum() / len(self.data)\n        sum_prod = sum_sq = 0.0\n        for value in self.data:\n            diff = value - mean\n            sum_prod += diff * diff\n            sum_sq += diff * diff\n        # Corrected the correlation formula to be Pearson correlation coefficient\n        # This implementation assumes the data is compared with itself, hence sum_sq is the same for both\n        # For actual correlation between two datasets, this needs to be adjusted\n        return 1.0 if sum_sq == 0 else sum_prod / sum_sq\n",
  "DataStatistics4": "import math\nfrom typing import List\n\nclass DataStatistics4:\n    @staticmethod\n    def correlation_coefficient(data1: List[float], data2: List[float]) -> float:\n        if len(data1) != len(data2):\n            raise ValueError(\"Both datasets must have the same number of elements.\")\n        \n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator1 = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)))\n        denominator2 = math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        denominator = denominator1 * denominator2\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data: List[float]) -> float:\n        n = len(data)\n        mean = sum(data) / n\n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        if std_deviation == 0:\n            return 0.0\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3)\n        return skewness\n\n    @staticmethod\n    def kurtosis(data: List[float]) -> float:\n        n = len(data)\n        mean = sum(data) / n\n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_dev = math.sqrt(variance)\n\n        if std_dev == 0:\n            return float('nan')\n\n        fourth_moment = sum((x - mean) ** 4 for x in data) / n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3.0\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data: List[float], mu: float, sigma: float) -> List[float]:\n        pai = 3.141592653589793\n        pdf_values = [(1 / (sigma * math.sqrt(2 * pai))) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n",
  "DecryptionUtils": "class DecryptionUtils:\n    def __init__(self, key):\n        self.key_ = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        shift = shift % 26\n        plaintext = []\n        for c in ciphertext:\n            if c.isalpha():\n                base = 'A' if c.isupper() else 'a'\n                shifted_char = chr((ord(c) - ord(base) - shift + 26) % 26 + ord(base))\n                plaintext.append(shifted_char)\n            else:\n                plaintext.append(c)\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = []\n        key_length = len(self.key_)\n        key_index = 0\n\n        for c in ciphertext:\n            if c.isalpha():\n                shift = ord(self.key_[key_index % key_length].lower()) - ord('a')\n                base = 'a' if c.islower() else 'A'\n                decrypted_char = chr((ord(c.lower()) - ord('a') - shift + 26) % 26 + ord('a'))\n                decrypted_text.append(decrypted_char.upper() if c.isupper() else decrypted_char)\n                key_index += 1\n            else:\n                decrypted_text.append(c)\n        return ''.join(decrypted_text)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        if rails <= 1:\n            return encrypted_text\n\n        n = len(encrypted_text)\n        fence = [['\\n'] * n for _ in range(rails)]\n\n        direction = -1\n        row = 0\n        col = 0\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            fence[row][col] = '*'\n            col += 1\n            row += direction\n\n        index = 0\n        for r in range(rails):\n            for c in range(n):\n                if fence[r][c] == '*':\n                    fence[r][c] = encrypted_text[index]\n                    index += 1\n\n        direction = -1\n        row = 0\n        col = 0\n        plain_text = []\n\n        for i in range(n):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text.append(fence[row][col])\n            col += 1\n            row += direction\n\n        return ''.join(plain_text)\n",
  "DiscountStrategy": "class DiscountStrategy:\n    class PromoType:\n        FidelityPromo = 'FidelityPromo'\n        BulkItemPromo = 'BulkItemPromo'\n        LargeOrderPromo = 'LargeOrderPromo'\n        NoPromo = 'NoPromo'\n\n    # Exposing the promo constants at the DiscountStrategy class level\n    FidelityPromo = PromoType.FidelityPromo\n    BulkItemPromo = PromoType.BulkItemPromo\n    LargeOrderPromo = PromoType.LargeOrderPromo\n    NoPromo = PromoType.NoPromo\n\n    def __init__(self, customer, cart, promo=PromoType.NoPromo):\n        self.customer = customer\n        self.cart = cart\n        self.promo = promo\n\n    def total(self):\n        total = 0.0\n        for item in self.cart:\n            try:\n                total += item.get(\"quantity\", 0) * item.get(\"price\", 0)\n            except KeyError:\n                print(\"Missing 'quantity' or 'price' in cart item.\")\n        return total\n\n    def due(self):\n        return self.total() - self.promotion()\n\n    def promotion(self):\n        if self.promo == self.PromoType.FidelityPromo:\n            return self.fidelity_discount()\n        elif self.promo == self.PromoType.BulkItemPromo:\n            return self.bulk_item_discount()\n        elif self.promo == self.PromoType.LargeOrderPromo:\n            return self.large_order_discount()\n        else:\n            return 0.0\n\n    def fidelity_discount(self):\n        fidelity = self.customer.get(\"fidelity\", 0)\n        if fidelity >= 1000.0:\n            return 0.05 * self.total()\n        return 0.0\n\n    def bulk_item_discount(self):\n        discount = 0.0\n        for item in self.cart:\n            try:\n                if item.get(\"quantity\", 0) >= 20:\n                    discount += item.get(\"quantity\", 0) * item.get(\"price\", 0) * 0.1\n            except KeyError:\n                print(\"Missing 'quantity' or 'price' in cart item.\")\n        return discount\n\n    def large_order_discount(self):\n        if len(self.cart) >= 10:\n            return 0.07 * self.total()\n        return 0.0\n",
  "EightPuzzle": "class EightPuzzle:\n    def __init__(self, initial_state=None):\n        self.initialState = initial_state if initial_state is not None else []\n        self.goalState = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return -1, -1\n\n    def move(self, state, direction):\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]\n\n        if direction == \"up\" and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == \"down\" and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == \"left\" and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == \"right\" and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        moves = []\n        i, j = self.find_blank(state)\n\n        if i > 0:\n            moves.append(\"up\")\n        if i < 2:\n            moves.append(\"down\")\n        if j > 0:\n            moves.append(\"left\")\n        if j < 2:\n            moves.append(\"right\")\n\n        return moves\n\n    def solve(self):\n        from collections import deque\n\n        open_list = deque([(self.initialState, [])])\n        closed_list = set()\n\n        while open_list:\n            current_state, path = open_list.popleft()\n            closed_list.add(tuple(map(tuple, current_state)))\n\n            if current_state == self.goalState:\n                return path\n\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if tuple(map(tuple, new_state)) not in closed_list:\n                    new_path = path + [move]\n                    open_list.append((new_state, new_path))\n\n        return []\n\n    def __eq__(self, other):\n        if isinstance(other, EightPuzzle):\n            return self.initialState == other.initialState\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(tuple(map(tuple, self.initialState)))\n\n    def __setitem__(self, key, value):\n        if key == 'initialState':\n            self.initialState = value\n",
  "EmailClient": "from datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr, capacity):\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def get_current_time(self):\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,  # Store size as an integer\n                \"time\": self.get_current_time(),\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        if not self.inbox:\n            return None  # Return None when inbox is empty\n        for email in self.inbox:\n            if email[\"state\"] == \"unread\":\n                email[\"state\"] = \"read\"\n                return email\n        return None  # Return None when no unread email is found\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return occupied_size + size > self.capacity\n\n    def get_occupied_size(self):\n        return sum(email[\"size\"] for email in self.inbox)\n\n    def clear_inbox(self, size):\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            freed_space += self.inbox[0][\"size\"]\n            del self.inbox[0]\n",
  "EncryptionUtils": "class EncryptionUtils:\n    def __init__(self, key):\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        ciphertext = []\n        for ch in plaintext:\n            if ch.isalpha():\n                ascii_offset = 65 if ch.isupper() else 97\n                shifted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ascii_offset)\n                ciphertext.append(shifted_char)\n            else:\n                ciphertext.append(ch)\n        return ''.join(ciphertext)\n\n    def vigenere_cipher(self, plain_text):\n        encrypted_text = []\n        key_length = len(self.key)\n        for i, ch in enumerate(plain_text):\n            if ch.isalpha():\n                shift = ord(self.key[i % key_length].lower()) - ord('a')\n                encrypted_char = chr((ord(ch.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text.append(encrypted_char.upper() if ch.isupper() else encrypted_char)\n            else:\n                encrypted_text.append(ch)\n        return ''.join(encrypted_text)\n\n    def rail_fence_cipher(self, plain_text, rails):\n        if rails <= 0:\n            raise ValueError(\"Rails must be greater than zero.\")\n        \n        fence = [''] * rails\n        direction = -1\n        row = 0\n\n        for ch in plain_text:\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row] += ch\n            row += direction\n\n        return ''.join(fence)\n",
  "ExcelProcessor": "import pandas as pd\nimport os\n\nclass ExcelProcessor:\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        try:\n            if not file_name:\n                return None\n            df = pd.read_excel(file_name, dtype=str, engine='openpyxl')\n            data = df.values.tolist()\n            # Convert numeric strings to integers\n            for i, row in enumerate(data):\n                for j, value in enumerate(row):\n                    if isinstance(value, str) and value.isdigit():\n                        data[i][j] = int(value)\n            return data\n        except FileNotFoundError:\n            return None\n        except Exception as e:\n            print(f\"Error reading file: {e}\")\n            return []\n\n    def write_excel(self, data, file_name):\n        try:\n            df = pd.DataFrame(data)\n            df.to_excel(file_name, index=False, header=False, engine='openpyxl')\n            return 1\n        except Exception as e:\n            print(f\"Error writing file: {e}\")\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if not data or N >= len(data[0]):\n            return 0, \"\"\n\n        new_data = []\n        for row in data:\n            new_row = row.copy()\n            value = row[N]\n            if isinstance(value, str):\n                if not value[0].isdigit():\n                    new_value = value.upper()\n                else:\n                    new_value = value[0]\n            elif isinstance(value, int):\n                new_value = value\n            else:\n                continue\n            new_row.append(new_value)  # Append the transformed value to the end of the row\n            new_data.append(new_row)\n\n        base_name, ext = os.path.splitext(save_file_name)\n        new_file_name = f\"{base_name}_process{ext}\"\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name\n",
  "ExpressionCalculator": "import re\nfrom collections import deque\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n        self.postfix_stack = deque()\n\n    def calculate(self, expression: str) -> float:\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        reversed_postfix_stack = deque(reversed(self.postfix_stack))\n\n        while reversed_postfix_stack:\n            current_op = reversed_postfix_stack.pop()\n\n            if not self.is_operator(current_op):\n                current_op = re.sub(r'~', '-', current_op)\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = re.sub(r'~', '-', first_value)\n                second_value = re.sub(r'~', '-', second_value)\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(result_stack.pop())\n\n    def prepare(self, expression: str):\n        op_stack = deque([','])\n        arr = expression\n        current_index = 0\n        count = 0\n        self.postfix_stack.clear()\n\n        for i in range(len(arr)):\n            current_op = arr[i]\n\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(arr[current_index:current_index + count])\n                peek_op = op_stack[-1]\n\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(op_stack.pop())\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(op_stack.pop())\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index:current_index + count])):\n            self.postfix_stack.append(arr[current_index:current_index + count])\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(op_stack.pop())\n\n    @staticmethod\n    def is_operator(c: str) -> bool:\n        operators = {'+', '-', '*', '/', '(', ')', '%'}\n        return c in operators\n\n    def compare(self, cur: str, peek: str) -> bool:\n        cur_op = '/' if cur == '%' else cur\n        peek_op = '/' if peek == '%' else peek\n        return self.operat_priority[ord(peek_op) - 40] >= self.operat_priority[ord(cur_op) - 40]\n\n    @staticmethod\n    def _calculate(first_value: str, second_value: str, current_op: str) -> float:\n        f = float(first_value)\n        s = float(second_value)\n\n        if current_op == '+':\n            return f + s\n        elif current_op == '-':\n            return f - s\n        elif current_op == '*':\n            return f * s\n        elif current_op == '/':\n            return f / s\n        elif current_op == '%':\n            return f % s\n\n        raise ValueError(f\"Unexpected operator: {current_op}\")\n\n    @staticmethod\n    def transform(expression: str) -> str:\n        expr = re.sub(r'\\s+', '', expression)\n        expr = re.sub(r'=$', '', expr)\n\n        for i in range(len(expr)):\n            if expr[i] == '-':\n                if i == 0:\n                    expr = expr[:i] + '~' + expr[i + 1:]\n                else:\n                    prev_c = expr[i - 1]\n                    if prev_c in '+-*/(' or (prev_c in 'Ee' and i > 1 and expr[i - 2].isdigit()):\n                        expr = expr[:i] + '~' + expr[i + 1:]\n\n        if expr.startswith('~('):\n            expr = '-' + expr[1:]\n            return \"0\" + expr\n        else:\n            return expr\n",
  "FitnessTracker": "class FitnessTracker:\n    BMI_std = {\n        \"male\": [20.0, 25.0],\n        \"female\": [19.0, 24.0]\n    }\n\n    def __init__(self, height, weight, age, sex):\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()  # Ensure sex is in lowercase for consistency\n\n    def get_bmi(self):\n        try:\n            return self.weight / (self.height * self.height)\n        except ZeroDivisionError:\n            return float('inf')  # Handle division by zero if height is zero\n\n    def condition_judge(self):\n        bmi = self.get_bmi()\n        bmi_range = self.BMI_std.get(self.sex, [0.0, 0.0])  # Default to [0.0, 0.0] if sex is not recognized\n        if bmi > bmi_range[1]:\n            return 1\n        elif bmi < bmi_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        if self.sex == \"male\":\n            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        elif self.sex == \"female\":\n            bmr = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n        else:\n            return 0.0  # Return 0.0 if sex is not recognized\n\n        condition = self.condition_judge()\n        if condition == 1:\n            calorie_intake = bmr * 1.2  # Overweight\n        elif condition == -1:\n            calorie_intake = bmr * 1.6  # Underweight\n        else:\n            calorie_intake = bmr * 1.4  # Normal weight\n        return calorie_intake\n",
  "GomokuGame": "class GomokuGame:\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def get_board(self):\n        return self.board\n\n    def _check_five_in_a_row(self, row, col, direction):\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5\n",
  "Hotel": "class Hotel:\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize a new hotel with a name and a dictionary of room types and their availability.\n        \n        :param name: Name of the hotel\n        :param rooms: Dictionary where keys are room types and values are the number of available rooms\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Book rooms for a guest.\n        \n        :param room_type: Type of room to book\n        :param room_number: Number of rooms to book\n        :param name: Name of the guest\n        :return: \"Success!\" if booking is successful, number of available rooms if requested exceeds availability, or \"False.\" if room type does not exist or no rooms are available\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return \"False.\"\n        \n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            if name in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] += room_number\n            else:\n                self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return str(self.available_rooms[room_type])\n        else:\n            return \"False.\"\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check in a guest who has already booked rooms.\n        \n        :param room_type: Type of room to check in\n        :param room_number: Number of rooms to check in\n        :param name: Name of the guest\n        :return: True if check-in is successful, False otherwise\n        \"\"\"\n        if room_type not in self.booked_rooms:\n            return False\n        \n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                del self.booked_rooms[room_type][name]\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n            return True\n        return False\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out guests and make rooms available again.\n        \n        :param room_type: Type of room to check out\n        :param room_number: Number of rooms to check out\n        \"\"\"\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms for a specific room type.\n        \n        :param room_type: Type of room\n        :return: Number of available rooms\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n",
  "HRManagementSystem": "class HRManagementSystem:\n    def __init__(self):\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                \"name\": name,\n                \"position\": position,\n                \"department\": department,\n                \"salary\": salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id, employee_info):\n        if employee_id not in self.employees:\n            return False\n\n        for key in employee_info:\n            if key not in self.employees[employee_id]:\n                return False\n\n        for key, value in employee_info.items():\n            self.employees[employee_id][key] = value\n\n        return True\n\n    def get_employee(self, employee_id):\n        return self.employees.get(employee_id, None)\n\n    def list_employees(self):\n        employee_data = {}\n        for employee_id, employee_info in self.employees.items():\n            employee_details = employee_info.copy()\n            employee_details[\"employee_ID\"] = employee_id\n            employee_data[employee_id] = employee_details\n        return employee_data\n",
  "Interpolation": "class Interpolation:\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Perform linear interpolation on a set of 1D data points.\n\n        Parameters:\n        x (list of float): The x-coordinates of the data points.\n        y (list of float): The y-coordinates of the data points.\n        x_interp (list of float): The x-coordinates at which to interpolate.\n\n        Returns:\n        list of float: The interpolated y-values corresponding to x_interp.\n        \"\"\"\n        if not x or not y or not x_interp or len(x) != len(y):\n            raise ValueError(\"Invalid input: x, y must be non-empty and of the same length, x_interp must be non-empty.\")\n        \n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Perform bilinear interpolation on a set of 2D data points.\n\n        Parameters:\n        x (list of float): The x-coordinates of the grid points.\n        y (list of float): The y-coordinates of the grid points.\n        z (list of list of float): The z-values at each grid point.\n        x_interp (list of float): The x-coordinates at which to interpolate.\n        y_interp (list of float): The y-coordinates at which to interpolate.\n\n        Returns:\n        list of float: The interpolated z-values corresponding to x_interp and y_interp.\n        \"\"\"\n        if not x or not y or not z or not x_interp or not y_interp:\n            raise ValueError(\"Invalid input: x, y, z, x_interp, and y_interp must be non-empty.\")\n        if len(x) != len(z) or any(len(row) != len(y) for row in z) or len(x_interp) != len(y_interp):\n            raise ValueError(\"Invalid input: x and y must match the dimensions of z, x_interp and y_interp must be of the same length.\")\n        \n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j + 1] - yi) +\n                                  z01 * (x[i + 1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp\n",
  "IPAddress": "class IPAddress:\n    def __init__(self, ip_address: str):\n        self.ip_address = ip_address\n\n    def is_valid(self) -> bool:\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n\n        for octet in octets:\n            if not self._is_valid_octet(octet):\n                return False\n        return True\n\n    def get_octets(self) -> list[str]:\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n    def get_binary(self) -> str:\n        if self.is_valid():\n            octets = self.get_octets()\n            binary_octets = [f'{int(octet):08b}' for octet in octets]\n            return '.'.join(binary_octets)\n        else:\n            return \"\"\n\n    def _is_valid_octet(self, octet: str) -> bool:\n        if not octet.isdigit() or not (0 <= int(octet) <= 255):\n            return False\n        # Check for leading zeros\n        if octet != '0' and octet.startswith('0'):\n            return False\n        return True\n",
  "IpUtil": "import socket\n\nclass IpUtil:\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        if ip_address == \"0.0.0.0\":\n            try:\n                return socket.gethostname()\n            except socket.error:\n                return \"\"\n\n        try:\n            # Create a sockaddr_in structure\n            sa = socket.sockaddr_in()\n            sa.sin_family = socket.AF_INET\n            sa.sin_addr = socket.inet_pton(socket.AF_INET, ip_address)\n\n            # Get the hostname from the IP address\n            result = socket.getnameinfo((sa.sin_addr, 0), socket.NI_NAMEREQD)\n            if result:\n                return result[0]\n        except socket.gaierror:\n            pass\n\n        return \"\"\n",
  "JobMarketplace": "class Job:\n    def __init__(self, job_title, company, requirements):\n        self.job_title = job_title\n        self.company = company\n        self.requirements = requirements\n\n    def __eq__(self, other):\n        if isinstance(other, Job):\n            return (self.job_title == other.job_title and\n                    self.company == other.company and\n                    self.requirements == other.requirements)\n        elif isinstance(other, dict):\n            return (self.job_title == other.get('job_title') and\n                    self.company == other.get('company') and\n                    self.requirements == other.get('requirements'))\n        return False\n\n\nclass Resume:\n    def __init__(self, name, skills, experience):\n        self.name = name\n        self.skills = skills\n        self.experience = experience\n\n    def __eq__(self, other):\n        if isinstance(other, Resume):\n            return (self.name == other.name and\n                    self.skills == other.skills and\n                    self.experience == other.experience)\n        elif isinstance(other, dict):\n            return (self.name == other.get('name') and\n                    self.skills == other.get('skills') and\n                    self.experience == other.get('experience'))\n        return False\n\n\nclass JobMarketplace:\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        self.job_listings.append(Job(job_title, company, requirements))\n\n    def remove_job(self, job):\n        self.job_listings = [j for j in self.job_listings if j != job]\n\n    def submit_resume(self, name, skills, experience):\n        self.resumes.append(Resume(name, skills, experience))\n\n    def withdraw_resume(self, resume):\n        self.resumes = [r for r in self.resumes if r != resume]\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        for job_listing in self.job_listings:\n            title = job_listing.job_title if isinstance(job_listing, Job) else job_listing.get('job_title')\n            requirements = job_listing.requirements if isinstance(job_listing, Job) else job_listing.get('requirements', [])\n            if (criteria in title or\n                    any(criteria in requirement for requirement in requirements)):\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        requirements = job.requirements if isinstance(job, Job) else job.get('requirements', [])\n        return [resume for resume in self.resumes if self.matches_requirements(resume, requirements)]\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        skills = resume.skills if isinstance(resume, Resume) else resume.get('skills', [])\n        # Adjusted to check if all requirements are in skills for an exact match\n        return all(skill in skills for skill in requirements)\n",
  "JSONProcessor": "import os\nimport json\n\nclass JSONProcessor:\n    \n    def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0  # File does not exist\n        \n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n                if not data:\n                    return -1  # JSON is empty or null\n                return data  # Return data on success\n        except Exception:\n            return -1  # Error\n    \n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, indent=4)\n            return 1  # Success\n        except Exception:\n            return -1  # Error\n    \n    def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        \n        if isinstance(data, int):  # Check if read_json returned an error code\n            return 0  # Read failed\n        \n        if remove_key in data:\n            del data[remove_key]\n            return self.write_json(data, file_path)  # Return result of write operation\n        else:\n            return 0  # Key not found\n",
  "KappaCalculator": "import numpy as np\n\nclass KappaCalculator:\n    @staticmethod\n    def kappa(test_data, k):\n        data_mat = np.array(test_data)\n\n        P0 = np.trace(data_mat)\n\n        xsum = np.sum(data_mat, axis=1)\n        ysum = np.sum(data_mat, axis=0)\n        total_sum = np.sum(data_mat)\n\n        Pe = np.dot(ysum, xsum) / (total_sum * total_sum)\n        P0 /= total_sum\n\n        cohens_coefficient = (P0 - Pe) / (1 - Pe) if (1 - Pe) != 0 else 0\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(test_data, N, k, n):\n        data_mat = np.array(test_data)\n\n        total_sum = 0.0\n        P0 = 0.0\n\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                total_sum += data_mat[i, j]\n                temp += np.power(data_mat[i, j], 2)\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n\n        P0 /= N\n\n        ysum = np.sum(data_mat, axis=0)\n        ysum = np.square(ysum / total_sum)\n\n        Pe = np.sum(ysum)\n\n        ans = (P0 - Pe) / (1 - Pe) if (1 - Pe) != 0 else 0\n        return ans\n",
  "LongestWord": "import re\n\nclass LongestWord:\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word: str):\n        self.word_list.append(word.lower())\n\n    def find_longest_word(self, sentence: str) -> str:\n        longest_word = \"\"\n        # Convert sentence to lowercase\n        lower_sentence = sentence.lower()\n        # Remove punctuation using regex\n        lower_sentence = re.sub(r'[^\\w\\s]', '', lower_sentence)\n\n        # Split sentence into words\n        words = lower_sentence.split()\n\n        for word in words:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n\n        return longest_word\n\n    def get_word_list(self) -> list:\n        return self.word_list\n",
  "MahjongConnect": "import random\nfrom typing import List, Tuple, Set\n\nclass MahjongConnect:\n    def __init__(self, board_size: Tuple[int, int], icons: List[str]):\n        self.BOARD_SIZE = board_size\n        self.ICONS = icons\n        self.board = self.create_board()\n\n    def create_board(self) -> List[List[str]]:\n        new_board = [['' for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        for i in range(self.BOARD_SIZE[0]):\n            for j in range(self.BOARD_SIZE[1]):\n                new_board[i][j] = random.choice(self.ICONS)\n        return new_board\n\n    def is_valid_move(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within board boundaries\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and\n                0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        # Check if positions are not identical\n        if pos1 == pos2:\n            return False\n\n        # Check if icons at positions are the same\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a path between the positions\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        visited: Set[Tuple[int, int]] = set()\n        stack: List[Tuple[int, int]] = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Explore adjacent cells\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + direction[0], y + direction[1]\n                if (0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1] and\n                        (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]):\n                    stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> None:\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self) -> bool:\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n",
  "Manacher": "class Manacher:\n    def __init__(self, input_string):\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        if (center - diff == -1) or (center + diff == len(string)) or (string[center - diff] != string[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        if not self.input_string:\n            return \"\"\n\n        max_length = 0\n        new_input_string = \"|\".join(self.input_string) + \"|\"\n        start = 0\n\n        for i in range(len(new_input_string)):\n            length = self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Correctly calculate the start and end indices for the longest palindromic substring\n        start_index = (start - max_length) // 2\n        end_index = (start + max_length + 1) // 2  # Adjusted to include the extra character\n\n        return self.input_string[start_index:end_index]\n",
  "MetricsCalculator": "class MetricsCalculator:\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Predicted and true labels must be of the same length.\")\n        \n        for predicted, true_label in zip(predicted_labels, true_labels):\n            if predicted == 1 and true_label == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true_label == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true_label == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true_label == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        denominator = self.true_positives + self.false_positives\n        return 0.0 if denominator == 0 else self.true_positives / denominator\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        denominator = self.true_positives + self.false_negatives\n        return 0.0 if denominator == 0 else self.true_positives / denominator\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision_value = self.precision(predicted_labels, true_labels)\n        recall_value = self.recall(predicted_labels, true_labels)\n        denominator = precision_value + recall_value\n        return 0.0 if denominator == 0.0 else 2.0 * precision_value * recall_value / denominator\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        return 0.0 if total == 0 else (self.true_positives + self.true_negatives) / total\n",
  "MetricsCalculator2": "class MetricsCalculator:\n    @staticmethod\n    def mrr(data):\n        # Ensure data is always a list of pairs\n        if isinstance(data, tuple):\n            data = [data]\n        if not data:\n            return 0.0, [0.0]\n\n        sum_mrr = 0.0\n        individual_mrr = []\n\n        for vec, k in data:\n            if k <= 0 or not vec:\n                individual_mrr.append(0.0)\n            else:\n                mrr_value = MetricsCalculator._calculate_mrr(vec)\n                individual_mrr.append(mrr_value)\n                sum_mrr += mrr_value\n\n        average_mrr = sum_mrr / len(data) if data else 0.0\n        return average_mrr, individual_mrr\n\n    @staticmethod\n    def map(data):\n        # Ensure data is always a list of pairs\n        if isinstance(data, tuple):\n            data = [data]\n        if not data:\n            return 0.0, [0.0]\n\n        separate_result = []\n\n        for sub_list, total_num in data:\n            if total_num == 0:\n                separate_result.append(0.0)\n                continue\n\n            ap = MetricsCalculator._calculate_map(sub_list)\n            separate_result.append(ap)\n\n        mean_ap = sum(separate_result) / len(data) if data else 0.0\n        return mean_ap, separate_result\n\n    @staticmethod\n    def _calculate_mrr(vec):\n        try:\n            rank = vec.index(1) + 1\n            return 1.0 / rank\n        except ValueError:\n            return 0.0\n\n    @staticmethod\n    def _calculate_map(vec):\n        sum_precision = 0.0\n        count_relevant = 0\n\n        for i, value in enumerate(vec):\n            if value == 1:\n                count_relevant += 1\n                sum_precision += count_relevant / (i + 1)\n\n        return sum_precision / count_relevant if count_relevant > 0 else 0.0\n\n# Alias to match expected class name in tests\nMetricsCalculator2 = MetricsCalculator\n",
  "MovieBookingSystem": "from datetime import datetime, time\nfrom typing import List, Tuple\n\nclass MovieBookingSystem:\n    def __init__(self):\n        self.movies = []\n\n    class Movie:\n        def __init__(self, name: str, price: float, start_time: time, end_time: time, seats: List[List[int]]):\n            self.name = name\n            self.price = price\n            self.start_time = start_time\n            self.end_time = end_time\n            self.seats = seats\n\n        def __getitem__(self, key: str):\n            return getattr(self, key)\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        start_time = self.parse_time(start_time)\n        end_time = self.parse_time(end_time)\n        seats = [[0] * n for _ in range(n)]\n        movie = self.Movie(name, price, start_time, end_time, seats)\n        self.movies.append(movie)\n\n    def book_ticket(self, name: str, seats_to_book: List[Tuple[int, int]]) -> str:\n        for movie in self.movies:\n            if movie.name == name:\n                for seat in seats_to_book:\n                    row, col = seat\n                    if 0 <= row < len(movie.seats) and 0 <= col < len(movie.seats[row]):\n                        if movie.seats[row][col] == 0:\n                            movie.seats[row][col] = 1\n                        else:\n                            return \"Booking failed.\"\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time: str, end_time: str) -> List[str]:\n        start_time = self.parse_time(start_time)\n        end_time = self.parse_time(end_time)\n\n        available_movies = []\n        for movie in self.movies:\n            if self.is_time_in_range(start_time, end_time, movie.start_time) and self.is_time_in_range(start_time, end_time, movie.end_time):\n                available_movies.append(movie.name)\n        return available_movies\n\n    @staticmethod\n    def parse_time(time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(\"Failed to parse time\")\n\n    @staticmethod\n    def is_time_in_range(start: time, end: time, check: time) -> bool:\n        start_seconds = start.hour * 3600 + start.minute * 60\n        end_seconds = end.hour * 3600 + end.minute * 60\n        check_seconds = check.hour * 3600 + check.minute * 60\n        return start_seconds <= check_seconds <= end_seconds\n",
  "MovieTicketDB": "import sqlite3\n\nclass MovieTicketDB:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connection = None\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n            self.create_table()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Unable to open database: {e}\")\n\n    def __del__(self):\n        self.close_connection()\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS tickets (\n            id INTEGER PRIMARY KEY,\n            movie_name TEXT,\n            theater_name TEXT,\n            seat_number TEXT,\n            customer_name TEXT\n        )\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(create_table_sql)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        insert_sql = \"\"\"\n        INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(insert_sql, (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert ticket: {e}\")\n\n    def search_tickets_by_customer(self, customer_name):\n        search_sql = \"\"\"\n        SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(search_sql, (customer_name,))\n            results = [list(row) for row in cursor.fetchall()]\n            return results\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to search tickets: {e}\")\n\n    def delete_ticket(self, ticket_id):\n        delete_sql = \"\"\"\n        DELETE FROM tickets WHERE id = ?\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(delete_sql, (ticket_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete ticket: {e}\")\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n",
  "MusicPlayer": "import random\nfrom typing import List, Optional\n\nclass MusicPlayer:\n    def __init__(self):\n        self.playlist: List[str] = []\n        self.current_song: Optional[str] = None\n        self.volume: int = 50\n\n    def add_song(self, song: str) -> None:\n        self.playlist.append(song)\n\n    def remove_song(self, song: str) -> None:\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self) -> Optional[str]:\n        if not self.playlist:\n            return None\n        if not self.current_song or self.current_song not in self.playlist:\n            self.current_song = self.playlist[0]\n        return self.current_song\n\n    def stop(self) -> bool:\n        if self.current_song:\n            self.current_song = None\n            return True\n        return False\n\n    def switch_song(self) -> bool:\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index + 1 < len(self.playlist):\n                self.current_song = self.playlist[current_index + 1]\n                return True\n        return False\n\n    def previous_song(self) -> bool:\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n        return False\n\n    def set_volume(self, volume: int) -> None:\n        if self._is_valid_volume(volume):\n            self.volume = volume\n\n    def shuffle(self) -> bool:\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n\n    def _is_valid_volume(self, volume: int) -> bool:\n        return 0 <= volume <= 100\n",
  "NLPDataProcessor": "class NLPDataProcessor:\n    def construct_stop_word_list(self):\n        return {\"a\", \"an\", \"the\"}  # Use a set for faster lookup\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        answer = []\n        stop_word_set = {word.lower() for word in stop_word_list}  # Normalize stop words to lower case\n\n        for str_ in string_list:\n            string_split = []\n            words = str_.split()\n\n            for word in words:\n                if word.lower() not in stop_word_set:  # Compare lower case version of word\n                    string_split.append(word)  # Preserve original casing\n\n            answer.append(string_split)\n\n        return answer\n\n    def process(self, string_list):\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n",
  "NLPDataProcessor2": "import re\nfrom collections import defaultdict\n\nclass NLPDataProcessor2:\n    def __init__(self):\n        self.first_appear = {}\n\n    def to_lowercase(self, s):\n        return s.lower()\n\n    def remove_non_alpha(self, s):\n        return re.sub(r'[^a-z\\s]', '', s)\n\n    def process_data(self, string_list):\n        words_list = []\n        for s in string_list:\n            processed_string = self.remove_non_alpha(self.to_lowercase(s))\n            words = [word for word in processed_string.split() if word]\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = defaultdict(int)\n        self.first_appear.clear()\n        js = 0\n        for words in words_list:\n            for word in words:\n                if word not in word_frequency:\n                    js += 1\n                    self.first_appear[word] = js\n                word_frequency[word] += 1\n\n        sorted_word_frequency = sorted(\n            word_frequency.items(),\n            key=lambda x: (-x[1], self.first_appear[x[0]])\n        )\n\n        return dict(sorted_word_frequency[:5])\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n",
  "NumberConverter": "class NumberConverter:\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        binary_num = bin(decimal_num)[2:]\n        return binary_num if binary_num else \"0\"\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        return int(hex_num, 16)\n",
  "NumberWordFormatter": "class NumberWordFormatter:\n    def __init__(self):\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\", \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        if x is None:\n            return \"\"\n        elif isinstance(x, int):\n            return self.format(str(x))\n        elif isinstance(x, float):\n            return self.format(str(x))\n        elif isinstance(x, str):\n            return self._format_string(x)\n        else:\n            raise ValueError(\"Unsupported type\")\n\n    def _format_string(self, x):\n        lstr = x.split('.')[0]\n        rstr = x.split('.')[1] if '.' in x else \"\"\n        lstr = lstr[::-1]\n\n        if len(lstr) % 3 == 1:\n            lstr += \"00\"\n        elif len(lstr) % 3 == 2:\n            lstr += \"0\"\n\n        a = [\"\"] * 5\n        lm = \"\"\n\n        for i in range(len(lstr) // 3):\n            a[i] = lstr[3 * i + 2] + lstr[3 * i + 1] + lstr[3 * i]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = \"AND CENTS \" + self.trans_two(rstr) + \" \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            lm = lm.rstrip()\n            return lm + \" \" + xs + \"ONLY\"\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return self.NUMBER[int(s[0])] + \" HUNDRED\"\n        else:\n            return self.NUMBER[int(s[0])] + \" HUNDRED AND \" + self.trans_two(s[1:])\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]\n",
  "NumericEntityUnescaper": "class NumericEntityUnescaper:\n    def __init__(self):\n        pass\n\n    def replace(self, input: str) -> str:\n        out = []\n        pos = 0\n        length = len(input)\n        if not input:\n            return \"\"\n\n        while pos < length - 2:\n            if input[pos] == '&' and input[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n\n                if start < length and input[start] in ('x', 'X'):\n                    start += 1\n                    is_hex = True\n\n                if start == length:\n                    break\n\n                end = start\n                while end < length and self.is_hex_char(input[end]):\n                    end += 1\n\n                if end < length and input[end] == ';':\n                    try:\n                        number_str = input[start:end]\n                        if is_hex:\n                            entity_value = int(number_str, 16)\n                        else:\n                            entity_value = int(number_str)\n\n                        out.append(chr(entity_value))\n                        pos = end + 1\n                        continue\n                    except ValueError:\n                        break\n\n            out.append(input[pos])\n            pos += 1\n\n        return ''.join(out)\n\n    @staticmethod\n    def is_hex_char(c: str) -> bool:\n        return c.isdigit() or ('a' <= c.lower() <= 'f')\n",
  "Order": "class Dish:\n    def __init__(self, name, price, count):\n        self.name = name\n        self.price = price\n        self.count = count\n\nclass Order:\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish, count=None):\n        if isinstance(dish, dict):\n            # Adjusting to handle both 'name' and 'dish' keys for backward compatibility\n            name = dish.get('name', dish.get('dish'))\n            price = dish.get('price')\n            count = dish.get('count') if count is not None else 1  # Default count to 1 if not provided\n            dish = Dish(name, price, count)\n        \n        for menu_dish in self.menu:\n            if dish.name == menu_dish.name:\n                if menu_dish.count < count:\n                    return False\n                else:\n                    menu_dish.count -= count\n                    self.selected_dishes.append(Dish(dish.name, dish.price, count))\n                    return True\n        return False\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            discount = self.sales.get(dish.name, 1.0)  # Default to no discount if not found\n            total += dish.price * dish.count * discount\n        return total\n\n    def checkout(self):\n        if not self.selected_dishes:\n            return 0\n        total = self.calculate_total()\n        self.selected_dishes.clear()\n        return total\n",
  "PageUtil": "from typing import List, Dict, Union\n\nclass PageUtil:\n    def __init__(self, data: List[int], page_size: int):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + self.page_size - 1) // self.page_size\n\n    def get_page(self, page_number: int) -> List[int]:\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number: int) -> Dict[str, Union[int, List[int], bool]]:\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        return page_info\n\n    def search(self, keyword: str) -> Dict[str, Union[str, int, List[int]]]:\n        results = [item for item in self.data if keyword in str(item)]\n\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        return search_info\n",
  "PersonRequest": "class PersonRequest:\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phone_number(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        if not name or len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in {\"Man\", \"Woman\", \"UGM\"}:\n            return None\n        return sex\n\n    def _validate_phone_number(self, phoneNumber: str) -> str:\n        if not phoneNumber or len(phoneNumber) != 11 or not self._is_all_digits(phoneNumber):\n            return None\n        return phoneNumber\n\n    @staticmethod\n    def _is_all_digits(s: str) -> bool:\n        return s.isdigit()\n",
  "PushBoxGame": "class PushBoxGame:\n    def __init__(self, map=None):\n        self.map = map if map is not None else []\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self._is_game_over = False\n        self.init_game()\n\n    def get_map(self):\n        return self.map\n\n    @property\n    def is_game_over(self):\n        return self._is_game_over\n\n    def get_player_col(self):\n        return self.player_col\n\n    def get_player_row(self):\n        return self.player_row\n\n    def get_targets(self):\n        return self.targets\n\n    def get_boxes(self):\n        return self.boxes\n\n    def get_target_count(self):\n        return self.target_count\n\n    def check_win(self):\n        box_on_target_count = sum(1 for box in self.boxes if box in self.targets)\n        if box_on_target_count == self.target_count:\n            self._is_game_over = True\n        return self._is_game_over\n\n    def move(self, direction):\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        if direction == 'w':\n            new_player_row -= 1\n        elif direction == 's':\n            new_player_row += 1\n        elif direction == 'a':\n            new_player_col -= 1\n        elif direction == 'd':\n            new_player_col += 1\n\n        if self.map[new_player_row][new_player_col] != '#':\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                if self.map[new_box_row][new_box_col] != '#' and (new_box_row, new_box_col) not in self.boxes:\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        return self.check_win()\n\n    def init_game(self):\n        for row, line in enumerate(self.map):\n            for col, char in enumerate(line):\n                if char == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif char == 'G':\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif char == 'X':\n                    self.boxes.append((row, col))\n",
  "RegexUtils": "import re\nfrom typing import List\n\nclass RegexUtils:\n    def match(self, pattern: str, text: str) -> bool:\n        return re.search(pattern, text) is not None\n\n    def findall(self, pattern: str, text: str) -> List[str]:\n        return re.findall(pattern, text)\n\n    def split(self, pattern: str, text: str) -> List[str]:\n        return re.split(pattern, text)\n\n    def sub(self, pattern: str, replacement: str, text: str) -> str:\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self) -> str:\n        return r\"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\"\n\n    def generate_phone_number_pattern(self) -> str:\n        return r\"\\b\\d{3}-\\d{3}-\\d{4}\\b\"\n\n    def generate_split_sentences_pattern(self) -> str:\n        return r\"[.!?][\\s]{1,2}(?=[A-Z])\"\n\n    def split_sentences(self, text: str) -> List[str]:\n        pattern = self.generate_split_sentences_pattern()\n        sentences = self.split(pattern, text)\n\n        # Remove empty strings from the beginning and end of the list\n        if sentences and sentences[0] == \"\":\n            sentences.pop(0)\n        if sentences and sentences[-1] == \"\":\n            sentences.pop()\n\n        return sentences\n\n    def validate_phone_number(self, phone_number: str) -> bool:\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text: str) -> List[str]:\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)\n",
  "RPGCharacter": "class RPGCharacter:\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        while amount > 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n\n    def is_alive(self):\n        return self.hp > 0\n\n    def get_hp(self):\n        return self.hp\n\n    def get_exp(self):\n        return self.exp\n\n    def get_attack_power(self):\n        return self.attack_power\n\n    def get_defense(self):\n        return self.defense\n\n    def get_level(self):\n        return self.level\n\n    def set_hp(self, x):\n        self.hp = x\n",
  "Server": "class Server:\n    def __init__(self):\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return self.white_list\n        else:\n            return False\n\n    def recv(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return -1\n        addr = int(info[\"addr\"])\n        content = info[\"content\"]\n\n        if addr not in self.white_list:\n            return 0\n        else:\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            return 1\n\n    def send(self, info):\n        if \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n        return \"\"\n\n    def show(self, type):\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return False\n",
  "ShoppingCart": "class ShoppingCart:\n    def __init__(self):\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1):\n        if price < 0 or quantity < 0:\n            raise ValueError(\"Price and quantity must be non-negative.\")\n        if item in self.items:\n            # Update the quantity, keep the price the same\n            self.items[item]['quantity'] += quantity\n        else:\n            # Add new item with price and quantity\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item: str, quantity: int = 1):\n        if quantity < 0:\n            raise ValueError(\"Quantity must be non-negative.\")\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n            if self.items[item]['quantity'] <= 0:\n                del self.items[item]\n\n    def view_items(self) -> dict:\n        return self.items.copy()\n\n    def total_price(self) -> float:\n        total = 0.0\n        for info in self.items.values():\n            total += info['price'] * info['quantity']\n        return total\n",
  "SignInSystem": "class SignInSystem:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username: str) -> bool:\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username: str) -> bool:\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        return all(signed_in for signed_in in self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        return [username for username, signed_in in self.users.items() if not signed_in]\n",
  "Snake": "import random\n\nclass Snake:\n    def __init__(self, screen_width, screen_height, block_size, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = screen_width\n        self.SCREEN_HEIGHT = screen_height\n        self.BLOCK_SIZE = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        cur = self.positions[0]\n        x, y = direction\n\n        new_pos = (\n            (cur[0] + x * self.BLOCK_SIZE) % self.SCREEN_WIDTH,\n            (cur[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT\n        )\n\n        if new_pos == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new_pos in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_pos)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while True:\n            self.food_position = (\n                random.randrange(0, self.SCREEN_WIDTH // self.BLOCK_SIZE) * self.BLOCK_SIZE,\n                random.randrange(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE) * self.BLOCK_SIZE\n            )\n            if self.food_position not in self.positions:\n                break\n\n    def reset(self):\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n\n    def get_length(self):\n        return self.length\n\n    def get_positions(self):\n        return self.positions\n\n    def get_score(self):\n        return self.score\n\n    def get_food_position(self):\n        return self.food_position\n\n    def get_screen_width(self):\n        return self.SCREEN_WIDTH\n\n    def get_screen_height(self):\n        return self.SCREEN_HEIGHT\n\n    def get_block_size(self):\n        return self.BLOCK_SIZE\n",
  "SplitSentence": "import re\n\nclass SplitSentence:\n    def split_sentences(self, sentences_string):\n        sentences = []\n        # Regular expression to split sentences, considering common abbreviations\n        regex = r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s'\n        splits = re.split(regex, sentences_string)\n\n        for sentence in splits:\n            sentence = sentence.rstrip()\n            if sentence:\n                sentences.append(sentence)\n\n        return sentences\n\n    def count_words(self, sentence):\n        # Remove non-alphabetic characters except spaces\n        cleaned_sentence = ''.join(char if char.isalpha() or char.isspace() else ' ' for char in sentence)\n        words = cleaned_sentence.split()\n\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count\n",
  "SQLGenerator": "class SQLGenerator:\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=\"\"):\n        if fields is None:\n            fields_str = \"*\"\n        else:\n            fields_str = \", \".join(fields)\n\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join(f\"'{value}'\" for value in data.values())\n\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        set_clause = \", \".join(f\"{key} = '{value}'\" for key, value in data.items())\n\n        sql = f\"UPDATE {self.table_name} SET {set_clause}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition=\"\"):\n        sql = f\"DELETE FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n",
  "SQLQueryBuilder": "class SQLQueryBuilder:\n    @staticmethod\n    def select(table, columns=None, where=None):\n        if columns is None:\n            columns = [\"*\"]\n        if where is None:\n            where = []\n\n        # Handle if columns is a dictionary\n        if isinstance(columns, dict):\n            columns = list(columns.keys())\n\n        query = \"SELECT \"\n        if columns == [\"*\"]:\n            query += \"*\"\n        else:\n            query += \", \".join(columns)\n        \n        query += f\" FROM {table}\"\n        \n        if where:\n            # Handle if where is a dictionary\n            if isinstance(where, dict):\n                where = where.items()\n            query += \" WHERE \" + \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def insert(table, data):\n        if not data:\n            raise ValueError(\"Data pairs must be provided for an INSERT query.\")\n        \n        # Handle if data is a dictionary\n        if isinstance(data, dict):\n            data = data.items()\n\n        columns = \", \".join(key for key, _ in data)\n        values = \", \".join(f\"'{value}'\" for _, value in data)\n        \n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        if where is None:\n            where = []\n\n        query = f\"DELETE FROM {table}\"\n        \n        if where:\n            # Handle if where is a dictionary\n            if isinstance(where, dict):\n                where = where.items()\n            query += \" WHERE \" + \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        if not data:\n            raise ValueError(\"Data pairs must be provided for an UPDATE query.\")\n        if where is None:\n            where = []\n\n        # Handle if data is a dictionary\n        if isinstance(data, dict):\n            data = data.items()\n\n        set_clause = \", \".join(f\"{key}='{value}'\" for key, value in data)\n        query = f\"UPDATE {table} SET {set_clause}\"\n        \n        if where:\n            # Handle if where is a dictionary\n            if isinstance(where, dict):\n                where = where.items()\n            query += \" WHERE \" + \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n",
  "Statistics3": "import math\nfrom collections import Counter\nfrom statistics import nanmean, nanmedian, nanstd\nimport numpy as np\n\nclass Statistics3:\n    @staticmethod\n    def mean(data):\n        if not data:\n            return float('nan')\n        return nanmean(data)\n\n    @staticmethod\n    def median(data):\n        if not data:\n            return float('nan')\n        return nanmedian(data)\n\n    @staticmethod\n    def mode(data):\n        if not data:\n            return []\n        counter = Counter(data)\n        max_count = max(counter.values())\n        return [k for k, v in counter.items() if v == max_count]\n\n    @staticmethod\n    def correlation(x, y):\n        if len(x) != len(y):\n            raise ValueError(\"Vectors must be of the same length\")\n        if not x or not y:\n            return float('nan')\n        \n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator_x = math.sqrt(sum((xi - mean_x) ** 2 for xi in x))\n        denominator_y = math.sqrt(sum((yi - mean_y) ** 2 for yi in y))\n        \n        if denominator_x == 0 or denominator_y == 0:\n            return float('nan')\n        return numerator / (denominator_x * denominator_y)\n\n    @staticmethod\n    def correlation_matrix(data):\n        num_cols = len(data[0])\n        matrix = np.eye(num_cols)  # Start with an identity matrix\n        \n        for i in range(num_cols):\n            for j in range(i + 1, num_cols):\n                col1 = [row[i] for row in data]\n                col2 = [row[j] for row in data]\n                corr = Statistics3.correlation(col1, col2)\n                matrix[i][j] = corr\n                matrix[j][i] = corr  # Ensure symmetry\n        \n        return matrix.tolist()\n\n    @staticmethod\n    def standard_deviation(data):\n        if len(data) < 2:\n            return float('nan')\n        return nanstd(data, ddof=1)\n\n    @staticmethod\n    def z_score(data):\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation == float('nan') or std_deviation == 0:\n            return [float('nan')] * len(data)\n        \n        mean_value = Statistics3.mean(data)\n        return [(x - mean_value) / std_deviation for x in data]\n",
  "StockPortfolioTracker": "class Stock:\n    def __init__(self, name, price, quantity):\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n\n    def __eq__(self, other):\n        if isinstance(other, Stock):\n            return self.name == other.name and self.price == other.price and self.quantity == other.quantity\n        return False\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(data['name'], data['price'], data['quantity'])\n\n\nclass StockSummary:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __eq__(self, other):\n        if isinstance(other, StockSummary):\n            return self.name == other.name and self.value == other.value\n        return False\n\n\nclass StockPortfolioTracker:\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def _ensure_stock_instance(self, stock):\n        if isinstance(stock, dict):\n            return Stock.from_dict(stock)\n        elif not isinstance(stock, Stock):\n            raise ValueError(\"Invalid stock format\")\n        return stock\n\n    def add_stock(self, stock):\n        stock = self._ensure_stock_instance(stock)\n        for pf in self.portfolio:\n            if pf.name == stock.name:\n                pf.quantity += stock.quantity\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        stock = self._ensure_stock_instance(stock)\n        for i, pf in enumerate(self.portfolio):\n            if pf.name == stock.name and pf.quantity >= stock.quantity:\n                pf.quantity -= stock.quantity\n                if pf.quantity == 0:\n                    del self.portfolio[i]\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        stock = self._ensure_stock_instance(stock)\n        if stock.price * stock.quantity > self.cash_balance:\n            return False\n        self.add_stock(stock)\n        self.cash_balance -= stock.price * stock.quantity\n        return True\n\n    def sell_stock(self, stock):\n        stock = self._ensure_stock_instance(stock)\n        if not self.remove_stock(stock):\n            return False\n        self.cash_balance += stock.price * stock.quantity\n        return True\n\n    def calculate_portfolio_value(self):\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock.price * stock.quantity\n        return total_value\n\n    def get_portfolio_summary(self):\n        summary = [StockSummary(stock.name, self.get_stock_value(stock)) for stock in self.portfolio]\n        return self.calculate_portfolio_value(), summary\n\n    def get_stock_value(self, stock):\n        stock = self._ensure_stock_instance(stock)\n        return stock.price * stock.quantity\n\n    def get_portfolio(self):\n        return self.portfolio\n\n    def get_cash_balance(self):\n        return self.cash_balance\n\n    def set_portfolio(self, portfolio):\n        if not all(isinstance(item, (Stock, dict)) for item in portfolio):\n            raise ValueError(\"All items in the portfolio must be Stock instances or dict-like objects\")\n        self.portfolio = [self._ensure_stock_instance(item) for item in portfolio]\n",
  "StudentDatabaseProcessor": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        self.execute_query(create_table_query, [])\n\n    def insert_student(self, student_data):\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        params = [\n            student_data[\"name\"],\n            student_data[\"age\"],\n            student_data[\"gender\"],\n            student_data[\"grade\"]\n        ]\n        self.execute_query(insert_query, params)\n\n    def search_student_by_name(self, name):\n        select_query = \"\"\"\n        SELECT * FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        return self.query_result(select_query, params)\n\n    def delete_student_by_name(self, name):\n        delete_query = \"\"\"\n        DELETE FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        self.execute_query(delete_query, params)\n\n    def execute_query(self, query, params):\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            conn.commit()\n\n    def query_result(self, query, params):\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            return results\n",
  "TextFileProcessor": "import json\nimport re\n\nclass TextFileProcessor:\n    def __init__(self, filename):\n        self.filename_ = filename\n\n    def read_file_as_json(self):\n        with open(self.filename_, 'r') as file:\n            return json.load(file)\n\n    def read_file(self):\n        with open(self.filename_, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self.filename_, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        result = ''.join(filter(str.isalpha, content))\n        self.write_file(result)\n        return result\n",
  "Thermostat": "class Thermostat:\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, new_mode):\n        if new_mode in [\"heat\", \"cool\"]:\n            self.mode = new_mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = \"heat\"\n        else:\n            self.mode = \"cool\"\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == \"cool\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == \"heat\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == \"heat\":\n            while self.current_temperature < self.target_temperature:\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time\n",
  "TicTacToe": "class TicTacToe:\n    def __init__(self, N=3):\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if 0 <= row < len(self.board) and 0 <= col < len(self.board[0]) and self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        # Check rows\n        for row in self.board:\n            if row[0] != ' ' and all(cell == row[0] for cell in row):\n                return row[0]\n        \n        # Check columns\n        for col in range(len(self.board[0])):\n            if self.board[0][col] != ' ' and all(self.board[row][col] == self.board[0][col] for row in range(len(self.board))):\n                return self.board[0][col]\n        \n        # Check diagonals\n        if self.board[0][0] != ' ' and all(self.board[i][i] == self.board[0][0] for i in range(len(self.board))):\n            return self.board[0][0]\n        \n        if self.board[0][len(self.board)-1] != ' ' and all(self.board[i][len(self.board)-1-i] == self.board[0][len(self.board)-1] for i in range(len(self.board))):\n            return self.board[0][len(self.board)-1]\n        \n        return '\\0'\n\n    def is_board_full(self):\n        return all(all(cell != ' ' for cell in row) for row in self.board)\n\n    def get_current_player(self):\n        return self.current_player\n",
  "TimeUtils": "from datetime import datetime as _dt, timedelta as _td\n\nclass TimeUtils:\n    def __init__(self):\n        self._datetime = _dt.now()\n\n    def get_current_time(self) -> str:\n        return self._datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self) -> str:\n        return self._datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds: int) -> str:\n        self._datetime += _td(seconds=seconds)\n        return self._datetime.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, str_time: str) -> _dt:\n        return _dt.strptime(str_time, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime_obj: _dt) -> str:\n        return datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1: str, string_time2: str) -> int:\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        diff = (time2 - time1).total_seconds()\n        return int(diff / 60)\n\n    def get_format_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        dt = _dt(year, month, day, hour, minute, second)\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "TriCalculator": "import math\n\nclass TriCalculator:\n    PI = 3.14159265358979323846\n\n    def __init__(self):\n        pass\n\n    def round(self, value, precision):\n        factor = 10.0 ** precision\n        return round(value * factor) / factor\n\n    def cos(self, x):\n        result = self.taylor(x, 17)\n        print(f\"Taylor result for cos: {result}\")\n        return self.round(result, 10)\n\n    def factorial(self, a):\n        if a < 0:\n            return 0\n        if a == 0:\n            return 1\n        b = 1\n        for i in range(1, a + 1):\n            b *= i\n        return b\n\n    def taylor(self, x, n):\n        a = 0.0\n        x = x / 180.0 * self.PI\n        sign = 1\n\n        for k in range(n):\n            term = math.pow(x, 2 * k) / self.factorial(2 * k)\n            if k % 2 == 0:\n                a += term\n            else:\n                a -= term\n        return a\n\n    def sin(self, x):\n        x = x / 180.0 * self.PI\n        g = 0.0\n        t = x\n        n = 1\n\n        while abs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / ((2 * n - 1) * (2 * n - 2))\n        return self.round(g, 10)\n\n    def tan(self, x):\n        cosine = self.cos(x)\n        if abs(cosine) > 0.01:\n            result = self.sin(x) / cosine\n            return self.round(result, 10)\n        else:\n            return False\n",
  "TwentyFourPointGame": "import random\nimport re\nfrom collections import defaultdict\nfrom operator import add, sub, mul, truediv, pow\n\nclass TwentyFourPointGame:\n    def __init__(self):\n        self.nums = []\n        random.seed()\n\n    def get_my_cards(self):\n        self.nums.clear()\n        self.generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == \"pass\":\n            return self.get_my_cards()\n\n        # Count digits in the expression\n        statistic = defaultdict(int)\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[int(c)] += 1\n\n        # Check if all numbers are used exactly once\n        nums_used = statistic.copy()\n        for num in self.nums:\n            if nums_used[num] > 0:\n                nums_used[num] -= 1\n            else:\n                return []\n\n        if all(value == 0 for value in nums_used.values()):\n            if self.evaluate_expression(expression):\n                return [1]\n            else:\n                return []\n        else:\n            return []\n\n    def evaluate_expression(self, expression):\n        try:\n            if not re.match(r'^[\\d+\\-*/^(). ]+$', expression):\n                raise ValueError(\"Invalid characters in expression\")\n\n            calculator = Calculator()\n            result = calculator.calculate(expression)\n\n            return abs(result - 24.0) < 1e-6  # Allowing for floating-point precision issues\n        except Exception:\n            return False\n\n    def set_nums(self, now):\n        self.nums = now\n\n    def generate_cards(self):\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n        assert len(self.nums) == 4\n\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': add,\n            '-': sub,\n            '*': mul,\n            '/': truediv,\n            '^': pow\n        }\n\n    def calculate(self, expression):\n        if not expression:\n            return 0.0\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer += ch\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if ch in self.operators:\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op):\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(op, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[op](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "URLHandler": "from urllib.parse import urlparse, parse_qs, unquote\n\nclass URLHandler:\n    def __init__(self, url):\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self) -> str:\n        scheme = self.parsed_url.scheme\n        return scheme if scheme else None\n\n    def get_host(self) -> str:\n        host = self.parsed_url.netloc\n        return host if host else None\n\n    def get_path(self) -> str:\n        path = self.parsed_url.path\n        query = self.parsed_url.query\n        fragment = self.parsed_url.fragment\n        if path or query or fragment:\n            return f\"{path}?{query}#{fragment}\".rstrip(' ?#')\n        return None\n\n    def get_query_params(self) -> dict:\n        query_params = parse_qs(self.parsed_url.query)\n        if not query_params:\n            return None\n        # Convert lists to single values if there's only one value\n        return {k: v[0] if len(v) == 1 else v for k, v in query_params.items()}\n\n    def get_fragment(self) -> str:\n        fragment = self.parsed_url.fragment\n        return fragment if fragment else None\n",
  "UrlPath": "class UrlPath:\n    def __init__(self):\n        self.segments = []\n        self._with_end_tag = False\n\n    def add(self, segment: str):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path: str, charset: str):\n        if not path:\n            return\n\n        if path.endswith('/'):\n            self._with_end_tag = True\n\n        fixed_path = self.fix_path(path)\n        if fixed_path:\n            for segment in fixed_path.split('/'):\n                decoded_seg = ''\n                for ch in segment:\n                    if ch == '%':\n                        # Placeholder for percent-encoded character handling\n                        pass\n                    else:\n                        decoded_seg += ch\n                self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path: str) -> str:\n        if not path:\n            return \"\"\n\n        segment_str = path\n        if segment_str.startswith('/'):\n            segment_str = segment_str[1:]\n        if segment_str.endswith('/'):\n            segment_str = segment_str[:-1]\n        return segment_str\n\n    def get_segments(self) -> list:\n        return self.segments\n\n    @property\n    def with_end_tag(self) -> bool:\n        return self._with_end_tag\n",
  "UserLoginDB": "import sqlite3\nfrom contextlib import closing\n\nclass UserLoginDB:\n    def __init__(self, db_name):\n        self.connection = None\n        self.stmt = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.create_table()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Cannot open database: {e}\")\n\n    def __del__(self):\n        self.finalize_statement()\n        if self.connection:\n            self.connection.close()\n\n    def prepare_statement(self, query):\n        self.finalize_statement()\n        try:\n            self.stmt = self.connection.cursor()\n            self.stmt.execute(query)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to prepare statement: {e}\")\n\n    def finalize_statement(self):\n        if self.stmt:\n            self.stmt.close()\n            self.stmt = None\n\n    def insert_user(self, username, password):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to insert user: {e}\")\n\n    def search_user_by_username(self, username):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n                row = cursor.fetchone()\n                return (row[0], row[1]) if row else None\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to search user: {e}\")\n\n    def delete_user_by_username(self, username):\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to delete user: {e}\")\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        return user is not None and user[1] == password\n\n    def create_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT,\n            password TEXT\n        )\n        \"\"\"\n        with closing(self.connection.cursor()) as cursor:\n            try:\n                cursor.execute(create_table_query)\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Cannot create table: {e}\")\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n",
  "VectorUtil": "import math\nfrom typing import List, Tuple, Dict\n\nclass VectorUtil:\n    @staticmethod\n    def norm(vector: Tuple[float, ...]) -> float:\n        return math.sqrt(sum(val * val for val in vector))\n\n    @staticmethod\n    def normalize(vector: Tuple[float, ...]) -> Tuple[float, ...]:\n        vec_norm = VectorUtil.norm(vector)\n        if vec_norm == 0.0:\n            return tuple(0.0 for _ in vector)\n        return tuple(val / vec_norm for val in vector)\n\n    @staticmethod\n    def similarity(vector_1: Tuple[float, ...], vector_2: Tuple[float, ...]) -> float:\n        norm_vec1 = VectorUtil.normalize(vector_1)\n        norm_vec2 = VectorUtil.normalize(vector_2)\n        dot_product = sum(norm_vec1[i] * norm_vec2[i] for i in range(len(vector_1)))\n        return dot_product\n\n    @staticmethod\n    def cosine_similarities(vector_1: Tuple[float, ...], vectors_all: List[Tuple[float, ...]]) -> List[float]:\n        norm_vec1 = VectorUtil.norm(vector_1)\n        similarities = []\n        for vec in vectors_all:\n            norm_vec_all = VectorUtil.norm(vec)\n            if norm_vec_all == 0.0:\n                similarities.append(0.0)\n                continue\n            dot_product = sum(vec[i] * vector_1[i] for i in range(len(vector_1)))\n            similarity = dot_product / (norm_vec1 * norm_vec_all)\n            similarities.append(similarity)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1: List[Tuple[float, ...]], vector_list_2: List[Tuple[float, ...]]) -> float:\n        if not vector_list_1 or not vector_list_2:\n            raise ValueError(\"At least one of the lists is empty.\")\n\n        mean_vec1 = tuple(sum(vec[i] for vec in vector_list_1) / len(vector_list_1) for i in range(len(vector_list_1[0])))\n        mean_vec2 = tuple(sum(vec[i] for vec in vector_list_2) / len(vector_list_2) for i in range(len(vector_list_2[0])))\n\n        return VectorUtil.similarity(mean_vec1, mean_vec2)\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: Dict[str, float]) -> Dict[str, float]:\n        result = {}\n        for key, count in number_dict.items():\n            idf_value = math.log((total_num + 1.0) / (count + 1.0))\n            result[key] = idf_value\n        return result\n\n# Pre-instantiated templates for vectors of size 2 and 8\nVectorUtil.similarity_2d = lambda v1, v2: VectorUtil.similarity(v1, v2)\nVectorUtil.cosine_similarities_2d = lambda v1, vs: VectorUtil.cosine_similarities(v1, vs)\nVectorUtil.n_similarity_2d = lambda vl1, vl2: VectorUtil.n_similarity(vl1, vl2)\n\nVectorUtil.similarity_8d = lambda v1, v2: VectorUtil.similarity(v1, v2)\nVectorUtil.cosine_similarities_8d = lambda v1, vs: VectorUtil.cosine_similarities(v1, vs)\nVectorUtil.n_similarity_8d = lambda vl1, vl2: VectorUtil.n_similarity(vl1, vl2)\n",
  "VendingMachine": "class VendingMachine:\n    def __init__(self):\n        self._inventory = {}\n        self._balance = 0.0\n\n    @property\n    def balance(self):\n        return self._balance\n\n    @balance.setter\n    def balance(self, value):\n        self._balance = value\n\n    @property\n    def inventory(self):\n        return self._inventory\n\n    @inventory.setter\n    def inventory(self, value):\n        self._inventory = value\n\n    def add_item(self, item_name: str, price: float, quantity: int):\n        if not self.restock_item(item_name, quantity):\n            self._inventory[item_name] = {\"price\": price, \"quantity\": quantity}\n\n    def insert_coin(self, amount: float) -> float:\n        self._balance += amount\n        return self._balance\n\n    def purchase_item(self, item_name: str) -> float:\n        if item_name in self._inventory:\n            item = self._inventory[item_name]\n            if item[\"quantity\"] > 0 and self._balance >= item[\"price\"]:\n                self._balance -= item[\"price\"]\n                item[\"quantity\"] -= 1\n                return self._balance\n        return 0.0  # Return 0.0 to indicate failure instead of False\n\n    def restock_item(self, item_name: str, quantity: int) -> bool:\n        if item_name in self._inventory:\n            self._inventory[item_name][\"quantity\"] += quantity\n            return True\n        return False\n\n    def display_items(self) -> str:\n        if not self._inventory:\n            return False\n\n        return \"\\n\".join(f\"{item} - ${info['price']} [{info['quantity']}]\" for item, info in self._inventory.items())\n",
  "Warehouse": "class Warehouse:\n    def __init__(self):\n        self._inventory = {}\n        self._orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        if product_id not in self._inventory:\n            self._inventory[product_id] = {\"name\": name, \"quantity\": quantity}\n        else:\n            self._inventory[product_id][\"quantity\"] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self._inventory:\n            self._inventory[product_id][\"quantity\"] += quantity\n\n    def get_product_quantity(self, product_id):\n        return self._inventory.get(product_id, {}).get(\"quantity\", 0)\n\n    def create_order(self, order_id, product_id, quantity):\n        available_quantity = self.get_product_quantity(product_id)\n        if available_quantity >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self._orders[order_id] = {\n                \"product_id\": product_id,\n                \"quantity\": quantity,\n                \"status\": \"Shipped\"\n            }\n            return True\n        return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self._orders:\n            self._orders[order_id][\"status\"] = status\n            return True\n        return False\n\n    def track_order(self, order_id):\n        return self._orders.get(order_id, {}).get(\"status\", \"\")\n\n    @property\n    def orders(self):\n        return self._orders\n\n    @property\n    def inventory(self):\n        return self._inventory\n",
  "WeatherSystem": "class WeatherInfo:\n    def __init__(self, weather, temperature, temperature_units):\n        self.weather = weather\n        self.temperature = temperature\n        self.temperature_units = temperature_units\n\n\nclass WeatherSystem:\n    def __init__(self, city):\n        self.city = city\n        self.temperature = 0.0\n        self.weather = \"\"\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units=\"celsius\"):\n        self.weather_list = weather_list\n        weather_info = self.weather_list.get(self.city)\n        if weather_info is None:\n            return False  # Return False instead of (0.0, \"\") as per the error message\n\n        self.temperature = weather_info['temperature']\n        self.weather = weather_info['weather']\n\n        if weather_info['temperature_units'] != tmp_units:\n            if tmp_units == \"celsius\":\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == \"fahrenheit\":\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        self.city = city\n\n    def set_temperature(self, temperature):\n        self.temperature = temperature\n\n    def celsius_to_fahrenheit(self):\n        return (self.temperature * 9 / 5) + 32\n\n    def fahrenheit_to_celsius(self):\n        return (self.temperature - 32) * 5 / 9\n\n    def get_city(self):\n        return self.city\n",
  "Words2Numbers": "class Words2Numbers:\n    def __init__(self):\n        self.units = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                      \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\",\n                      \"eighteen\", \"nineteen\"]\n        \n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        \n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n        \n        self.numwords = {\"and\": (1, 0)}\n        for idx, unit in enumerate(self.units):\n            self.numwords[unit] = (1, idx)\n        for idx, ten in enumerate(self.tens):\n            self.numwords[ten] = (1, idx * 10)\n        for idx, scale in enumerate(self.scales):\n            self.numwords[scale] = (10 ** (idx * 3), 0)\n        self.numwords[\"hundred\"] = (100, 0)\n        \n        self.ordinal_words = {\"first\": 1, \"second\": 2, \"third\": 3, \"fourth\": 4, \"fifth\": 5, \"sixth\": 6,\n                             \"seventh\": 7, \"eighth\": 8, \"ninth\": 9, \"tenth\": 10, \"eleventh\": 11,\n                             \"twelfth\": 12, \"thirteenth\": 13, \"fourteenth\": 14, \"fifteenth\": 15,\n                             \"sixteenth\": 16, \"seventeenth\": 17, \"eighteenth\": 18, \"nineteenth\": 19,\n                             \"twentieth\": 20, \"thirtieth\": 30, \"fortieth\": 40, \"fiftieth\": 50,\n                             \"sixtieth\": 60, \"seventieth\": 70, \"eightieth\": 80, \"ninetieth\": 90}\n        \n        self.ordinal_endings = [(\"ieth\", \"y\"), (\"th\", \"\"), (\"st\", \"\"), (\"nd\", \"\"), (\"rd\", \"\")]\n\n    def text2int(self, textnum):\n        text = textnum.replace('-', ' ').lower()\n        current = 0\n        result = 0\n        curstring = \"\"\n\n        for word in text.split():\n            if word in self.ordinal_words:\n                scale = 1\n                increment = self.ordinal_words[word]\n                current = current * scale + increment\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word in self.numwords:\n                    scale, increment = self.numwords[word]\n                    if scale == 1:\n                        current += increment\n                    else:\n                        current *= scale\n                        result += current\n                        current = 0\n                else:\n                    if current > 0:\n                        result += current\n                        current = 0\n                    curstring += word + \" \"\n\n        if current > 0:\n            result += current\n\n        curstring += str(result)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        text = textnum.replace('-', ' ').lower()\n        for word in text.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word not in self.numwords:\n                    return False\n        return True\n",
  "XMLProcessor": "import xml.etree.ElementTree as ET\nimport sys\nimport os\n\nclass XMLProcessor:\n    def __init__(self, file_name):\n        self.file_name = file_name\n        self.tree = None\n        self.root = None\n\n    def read_xml(self):\n        try:\n            if not self.file_name or not os.path.exists(self.file_name):\n                raise FileNotFoundError(f\"File not found: {self.file_name}\")\n            self.tree = ET.parse(self.file_name)\n            self.root = self.tree.getroot()\n        except (ET.ParseError, FileNotFoundError) as e:\n            print(f\"Error: Could not load XML file: {self.file_name}\", file=sys.stderr)\n            return None\n        return self.root\n\n    def write_xml(self, file_name):\n        if self.root is None:\n            print(\"Error: No XML document to write.\", file=sys.stderr)\n            return False\n        if self.tree is None:\n            self.tree = ET.ElementTree(self.root)\n        try:\n            self.tree.write(file_name, encoding='utf-8', xml_declaration=True)\n            return True\n        except IOError as e:\n            print(f\"Error: Could not write XML file: {file_name}\", file=sys.stderr)\n            return False\n\n    def process_xml_data(self, file_name):\n        if self.root is None:\n            print(\"Error: No root element found.\", file=sys.stderr)\n            return False\n\n        for element in self.root.findall('.//item'):\n            text = element.text\n            if text:\n                element.text = text.upper()\n\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        if self.root is None:\n            return []\n\n        return self.root.findall(f'.//{element_name}')\n",
  "ZipFileProcessor": "import os\nimport zipfile\nfrom pathlib import Path\n\nclass ZipFileInfo:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n\nclass ZipFileProcessor:\n    def __init__(self, zip_file_path):\n        self.zip_file_path = zip_file_path\n\n    def extract_all(self, output_directory):\n        if not output_directory:\n            return False\n        \n        if not self.create_directory_if_not_exists(output_directory):\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(output_directory)\n        except Exception as e:\n            print(f\"Failed to extract all files: {e}\")\n            return False\n        return True\n\n    def extract_file(self, file_name, output_directory):\n        if not output_directory:\n            return False\n\n        if not self.create_directory_if_not_exists(output_directory):\n            print(f\"Failed to create output directory: {output_directory}\")\n            return False\n\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                if file_name in zip_ref.namelist():\n                    zip_ref.extract(file_name, output_directory)\n                else:\n                    print(f\"File not found in zip: {file_name}\")\n                    return False\n        except Exception as e:\n            print(f\"Failed to extract file: {e}\")\n            return False\n        return True\n\n    def create_zip_file(self, files, output_zip_file):\n        try:\n            with zipfile.ZipFile(output_zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:\n                for file_path in files:\n                    zipf.write(file_path, os.path.basename(file_path))\n        except Exception as e:\n            print(f\"Error creating zip file: {e}\")\n            return False\n        return True\n\n    def read_zip_file(self):\n        try:\n            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:\n                info = ZipFileInfo(self.zip_file_path, 'r')\n        except Exception as e:\n            print(f\"Failed to read zip file: {e}\")\n            return None\n        return info\n\n    @staticmethod\n    def create_directory_if_not_exists(dir_path):\n        try:\n            Path(dir_path).mkdir(parents=True, exist_ok=True)\n        except Exception as e:\n            print(f\"Failed to create directory: {e}\")\n            return False\n        return True\n"
}
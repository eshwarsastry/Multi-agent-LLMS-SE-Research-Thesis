{
  "AccessGatewayFilter": "import time\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    level: int\n    address: str\n\n@dataclass\nclass Authorization:\n    user: User\n    jwt: str\n\n@dataclass\nclass Request:\n    path: str\n    method: str\n    auth: Authorization\n\nclass AccessGatewayFilter:\n    def __init__(self):\n        pass\n\n    def filter(self, request: Request) -> bool:\n        request_uri = request.path\n        method = request.method\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token.user\n            if user.level > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n        return False\n\n    @staticmethod\n    def is_start_with(request_uri: str) -> bool:\n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request: Request) -> Authorization:\n        token = request.auth\n        user = token.user\n\n        if token.jwt.startswith(user.name):\n            jwt_str_date = token.jwt[len(user.name):]\n\n            try:\n                jwt_timestamp = float(jwt_str_date)\n            except ValueError:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n\n            now = time.time()\n            if now - jwt_timestamp >= 3 * 24 * 60 * 60:\n                return Authorization(User(\"\", 0, \"\"), \"\")\n        return token\n\n    @staticmethod\n    def set_current_user_info_and_log(user: User):\n        current_time = int(time.time())\n        print(f\"{user.name} {user.address} {current_time}\")\n\n# Example usage:\n# request = Request(\"/some/path\", \"GET\", Authorization(User(\"JohnDoe\", 3, \"123 Main St\"), \"JohnDoe1633072800\"))\n# filter_instance = AccessGatewayFilter()\n# print(filter_instance.filter(request))\n",
  "AreaCalculator": "import math\n\nclass AreaCalculator:\n    def __init__(self, radius):\n        if radius < 0:\n            raise ValueError(\"Radius cannot be negative.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius * self.radius\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius * self.radius\n\n    def calculate_cylinder_area(self, height):\n        if height < 0:\n            raise ValueError(\"Height cannot be negative.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return 0.5 * self.radius * self.radius * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        if inner_radius > outer_radius:\n            raise ValueError(\"Inner radius cannot be greater than outer radius.\")\n        return math.pi * (outer_radius * outer_radius - inner_radius * inner_radius)\n\n# Unit tests using unittest framework\nimport unittest\n\nclass TestAreaCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = AreaCalculator(5)\n\n    def test_calculate_circle_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_circle_area(), 78.53981633974483)\n\n    def test_calculate_sphere_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_sphere_area(), 314.1592653589793)\n\n    def test_calculate_cylinder_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_cylinder_area(10), 471.23889803846896)\n\n    def test_calculate_sector_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_sector_area(math.pi), 39.269908169872416)\n\n    def test_calculate_annulus_area(self):\n        self.assertAlmostEqual(self.calculator.calculate_annulus_area(3, 5), 50.26548245743669)\n\n    def test_negative_radius(self):\n        with self.assertRaises(ValueError):\n            AreaCalculator(-1)\n\n    def test_negative_height(self):\n        with self.assertRaises(ValueError):\n            self.calculator.calculate_cylinder_area(-1)\n\n    def test_invalid_inner_radius(self):\n        with self.assertRaises(ValueError):\n            self.calculator.calculate_annulus_area(6, 5)\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "ArrangementCalculator": "from typing import List\n\nclass ArrangementCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int = -1) -> int:\n        if m == -1 or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m: int = -1) -> List[List[str]]:\n        result = []\n        if m == -1:\n            m = len(self.datas)\n\n        current = []\n        remaining = self.datas.copy()\n\n        self._permutations_recursive(current, remaining, m, result)\n\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            partial_result = self.select(i)\n            result.extend(partial_result)\n        return result\n\n    def _permutations_recursive(self, current: List[str], remaining: List[str], m: int, result: List[List[str]]) -> None:\n        if len(current) == m:\n            result.append(current.copy())\n        else:\n            for i in range(len(remaining)):\n                new_current = current + [remaining[i]]\n                new_remaining = remaining[:i] + remaining[i+1:]\n                self._permutations_recursive(new_current, new_remaining, m, result)\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n",
  "AssessmentSystem": "from typing import Optional, Dict, List\n\nclass Student:\n    def __init__(self, grade: int, major: str):\n        self.grade = grade\n        self.major = major\n        self.courses: Dict[str, int] = {}\n\n\nclass AssessmentSystem:\n    def __init__(self):\n        self.students: Dict[str, Student] = {}\n\n    def add_student(self, name: str, grade: int, major: str):\n        self.students[name] = Student(grade, major)\n\n    def add_course_score(self, name: str, course: str, score: int):\n        if name in self.students:\n            self.students[name].courses[course] = score\n\n    def get_gpa(self, name: str) -> Optional[float]:\n        student = self.students.get(name)\n        if student and student.courses:\n            total_score = sum(student.courses.values())\n            return total_score / len(student.courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> List[str]:\n        students_with_fail = []\n        for name, student in self.students.items():\n            if any(score < 60 for score in student.courses.values()):\n                students_with_fail.append(name)\n        return students_with_fail\n\n    def get_course_average(self, course: str) -> Optional[float]:\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student.courses:\n                total += student.courses[course]\n                count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self) -> Optional[str]:\n        top_student = None\n        highest_gpa = None\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and (highest_gpa is None or gpa > highest_gpa):\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n",
  "AutomaticGuitarSimulator": "class PlayItem:\n    def __init__(self, chord, tune):\n        self.chord = chord\n        self.tune = tune\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        self.play_text = text\n\n    def interpret(self, display=False):\n        play_list = []\n        if not self.play_text:\n            return play_list\n\n        for play_seg in self.play_text.split():\n            pos = 0\n            while pos < len(play_seg) and play_seg[pos].isalpha():\n                pos += 1\n\n            play_chord = play_seg[:pos]\n            play_value = play_seg[pos:]\n\n            item = PlayItem(play_chord, play_value)\n            play_list.append(item)\n\n            if display:\n                print(self.format_display(play_chord, play_value))\n        \n        return play_list\n\n    @staticmethod\n    def format_display(key, value):\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n\n# Example usage:\n# simulator = AutomaticGuitarSimulator(\"Am4 C5 E6\")\n# items = simulator.interpret(display=True)\n",
  "AvgPartition": "class AvgPartition:\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the AvgPartition class with a list of integers and a limit.\n        \n        :param lst: List of integers to be partitioned.\n        :param limit: The maximum number of partitions.\n        \"\"\"\n        self.lst = lst[:]\n        self.limit = limit\n\n    def set_num(self):\n        \"\"\"\n        Determine the number of elements per partition and the remainder.\n        \n        :return: A tuple containing the base size of each partition and the remainder.\n        \"\"\"\n        if self.limit <= 0:\n            return 0, len(self.lst)\n        \n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Retrieve a specific partition of the list based on the index.\n        \n        :param index: The index of the partition to retrieve.\n        :return: A list representing the partition at the given index.\n        \"\"\"\n        if self.limit <= 0:\n            return []\n        \n        size, remainder = self.set_num()\n        if index >= self.limit:\n            return []\n        \n        start = index * size + min(index, remainder)\n        end = start + size\n        if index < remainder:\n            end += 1\n        \n        return self.lst[start:end]\n\n# Example usage:\n# avg_partition = AvgPartition([1, 2, 3, 4, 5, 6, 7, 8], 3)\n# print(avg_partition.get(0))  # Output: [1, 2, 3]\n# print(avg_partition.get(1))  # Output: [4, 5, 6]\n# print(avg_partition.get(2))  # Output: [7, 8]\n",
  "BankAccount": "class InvalidAmountError(Exception):\n    \"\"\"Exception raised for errors in the input amount.\"\"\"\n    pass\n\nclass InsufficientBalanceError(Exception):\n    \"\"\"Exception raised when there is an attempt to withdraw more than the balance.\"\"\"\n    pass\n\nclass BankAccount:\n    def __init__(self, balance=0):\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise InvalidAmountError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise InvalidAmountError(\"Invalid amount\")\n        if amount > self.balance:\n            raise InsufficientBalanceError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n# Example usage:\n# account1 = BankAccount(100)\n# account2 = BankAccount(50)\n# account1.transfer(account2, 30)\n# print(account1.view_balance())  # Output: 70\n# print(account2.view_balance())  # Output: 80\n",
  "BinaryDataProcessor": "class BinaryDataProcessor:\n    def __init__(self, binary_string):\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        # Remove any non-binary characters ('0' or '1') from the input string\n        self.binary_string = ''.join(c for c in self.binary_string if c in '01')\n\n    def calculate_binary_info(self):\n        # Calculate the percentage of zeroes and ones in the cleaned binary string\n        if not self.binary_string:\n            raise ValueError(\"The binary string is empty after cleaning.\")\n        \n        zeroes_count = self.binary_string.count('0')\n        ones_count = len(self.binary_string) - zeroes_count\n        total_length = len(self.binary_string)\n\n        zeroes_percentage = zeroes_count / total_length\n        ones_percentage = ones_count / total_length\n\n        return {\n            \"Zeroes\": zeroes_percentage,\n            \"Ones\": ones_percentage,\n            \"Bit length\": total_length\n        }\n\n    def convert_to_ascii(self):\n        # Convert the cleaned binary string into an ASCII string\n        ascii_string = ''\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            if len(byte) == 8:  # Ensure we have a full byte\n                ascii_string += chr(int(byte, 2))\n        return ascii_string\n\n    def convert_to_utf8(self):\n        # Convert the cleaned binary string into a UTF-8 string\n        return self.convert_to_ascii()\n\n# Example usage:\n# processor = BinaryDataProcessor(\"110010101111001\")\n# print(processor.calculate_binary_info())\n# print(processor.convert_to_ascii())\n# print(processor.convert_to_utf8())\n",
  "BitStatusUtil": "class BitStatusUtil:\n    @staticmethod\n    def add(states: int, stat: int) -> int:\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states: int, stat: int) -> bool:\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states: int, stat: int) -> int:\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args: list[int]) -> None:\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n\n# Example usage:\n# bit_util = BitStatusUtil()\n# new_states = bit_util.add(0b1010, 0b0010)\n# print(bit_util.has(new_states, 0b0010))  # Should print True\n# updated_states = bit_util.remove(new_states, 0b0010)\n# print(bit_util.has(updated_states, 0b0010))  # Should print False\n",
  "BlackjackGame": "import random\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        suits = [\"S\", \"C\", \"D\", \"H\"]\n        ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank == \"A\":\n                value += 11\n                num_aces += 1\n            else:\n                value += 10\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            return \"Player wins\" if player_value <= dealer_value else \"Dealer wins\"\n        elif player_value > 21:\n            return \"Dealer wins\"\n        elif dealer_value > 21:\n            return \"Player wins\"\n        else:\n            return \"Dealer wins\" if player_value <= dealer_value else \"Player wins\"\n\n# Example usage:\n# game = BlackjackGame()\n# print(game.check_winner([\"A10\"], [\"A9\"]))\n",
  "BookManagement": "from threading import Lock\n\nclass BookManagement:\n    def __init__(self):\n        self.inventory = {}\n        self.lock = Lock()\n\n    def add_book(self, title: str, quantity: int = 1):\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be a positive integer.\")\n        with self.lock:\n            if title in self.inventory:\n                self.inventory[title] += quantity\n            else:\n                self.inventory[title] = quantity\n\n    def remove_book(self, title: str, quantity: int):\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be a positive integer.\")\n        with self.lock:\n            if title not in self.inventory or self.inventory[title] < quantity:\n                raise RuntimeError(\"Insufficient quantity or book not found\")\n            self.inventory[title] -= quantity\n            if self.inventory[title] == 0:\n                del self.inventory[title]\n\n    def view_inventory(self) -> dict:\n        with self.lock:\n            return self.inventory.copy()\n\n    def view_book_quantity(self, title: str) -> int:\n        with self.lock:\n            return self.inventory.get(title, 0)\n\n# Example usage:\n# book_manager = BookManagement()\n# book_manager.add_book(\"Python Programming\", 5)\n# print(book_manager.view_inventory())\n# book_manager.remove_book(\"Python Programming\", 2)\n# print(book_manager.view_book_quantity(\"Python Programming\"))\n",
  "BookManagementDB": "import sqlite3\nfrom typing import List, Tuple\n\nclass BookManagementDB:\n    def __init__(self, db_name: str):\n        self.connection = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def __del__(self):\n        if self.connection:\n            self.connection.close()\n\n    def create_table(self):\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS books (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            author TEXT NOT NULL,\n            available INTEGER NOT NULL\n        )\n        \"\"\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(create_table_sql)\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n\n    def add_book(self, title: str, author: str):\n        insert_sql = \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(insert_sql, (title, author))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to add book: {e}\")\n\n    def remove_book(self, book_id: int):\n        delete_sql = \"DELETE FROM books WHERE id = ?\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(delete_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to remove book: {e}\")\n\n    def borrow_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 0 WHERE id = ?\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to mark book as borrowed: {e}\")\n\n    def return_book(self, book_id: int):\n        update_sql = \"UPDATE books SET available = 1 WHERE id = ?\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(update_sql, (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to mark book as returned: {e}\")\n\n    def search_books(self) -> List[Tuple[int, str, str, int]]:\n        select_sql = \"SELECT * FROM books\"\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(select_sql)\n            books = cursor.fetchall()\n            return [(row[0], row[1], row[2], row[3]) for row in books]\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to search books: {e}\")\n\n    def get_connection(self):\n        return self.connection\n",
  "CalendarUtil": "from datetime import datetime, timedelta\nimport time\n\nclass CalendarUtil:\n    class Event:\n        def __init__(self, date, start_time, end_time, description):\n            self.date = date\n            self.start_time = start_time\n            self.end_time = end_time\n            self.description = description\n\n        def __eq__(self, other):\n            return (self.date == other.date and\n                    self.start_time == other.start_time and\n                    self.end_time == other.end_time and\n                    self.description == other.description)\n\n    def __init__(self):\n        self.events = []\n\n    def add_event(self, event):\n        if event not in self.events:\n            self.events.append(event)\n\n    def remove_event(self, event):\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        events_on_date = []\n        for event in self.events:\n            if event.date.date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        for event in self.events:\n            if start_time < event.end_time and end_time > event.start_time:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        available_slots = []\n        start_time = datetime.combine(date, datetime.min.time())\n        end_time = start_time + timedelta(days=1) - timedelta(seconds=1)\n\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(hours=1)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time = slot_end_time\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        now = datetime.now()\n        upcoming_events = [event for event in self.events if event.start_time >= now]\n        return upcoming_events[:num_events]\n\ndef time_from_timestamp(timestamp):\n    return datetime.fromtimestamp(timestamp)\n\n# Example usage:\n# calendar = CalendarUtil()\n# event = CalendarUtil.Event(datetime(2023, 10, 1, 14, 0), datetime(2023, 10, 1, 15, 0), \"Meeting\")\n# calendar.add_event(event)\n# print(calendar.get_events(datetime(2023, 10, 1)))\n",
  "ChandrasekharSieve": "class ChandrasekharSieve:\n    def __init__(self, n):\n        if n < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def get_primes(self):\n        return self.primes\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        return [i for i in range(2, self.n + 1) if sieve[i]]\n\n# Example usage:\n# sieve = ChandrasekharSieve(30)\n# print(sieve.get_primes())\n",
  "Chat": "from datetime import datetime\nfrom collections import defaultdict\n\nclass Chat:\n    class Message:\n        def __init__(self, sender, receiver, message, timestamp):\n            self.sender = sender\n            self.receiver = receiver\n            self.message = message\n            self.timestamp = timestamp\n\n    def __init__(self):\n        self.users = defaultdict(list)\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = self.get_current_time()\n        message_info = self.Message(sender, receiver, message, timestamp)\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        return self.users.get(username, [])\n\n    def get_users(self):\n        return dict(self.users)\n\n    @staticmethod\n    def get_current_time():\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "ClassRegistrationSystem": "class Student:\n    def __init__(self, name, major):\n        self.name = name\n        self.major = major\n\n    def get_name(self):\n        return self.name\n\n    def get_major(self):\n        return self.major\n\n    def set_name(self, name):\n        self.name = name\n\n    def set_major(self, major):\n        self.major = major\n\n    def __eq__(self, other):\n        return self.name == other.name and self.major == other.major\n\n\nclass ClassRegistrationSystem:\n    def __init__(self):\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, new_student):\n        if any(student.get_name() == new_student.get_name() for student in self.students):\n            return 0\n        self.students.append(new_student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        if class_name not in self.students_registration_classes[student_name]:\n            self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        return [student.get_name() for student in self.students if student.get_major() == major]\n\n    def get_all_majors(self):\n        return list(set(student.get_major() for student in self.students))\n\n    def get_most_popular_class_in_major(self, major):\n        class_count = {}\n        for student in self.students:\n            if student.get_major() == major:\n                student_name = student.get_name()\n                if student_name in self.students_registration_classes:\n                    for class_name in self.students_registration_classes[student_name]:\n                        if class_name in class_count:\n                            class_count[class_name] += 1\n                        else:\n                            class_count[class_name] = 1\n\n        most_popular_class = None\n        max_count = 0\n        for class_name, count in class_count.items():\n            if count > max_count:\n                most_popular_class = class_name\n                max_count = count\n\n        return most_popular_class\n",
  "Classroom": "import datetime\nimport sys\n\nclass Course:\n    def __init__(self, name, start_time, end_time):\n        self.name = name\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.start_time == other.start_time and\n                self.end_time == other.end_time)\n\nclass Classroom:\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_tm = self.string_to_tm(check_time)\n\n        for course in self.courses:\n            start_tm = self.string_to_tm(course.start_time)\n            end_tm = self.string_to_tm(course.end_time)\n\n            if not all([check_tm, start_tm, end_tm]):\n                sys.stderr.write(\"Time conversion failed\\n\")\n                return False\n\n            if self.is_time_conflict(check_tm, check_tm, start_tm, end_tm):\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        new_start_tm = self.string_to_tm(new_course.start_time)\n        new_end_tm = self.string_to_tm(new_course.end_time)\n\n        if not all([new_start_tm, new_end_tm]):\n            sys.stderr.write(\"Time conversion failed\\n\")\n            return True\n\n        for course in self.courses:\n            start_tm = self.string_to_tm(course.start_time)\n            end_tm = self.string_to_tm(course.end_time)\n\n            if not all([start_tm, end_tm]):\n                sys.stderr.write(\"Time conversion failed\\n\")\n                return True\n\n            if self.is_time_conflict(start_tm, end_tm, new_start_tm, new_end_tm):\n                return False\n        return True\n\n    def has_course(self, course):\n        return course in self.courses\n\n    def string_to_tm(self, time_str):\n        try:\n            return datetime.datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(f\"Invalid time format: {time_str}\")\n\n    def is_time_conflict(self, start1, end1, start2, end2):\n        # Convert time objects to datetime objects on the same day for comparison\n        dummy_date = datetime.date(2023, 1, 1)\n        dt1_start = datetime.datetime.combine(dummy_date, start1)\n        dt1_end = datetime.datetime.combine(dummy_date, end1)\n        dt2_start = datetime.datetime.combine(dummy_date, start2)\n        dt2_end = datetime.datetime.combine(dummy_date, end2)\n\n        return (dt1_start <= dt2_end and dt1_end >= dt2_start)\n\n# Example usage:\n# classroom = Classroom(1)\n# course1 = Course(\"Math\", \"09:00\", \"10:00\")\n# classroom.add_course(course1)\n# print(classroom.is_free_at(\"09:30\"))  # Should return False\n# print(classroom.check_course_conflict(Course(\"Science\", \"10:00\", \"11:00\")))  # Should return True\n",
  "CookiesUtil": "import json\nimport os\n\nclass CookiesUtil:\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response):\n        if 'cookies' in response:\n            self.cookies = response['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        cookies_data = {}\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n        except FileNotFoundError:\n            print(f\"Error: The file {self.cookies_file} does not exist.\", file=os.sys.stderr)\n        except json.JSONDecodeError as e:\n            print(f\"Error reading JSON file: {e}\", file=os.sys.stderr)\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n        \n        return cookies_data\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file, indent=4)\n            return True\n        except IOError as e:\n            print(f\"Error writing JSON file: {e}\", file=os.sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\", file=os.sys.stderr)\n            return False\n\n    def set_cookies(self, request):\n        cookies_str = '; '.join(f\"{key}={value}\" for key, value in self.cookies.items())\n        request['cookies'] = cookies_str\n",
  "CSVProcessor": "import csv\nimport os\n\nclass CSVProcessor:\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        try:\n            with open(file_name, mode='r', newline='') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = [row for row in reader]\n            return title, data\n        except FileNotFoundError:\n            return [], []\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, mode='w', newline='') as file:\n                writer = csv.writer(file)\n                for row in data:\n                    writer.writerow(row)\n            return 1\n        except IOError:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        if not title or N >= len(title):\n            return 0\n\n        # Process the specified column\n        for row in data:\n            if N < len(row):\n                row[N] = row[N].upper()\n\n        # Combine title and processed data\n        new_data = [title] + data\n        processed_file_name = f\"{os.path.splitext(save_file_name)[0]}_process.csv\"\n        return self.write_csv(new_data, processed_file_name)\n\n# Example usage:\n# processor = CSVProcessor()\n# result = processor.process_csv_data(1, 'example.csv')\n# print(\"Processed successfully\" if result else \"Processing failed\")\n",
  "CurrencyConverter": "class CurrencyConverter:\n    def __init__(self):\n        self.rates = {\n            \"USD\": 1.0,\n            \"EUR\": 0.85,\n            \"GBP\": 0.72,\n            \"JPY\": 110.15,\n            \"CAD\": 1.23,\n            \"AUD\": 1.34,\n            \"CNY\": 6.40,\n        }\n        self.currency_order = [\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CNY\"]\n\n    def convert(self, amount, from_currency, to_currency):\n        if from_currency == to_currency:\n            return amount\n\n        if from_currency not in self.rates or to_currency not in self.rates:\n            raise ValueError(\"Unsupported currency\")\n\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n    def get_supported_currencies(self):\n        return self.currency_order\n\n    def add_currency_rate(self, currency, rate):\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        self.currency_order.append(currency)\n        return True\n\n    def update_currency_rate(self, currency, new_rate):\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return True\n",
  "DatabaseProcessor": "import sqlite3\n\nclass DatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def _open_database(self):\n        try:\n            return sqlite3.connect(self.database_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to open database: {e}\")\n\n    def create_table(self, table_name, key1='key1', key2='key2'):\n        db = self._open_database()\n        try:\n            create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n            db.execute(create_table_query)\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to create table: {e}\")\n        finally:\n            db.close()\n\n    def insert_into_database(self, table_name, data):\n        db = self._open_database()\n        try:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor = db.cursor()\n            for item in data:\n                cursor.execute(insert_query, (item['name'], int(item['age'])))\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to insert data: {e}\")\n        finally:\n            db.close()\n\n    def search_database(self, table_name, name):\n        db = self._open_database()\n        result = []\n        try:\n            query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n            cursor = db.cursor()\n            cursor.execute(query, (name,))\n            for row in cursor.fetchall():\n                result.append(list(row))\n        except sqlite3.Error as e:\n            print(f\"Failed to search database: {e}\")\n        finally:\n            db.close()\n        return result\n\n    def delete_from_database(self, table_name, name):\n        db = self._open_database()\n        try:\n            delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n            cursor = db.cursor()\n            cursor.execute(delete_query, (name,))\n            db.commit()\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to delete data: {e}\")\n        finally:\n            db.close()\n",
  "DataStatistics": "from collections import Counter\nimport statistics\n\nclass DataStatistics:\n    def mean(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        avg = sum(data) / len(data)\n        return round(avg, 2)\n\n    def median(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            med = (sorted_data[mid - 1] + sorted_data[mid]) / 2\n        else:\n            med = sorted_data[mid]\n        return round(med, 2)\n\n    def mode(self, data):\n        if not data:\n            raise ValueError(\"Data list is empty.\")\n        count_map = Counter(data)\n        max_count = max(count_map.values())\n        modes = [k for k, v in count_map.items() if v == max_count]\n        return modes\n",
  "DiscountStrategy": "class DiscountStrategy:\n    class PromoType:\n        FidelityPromo = 'fidelity'\n        BulkItemPromo = 'bulk_item'\n        LargeOrderPromo = 'large_order'\n        NoPromo = 'no_promo'\n\n    def __init__(self, customer, cart, promo=PromoType.NoPromo):\n        self.customer = customer\n        self.cart = cart\n        self.promo = promo\n\n    def total(self):\n        total = 0.0\n        for item in self.cart:\n            try:\n                quantity = item.get('quantity', 0)\n                price = item.get('price', 0)\n                total += quantity * price\n            except KeyError:\n                print(\"Missing 'quantity' or 'price' in cart item.\")\n        return total\n\n    def due(self):\n        return self.total() - self.promotion()\n\n    def promotion(self):\n        if self.promo == self.PromoType.FidelityPromo:\n            return self.fidelity_discount()\n        elif self.promo == self.PromoType.BulkItemPromo:\n            return self.bulk_item_discount()\n        elif self.promo == self.PromoType.LargeOrderPromo:\n            return self.large_order_discount()\n        else:\n            return 0.0\n\n    def fidelity_discount(self):\n        fidelity = self.customer.get('fidelity', 0)\n        if fidelity >= 1000.0:\n            return 0.05 * self.total()\n        return 0.0\n\n    def bulk_item_discount(self):\n        discount = 0.0\n        for item in self.cart:\n            try:\n                quantity = item.get('quantity', 0)\n                price = item.get('price', 0)\n                if quantity >= 20:\n                    discount += quantity * price * 0.1\n            except KeyError:\n                print(\"Missing 'quantity' or 'price' in cart item.\")\n        return discount\n\n    def large_order_discount(self):\n        num_items = len(self.cart)\n        if num_items >= 10:\n            return 0.07 * self.total()\n        return 0.0\n",
  "EmailClient": "import time\nfrom datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr, capacity):\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def get_current_time(self):\n        now = datetime.now()\n        return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": str(size),\n                \"time\": self.get_current_time(),\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        if not self.inbox:\n            return {}\n        for email in self.inbox:\n            if email[\"state\"] == \"unread\":\n                email[\"state\"] = \"read\"\n                return email\n        return {}\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return occupied_size + size > self.capacity\n\n    def get_occupied_size(self):\n        return sum(int(email[\"size\"]) for email in self.inbox)\n\n    def clear_inbox(self, size):\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            freed_space += int(self.inbox[0][\"size\"])\n            self.inbox.pop(0)\n",
  "ExcelProcessor": "import pandas as pd\nimport os\n\nclass ExcelProcessor:\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        try:\n            # Validate file name\n            if not os.path.isfile(file_name):\n                raise FileNotFoundError(f\"The file {file_name} does not exist.\")\n            \n            df = pd.read_excel(file_name, dtype=str)\n            data = df.values.tolist()\n            \n            # Convert numeric strings to integers\n            for i, row in enumerate(data):\n                for j, value in enumerate(row):\n                    if value.isdigit():\n                        data[i][j] = int(value)\n            \n            return data\n        except Exception as e:\n            print(f\"An error occurred while reading the file: {e}\")\n            return []\n\n    def write_excel(self, data, file_name):\n        try:\n            # Create DataFrame from data\n            df = pd.DataFrame(data)\n            # Write to Excel\n            df.to_excel(file_name, index=False, header=False)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing the file: {e}\")\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if not data or N >= len(data[0]):\n            return 0, \"\"\n\n        new_data = []\n        for row in data:\n            new_row = row.copy()\n            value = row[N]\n            if isinstance(value, str):\n                if not value[0].isdigit():\n                    new_value = value.upper()\n                else:\n                    new_value = value[0]\n            elif isinstance(value, int):\n                new_value = value\n            else:\n                continue\n            \n            new_row.append(new_value)\n            new_data.append(new_row)\n\n        base_name, ext = os.path.splitext(save_file_name)\n        new_file_name = f\"{base_name}_process{ext}\"\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name\n\n# Example usage:\n# processor = ExcelProcessor()\n# success, new_file_name = processor.process_excel_data(2, \"example.xlsx\")\n# print(f\"Success: {success}, New File Name: {new_file_name}\")\n",
  "FitnessTracker": "class FitnessTracker:\n    BMI_STD = {\n        \"male\": [20.0, 25.0],\n        \"female\": [19.0, 24.0]\n    }\n\n    def __init__(self, height, weight, age, sex):\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n\n    def get_bmi(self):\n        try:\n            return self.weight / (self.height ** 2)\n        except ZeroDivisionError:\n            print(\"Height cannot be zero.\")\n            return None\n\n    def condition_judge(self):\n        bmi = self.get_bmi()\n        if bmi is None:\n            return None\n        bmi_range = self.BMI_STD.get(self.sex, [18.5, 24.5])  # Default to a general range if sex is not recognized\n        if bmi > bmi_range[1]:\n            return 1\n        elif bmi < bmi_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        bmr = self._calculate_bmr()\n        if bmr is None:\n            return None\n        condition = self.condition_judge()\n        if condition == 1:\n            return bmr * 1.2  # Overweight\n        elif condition == -1:\n            return bmr * 1.6  # Underweight\n        else:\n            return bmr * 1.4  # Normal\n\n    def _calculate_bmr(self):\n        try:\n            if self.sex == \"male\":\n                return 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n            elif self.sex == \"female\":\n                return 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n            else:\n                print(\"Invalid sex input. Please enter 'male' or 'female'.\")\n                return None\n        except TypeError:\n            print(\"Invalid input types for height, weight, or age.\")\n            return None\n\n\n# Example usage:\n# tracker = FitnessTracker(1.75, 70, 30, \"male\")\n# print(\"BMI:\", tracker.get_bmi())\n# print(\"Condition:\", tracker.condition_judge())\n# print(\"Calorie Intake:\", tracker.calculate_calorie_intake())\n",
  "GomokuGame": "class GomokuGame:\n    def __init__(self, board_size):\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        if 0 <= row < self.board_size and 0 <= col < self.board_size:\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                self.current_player = 'O' if self.current_player == 'X' else 'X'\n                return True\n        return False\n\n    def check_winner(self):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def get_board(self):\n        return self.board\n\n    def _check_five_in_a_row(self, row, col, direction):\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5\n",
  "Hotel": "class Hotel:\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the hotel with a name and a dictionary of room types and their availability.\n        \n        :param name: Name of the hotel\n        :param rooms: Dictionary with room types as keys and number of available rooms as values\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Book rooms for a guest.\n        \n        :param room_type: Type of the room to book\n        :param room_number: Number of rooms to book\n        :param name: Name of the guest\n        :return: Success message or available room count if less than requested\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return \"False.\"\n\n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            if name in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] += room_number\n            else:\n                self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return str(self.available_rooms[room_type])\n        else:\n            return \"False.\"\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check in guests who have booked rooms.\n        \n        :param room_type: Type of the room to check in\n        :param room_number: Number of rooms to check in\n        :param name: Name of the guest\n        :return: True if check-in is successful, False otherwise\n        \"\"\"\n        if room_type not in self.booked_rooms:\n            return False\n\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                del self.booked_rooms[room_type][name]\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n            return True\n        return False\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out guests and make rooms available again.\n        \n        :param room_type: Type of the room to check out\n        :param room_number: Number of rooms to check out\n        \"\"\"\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms for a specific room type.\n        \n        :param room_type: Type of the room\n        :return: Number of available rooms\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n",
  "HRManagementSystem": "from typing import Dict, Optional, Union\n\nclass HRManagementSystem:\n    def __init__(self):\n        self.employees: Dict[int, Dict[str, Union[str, int]]] = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                \"name\": name,\n                \"position\": position,\n                \"department\": department,\n                \"salary\": salary\n            }\n            return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: Dict[str, Union[str, int]]) -> bool:\n        if employee_id not in self.employees:\n            return False\n\n        valid_keys = self.employees[employee_id].keys()\n        if not all(key in valid_keys for key in employee_info.keys()):\n            return False\n\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id: int) -> Optional[Dict[str, Union[str, int]]]:\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> Dict[int, Dict[str, Union[str, int]]]:\n        return {employee_id: {**employee_info, \"employee_ID\": employee_id} for employee_id, employee_info in self.employees.items()}\n\n# Example usage:\n# hr_system = HRManagementSystem()\n# hr_system.add_employee(1, \"John Doe\", \"Software Engineer\", \"IT\", 75000)\n# print(hr_system.list_employees())\n",
  "Interpolation": "class Interpolation:\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Perform linear interpolation on a set of 1D data points.\n\n        :param x: List of x-coordinates of known data points.\n        :param y: List of y-coordinates of known data points.\n        :param x_interp: List of x-coordinates where interpolation is needed.\n        :return: List of interpolated y-values corresponding to x_interp.\n        \"\"\"\n        if not x or not y or not x_interp or len(x) != len(y):\n            raise ValueError(\"Invalid input: x, y must be non-empty and of the same length.\")\n        \n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Perform bilinear interpolation on a set of 2D data points.\n\n        :param x: List of x-coordinates of known data points.\n        :param y: List of y-coordinates of known data points.\n        :param z: 2D list of z-values at each (x, y) coordinate.\n        :param x_interp: List of x-coordinates where interpolation is needed.\n        :param y_interp: List of y-coordinates where interpolation is needed.\n        :return: List of interpolated z-values corresponding to (x_interp, y_interp).\n        \"\"\"\n        if not x or not y or not z or not x_interp or not y_interp:\n            raise ValueError(\"Invalid input: x, y, z, x_interp, y_interp must be non-empty.\")\n        if len(x) != len(z) or any(len(row) != len(y) for row in z) or len(x_interp) != len(y_interp):\n            raise ValueError(\"Invalid input: dimensions of x, y, z, x_interp, y_interp do not match.\")\n\n        z_interp = []\n        for k in range(len(x_interp)):\n            xi, yi = x_interp[k], y_interp[k]\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j + 1]\n                            z10 = z[i + 1][j]\n                            z11 = z[i + 1][j + 1]\n                            zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j + 1] - yi) +\n                                  z01 * (x[i + 1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp\n",
  "JobMarketplace": "class Job:\n    def __init__(self, job_title, company, requirements):\n        self.job_title = job_title\n        self.company = company\n        self.requirements = requirements\n\n    def __eq__(self, other):\n        return (self.job_title == other.job_title and\n                self.company == other.company and\n                self.requirements == other.requirements)\n\n\nclass Resume:\n    def __init__(self, name, skills, experience):\n        self.name = name\n        self.skills = skills\n        self.experience = experience\n\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.skills == other.skills and\n                self.experience == other.experience)\n\n\nclass JobMarketplace:\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        self.job_listings.append(Job(job_title, company, requirements))\n\n    def remove_job(self, job):\n        self.job_listings = [j for j in self.job_listings if j != job]\n\n    def submit_resume(self, name, skills, experience):\n        self.resumes.append(Resume(name, skills, experience))\n\n    def withdraw_resume(self, resume):\n        self.resumes = [r for r in self.resumes if r != resume]\n\n    def search_jobs(self, criteria):\n        matching_jobs = []\n        for job_listing in self.job_listings:\n            if (criteria in job_listing.job_title or\n                    any(criteria in requirement for requirement in job_listing.requirements)):\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    def get_job_applicants(self, job):\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job.requirements):\n                applicants.append(resume)\n        return applicants\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        return all(skill in resume.skills for skill in requirements)\n",
  "JSONProcessor": "import json\nimport os\n\nclass JSONProcessor:\n    \n    def read_json(self, file_path):\n        \"\"\"\n        Reads a JSON file from the specified file path and stores its contents in a JSON object.\n        Returns 1 on success, 0 if the file cannot be opened, and -1 if the file is empty or contains invalid JSON data.\n        \"\"\"\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n                if not data:\n                    return -1  # File is empty or contains no data\n                return data, 1\n        except (FileNotFoundError, PermissionError):\n            return None, 0  # File cannot be opened\n        except json.JSONDecodeError:\n            return None, -1  # Invalid JSON data\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Writes a JSON object to the specified file path in a formatted manner with an indentation of 4 spaces.\n        Returns 1 on success, -1 if the file cannot be written.\n        \"\"\"\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, indent=4)\n            return 1\n        except (IOError, PermissionError):\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Processes a JSON file by removing a specified key from it and then writing the modified JSON back to the same file.\n        Returns 1 on success, 0 if the file cannot be processed or the key does not exist, and -1 if there is an error writing the file.\n        \"\"\"\n        data, result = self.read_json(file_path)\n\n        if result != 1:\n            return 0  # File cannot be read or is invalid\n\n        if remove_key in data:\n            del data[remove_key]\n            return self.write_json(data, file_path)\n        else:\n            return 0  # Key does not exist in the JSON data\n",
  "KappaCalculator": "import numpy as np\n\nclass KappaCalculator:\n    @staticmethod\n    def kappa(test_data, k):\n        data_mat = np.array(test_data)\n\n        P0 = np.trace(data_mat)\n\n        xsum = np.sum(data_mat, axis=1)\n        ysum = np.sum(data_mat, axis=0)\n        total_sum = np.sum(data_mat)\n\n        Pe = np.dot(ysum, xsum) / (total_sum * total_sum)\n        P0 /= total_sum\n\n        cohens_coefficient = (P0 - Pe) / (1 - Pe)\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(test_data, N, k, n):\n        data_mat = np.array(test_data)\n\n        total_sum = 0.0\n        P0 = 0.0\n\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                total_sum += data_mat[i, j]\n                temp += data_mat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n\n        P0 /= N\n\n        ysum = np.sum(data_mat, axis=0)\n        ysum = ysum / total_sum\n        ysum = ysum ** 2\n\n        Pe = np.sum(ysum)\n\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans\n\n# Example usage:\n# testData = [[1, 0], [0, 1], [1, 0]]\n# k = 2\n# print(KappaCalculator.kappa(testData, k))\n# testData = [[1, 0], [0, 1], [1, 0]]\n# N = 3\n# k = 2\n# n = 2\n# print(KappaCalculator.fleiss_kappa(testData, N, k, n))\n",
  "MahjongConnect": "import random\nfrom typing import List, Tuple, Set\n\nclass MahjongConnect:\n    def __init__(self, board_size: Tuple[int, int], icons: List[str]):\n        self.BOARD_SIZE = board_size\n        self.ICONS = icons\n        self.board = self.create_board()\n\n    def create_board(self) -> List[List[str]]:\n        new_board = [['' for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        for i in range(self.BOARD_SIZE[0]):\n            for j in range(self.BOARD_SIZE[1]):\n                new_board[i][j] = random.choice(self.ICONS)\n        return new_board\n\n    def is_valid_move(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within board boundaries\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and\n                0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        # Check if positions are not identical\n        if pos1 == pos2:\n            return False\n\n        # Check if icons at positions are the same\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a path between the positions\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:\n        visited: Set[Tuple[int, int]] = set()\n        stack: List[Tuple[int, int]] = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Explore adjacent cells\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + direction[0], y + direction[1]\n                if (0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1] and\n                        (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]):\n                    stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> None:\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self) -> bool:\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n",
  "Manacher": "class Manacher:\n    def __init__(self, input_string):\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        if (center - diff == -1) or (center + diff == len(string)) or (string[center - diff] != string[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        if not self.input_string:\n            return \"\"\n\n        max_length = 0\n        new_input_string = \"|\".join(self.input_string) + \"|\"\n        output_string = \"\"\n\n        for i in range(len(new_input_string)):\n            length = self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Extract the longest palindromic substring\n        start_index = (start - max_length) // 2\n        end_index = (start + max_length) // 2\n        output_string = self.input_string[start_index:end_index]\n\n        return output_string\n\n# Example usage:\n# manacher = Manacher(\"babad\")\n# print(manacher.palindromic_string())  # Output could be \"bab\" or \"aba\"\n",
  "MetricsCalculator": "class MetricsCalculator:\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Predicted and true labels must be of the same length.\")\n        \n        for predicted, true_label in zip(predicted_labels, true_labels):\n            if predicted == 1 and true_label == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true_label == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true_label == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true_label == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision_value = self.precision(predicted_labels, true_labels)\n        recall_value = self.recall(predicted_labels, true_labels)\n        if precision_value + recall_value == 0.0:\n            return 0.0\n        return 2.0 * precision_value * recall_value / (precision_value + recall_value)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n",
  "MetricsCalculator2": "from typing import List, Tuple\n\nclass MetricsCalculator:\n    @staticmethod\n    def mrr(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        sum_mrr = 0.0\n        individual_mrr = []\n\n        for vec, k in data:\n            if k <= 0 or not vec:\n                individual_mrr.append(0.0)\n            else:\n                mrr_value = MetricsCalculator._calculate_mrr(vec, k)\n                individual_mrr.append(mrr_value)\n                sum_mrr += mrr_value\n\n        average_mrr = sum_mrr / len(data) if data else 0.0\n        return average_mrr, individual_mrr\n\n    @staticmethod\n    def map(data: List[Tuple[List[int], int]]) -> Tuple[float, List[float]]:\n        if not data:\n            return 0.0, [0.0]\n\n        separate_result = []\n\n        for sub_list, total_num in data:\n            if total_num == 0:\n                separate_result.append(0.0)\n                continue\n\n            ap = MetricsCalculator._calculate_map(sub_list, total_num)\n            separate_result.append(ap)\n\n        mean_ap = sum(separate_result) / len(separate_result) if separate_result else 0.0\n        return mean_ap, separate_result\n\n    @staticmethod\n    def _calculate_mrr(vec: List[int], k: int) -> float:\n        try:\n            index_of_one = vec.index(1)\n            return 1.0 / (index_of_one + 1)\n        except ValueError:\n            return 0.0\n\n    @staticmethod\n    def _calculate_map(vec: List[int], k: int) -> float:\n        relevant_count = 0\n        precision_sum = 0.0\n\n        for i, value in enumerate(vec):\n            if value == 1:\n                relevant_count += 1\n                precision_sum += relevant_count / (i + 1)\n\n        return precision_sum / relevant_count if relevant_count > 0 else 0.0\n",
  "MovieBookingSystem": "from datetime import datetime, time\nfrom typing import List, Tuple, Dict\n\nclass MovieBookingSystem:\n    def __init__(self):\n        self.movies: List[Dict] = []\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        try:\n            start_tm = self.parse_time(start_time)\n            end_tm = self.parse_time(end_time)\n        except ValueError as e:\n            raise ValueError(f\"Time parsing error: {e}\")\n\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': start_tm,\n            'end_time': end_tm,\n            'seats': [[0 for _ in range(n)] for _ in range(n)]\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name: str, seats_to_book: List[Tuple[int, int]]) -> str:\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    row, col = seat\n                    if 0 <= row < len(movie['seats']) and 0 <= col < len(movie['seats'][row]):\n                        if movie['seats'][row][col] == 0:\n                            movie['seats'][row][col] = 1\n                        else:\n                            return \"Booking failed.\"\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time: str, end_time: str) -> List[str]:\n        try:\n            start_tm = self.parse_time(start_time)\n            end_tm = self.parse_time(end_time)\n        except ValueError as e:\n            raise ValueError(f\"Time parsing error: {e}\")\n\n        available_movies = []\n        for movie in self.movies:\n            if self.is_time_in_range(start_tm, end_tm, movie['start_time']) and \\\n               self.is_time_in_range(start_tm, end_tm, movie['end_time']):\n                available_movies.append(movie['name'])\n        return available_movies\n\n    @staticmethod\n    def parse_time(time_str: str) -> time:\n        try:\n            return datetime.strptime(time_str, \"%H:%M\").time()\n        except ValueError:\n            raise ValueError(\"Failed to parse time\")\n\n    @staticmethod\n    def is_time_in_range(start: time, end: time, check: time) -> bool:\n        start_seconds = start.hour * 3600 + start.minute * 60\n        end_seconds = end.hour * 3600 + end.minute * 60\n        check_seconds = check.hour * 3600 + check.minute * 60\n        return start_seconds <= check_seconds <= end_seconds\n",
  "MusicPlayer": "import random\nfrom typing import List\n\nclass MusicPlayer:\n    def __init__(self):\n        self.playlist: List[str] = []\n        self.current_song: str = \"\"\n        self.volume: int = 50\n\n    def add_song(self, song: str) -> None:\n        \"\"\"Add a song to the playlist.\"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song: str) -> None:\n        \"\"\"Remove a song from the playlist and stop playing it if it's the current song.\"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self) -> str:\n        \"\"\"Play the first song in the playlist or continue playing the current song.\"\"\"\n        if self.playlist:\n            if self.current_song and self.current_song in self.playlist:\n                return self.current_song\n            else:\n                self.current_song = self.playlist[0]\n                return self.current_song\n        return \"\"\n\n    def stop(self) -> bool:\n        \"\"\"Stop playing the current song.\"\"\"\n        if self.current_song:\n            self.current_song = \"\"\n            return True\n        return False\n\n    def switch_song(self) -> bool:\n        \"\"\"Switch to the next song in the playlist.\"\"\"\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n        return False\n\n    def previous_song(self) -> bool:\n        \"\"\"Switch to the previous song in the playlist.\"\"\"\n        if self.current_song and self.current_song in self.playlist:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n        return False\n\n    def set_volume(self, volume: int) -> bool:\n        \"\"\"Set the volume if it's within the valid range.\"\"\"\n        if self._is_valid_volume(volume):\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self) -> bool:\n        \"\"\"Shuffle the playlist.\"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n\n    def _is_valid_volume(self, volume: int) -> bool:\n        \"\"\"Check if the volume is within the valid range.\"\"\"\n        return 0 <= volume <= 100\n",
  "NLPDataProcessor": "class NLPDataProcessor:\n    def __init__(self):\n        pass\n\n    def construct_stop_word_list(self):\n        \"\"\"Constructs a predefined list of stop words.\"\"\"\n        return [\"a\", \"an\", \"the\"]\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Removes stop words from a given list of strings.\n\n        :param string_list: List of strings to process.\n        :param stop_word_list: List of stop words to remove.\n        :return: A list of lists, where each sublist contains words from the corresponding string in string_list with stop words removed.\n        \"\"\"\n        answer = []\n\n        for string in string_list:\n            string_split = [word for word in string.split() if word not in stop_word_list]\n            answer.append(string_split)\n\n        return answer\n\n    def process(self, string_list):\n        \"\"\"\n        Processes a list of strings by first constructing a stop word list and then removing these stop words from each string in the list.\n\n        :param string_list: List of strings to process.\n        :return: A list of lists, where each sublist contains words from the corresponding string in string_list with stop words removed.\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n",
  "NLPDataProcessor2": "import re\nfrom collections import defaultdict, Counter, OrderedDict\n\nclass NLPDataProcessor:\n    def __init__(self):\n        self.first_appear = {}\n\n    def to_lowercase(self, string):\n        return string.lower()\n\n    def remove_non_alpha(self, string):\n        return re.sub(r'[^a-z\\s]', '', string)\n\n    def process_data(self, string_list):\n        words_list = []\n        for string in string_list:\n            processed_string = self.remove_non_alpha(self.to_lowercase(string))\n            words = [word for word in processed_string.split() if word]\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = defaultdict(int)\n        self.first_appear.clear()\n        js = 0\n        for words in words_list:\n            for word in words:\n                if word not in word_frequency:\n                    js += 1\n                    self.first_appear[word] = js\n                word_frequency[word] += 1\n\n        # Sort by frequency, then by first appearance\n        sorted_word_frequency = sorted(\n            word_frequency.items(),\n            key=lambda x: (-x[1], self.first_appear[x[0]])\n        )\n\n        # Get the top 5 words\n        top_5_word_frequency = OrderedDict(sorted_word_frequency[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n\n# Example usage:\n# processor = NLPDataProcessor()\n# result = processor.process([\"This is a test.\", \"Another test with more words.\"])\n# print(result)\n",
  "NumberConverter": "class NumberConverter:\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        if decimal_num == 0:\n            return \"0\"\n        binary_num = bin(decimal_num)[2:]  # Convert to binary and remove the '0b' prefix\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        return oct(decimal_num)[2:]  # Convert to octal and remove the '0o' prefix\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        return hex(decimal_num)[2:]  # Convert to hexadecimal and remove the '0x' prefix\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        return int(hex_num, 16)\n",
  "NumberWordFormatter": "class NumberWordFormatter:\n    def __init__(self):\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\", \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, x):\n        if x is None:\n            return self.format(None)\n        elif isinstance(x, int):\n            return self.format(str(x))\n        elif isinstance(x, float):\n            return self.format(str(x))\n        elif isinstance(x, str):\n            return self._format_string(x)\n        else:\n            return \"\"\n\n    def _format_string(self, x):\n        lstr = x.split('.')[0]\n        rstr = x.split('.')[1] if '.' in x else \"\"\n        lstr = lstr[::-1]\n\n        if len(lstr) % 3 == 1:\n            lstr += \"00\"\n        elif len(lstr) % 3 == 2:\n            lstr += \"0\"\n\n        a = [\"\"] * 5\n        lm = \"\"\n\n        for i in range(len(lstr) // 3):\n            a[i] = lstr[3 * i + 2] + lstr[3 * i + 1] + lstr[3 * i]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = \" AND CENTS \" + self.trans_two(rstr) + \" \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            lm = lm.rstrip()\n            return lm + xs + \"ONLY\"\n\n    def trans_two(self, s):\n        s = s.zfill(2)\n        if s[0] == '0':\n            return self.NUMBER[int(s[1])]\n        elif s[0] == '1':\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == '0':\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[1])]\n\n    def trans_three(self, s):\n        if s[0] == '0':\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return self.NUMBER[int(s[0])] + \" HUNDRED\"\n        else:\n            return self.NUMBER[int(s[0])] + \" HUNDRED AND \" + self.trans_two(s[1:])\n\n    def parse_more(self, i):\n        return self.NUMBER_MORE[i]\n",
  "NumericEntityUnescaper": "class NumericEntityUnescaper:\n    def __init__(self):\n        pass\n\n    def replace(self, input_string: str) -> str:\n        output = []\n        pos = 0\n        length = len(input_string)\n        \n        if not input_string:\n            return \"\"\n        \n        while pos < length - 2:\n            if input_string[pos] == '&' and input_string[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n\n                if start < length and input_string[start] in ('x', 'X'):\n                    start += 1\n                    is_hex = True\n\n                if start == length:\n                    break\n\n                end = start\n                while end < length and self._is_hex_char(input_string[end]):\n                    end += 1\n\n                if end < length and input_string[end] == ';':\n                    try:\n                        number_str = input_string[start:end]\n                        if is_hex:\n                            entity_value = int(number_str, 16)\n                        else:\n                            entity_value = int(number_str)\n\n                        output.append(chr(entity_value))\n                        pos = end + 1\n                        continue\n                    except ValueError:\n                        break\n\n            output.append(input_string[pos])\n            pos += 1\n\n        return ''.join(output)\n\n    @staticmethod\n    def _is_hex_char(c: str) -> bool:\n        return c.isdigit() or ('a' <= c.lower() <= 'f')\n",
  "Order": "class Dish:\n    def __init__(self, name, price, count):\n        self.name = name\n        self.price = price\n        self.count = count\n\n\nclass Order:\n    def __init__(self):\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish, count):\n        for menu_dish in self.menu:\n            if dish.name == menu_dish.name:\n                if menu_dish.count < count:\n                    return False\n                else:\n                    menu_dish.count -= count\n                    self.selected_dishes.append(Dish(dish.name, dish.price, count))\n                    return True\n        return False\n\n    def calculate_total(self):\n        total = 0\n        for dish in self.selected_dishes:\n            discount_factor = self.sales.get(dish.name, 1.0)\n            total += dish.price * dish.count * discount_factor\n        return total\n\n    def checkout(self):\n        if not self.selected_dishes:\n            return 0\n        total = self.calculate_total()\n        self.selected_dishes.clear()\n        return total\n",
  "PageUtil": "from typing import List, Dict, Union\n\nclass PageUtil:\n    def __init__(self, data: List[int], page_size: int):\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + self.page_size - 1) // self.page_size\n\n    def get_page(self, page_number: int) -> List[int]:\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number: int) -> Dict[str, Union[int, List[int], bool]]:\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        return page_info\n\n    def search(self, keyword: str) -> Dict[str, Union[str, int, List[int]]]:\n        results = [item for item in self.data if keyword in str(item)]\n\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        return search_info\n",
  "PersonRequest": "class PersonRequest:\n    def __init__(self, name: str, sex: str, phone_number: str):\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        if not name or len(name) > 33:\n            return \"\"\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        if sex not in {\"Man\", \"Woman\", \"UGM\"}:\n            return \"\"\n        return sex\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        if not phone_number or len(phone_number) != 11 or not self._is_all_digits(phone_number):\n            return \"\"\n        return phone_number\n\n    @staticmethod\n    def _is_all_digits(s: str) -> bool:\n        return s.isdigit()\n",
  "RPGCharacter": "class RPGCharacter:\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        while amount > 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n\n    def is_alive(self):\n        return self.hp > 0\n\n    def get_hp(self):\n        return self.hp\n\n    def get_exp(self):\n        return self.exp\n\n    def get_attack_power(self):\n        return self.attack_power\n\n    def get_defense(self):\n        return self.defense\n\n    def get_level(self):\n        return self.level\n\n    def set_hp(self, x):\n        self.hp = x\n",
  "Server": "class Server:\n    def __init__(self):\n        self.white_list = set()\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"Add an address to the whitelist if it's not already present.\"\"\"\n        if addr in self.white_list:\n            return list(self.white_list)\n        else:\n            self.white_list.add(addr)\n            return list(self.white_list)\n\n    def del_white_list(self, addr):\n        \"\"\"Remove an address from the whitelist if it exists.\"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return list(self.white_list)\n        else:\n            return list(self.white_list)\n\n    def recv(self, info):\n        \"\"\"\n        Receive data if it contains 'addr' and 'content' keys and the address is whitelisted.\n        Returns 1 if successful, 0 if address is not whitelisted, and -1 if data is invalid.\n        \"\"\"\n        if 'addr' not in info or 'content' not in info:\n            return -1\n        addr = int(info['addr'])\n        content = info['content']\n\n        if addr not in self.white_list:\n            return 0\n        else:\n            self.receive_struct = {'addr': str(addr), 'content': content}\n            return 1\n\n    def send(self, info):\n        \"\"\"\n        Send data if it contains 'addr' and 'content' keys.\n        Returns an error message if data is invalid.\n        \"\"\"\n        if 'addr' not in info or 'content' not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {'addr': info['addr'], 'content': info['content']}\n        return \"\"\n\n    def show(self, type):\n        \"\"\"\n        Display either the last sent or received data based on the type specified.\n        Returns an empty dictionary if the type is neither 'send' nor 'receive'.\n        \"\"\"\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return {}\n",
  "ShoppingCart": "from threading import Lock\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.lock = Lock()\n\n    def add_item(self, item: str, price: float, quantity: int = 1):\n        with self.lock:\n            if price < 0 or quantity < 0:\n                raise ValueError(\"Price and quantity must be non-negative.\")\n            if item in self.items:\n                # Update the price and quantity\n                self.items[item] = (price, self.items[item][1] + quantity)\n            else:\n                self.items[item] = (price, quantity)\n\n    def remove_item(self, item: str, quantity: int = 1):\n        with self.lock:\n            if quantity < 0:\n                raise ValueError(\"Quantity must be non-negative.\")\n            if item in self.items:\n                current_quantity = self.items[item][1]\n                new_quantity = current_quantity - quantity\n                if new_quantity > 0:\n                    self.items[item] = (self.items[item][0], new_quantity)\n                else:\n                    del self.items[item]\n\n    def view_items(self) -> dict:\n        with self.lock:\n            return self.items.copy()\n\n    def total_price(self) -> float:\n        with self.lock:\n            total = 0.0\n            for price, quantity in self.items.values():\n                total += price * quantity\n            return total\n",
  "SignInSystem": "class SignInSystem:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username: str) -> bool:\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username: str) -> bool:\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        return all(signed_in for signed_in in self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        return [username for username, signed_in in self.users.items() if not signed_in]\n",
  "Snake": "import random\n\nclass Snake:\n    def __init__(self, screen_width, screen_height, block_size, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = screen_width\n        self.SCREEN_HEIGHT = screen_height\n        self.BLOCK_SIZE = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        cur = self.positions[0]\n        x, y = direction\n\n        new_pos = (\n            (cur[0] + x * self.BLOCK_SIZE) % self.SCREEN_WIDTH,\n            (cur[1] + y * self.BLOCK_SIZE) % self.SCREEN_HEIGHT\n        )\n\n        if new_pos == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new_pos in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_pos)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while True:\n            self.food_position = (\n                random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE,\n                random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE\n            )\n            if self.food_position not in self.positions:\n                break\n\n    def reset(self):\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n\n    def get_length(self):\n        return self.length\n\n    def get_positions(self):\n        return self.positions\n\n    def get_score(self):\n        return self.score\n\n    def get_food_position(self):\n        return self.food_position\n\n    def get_screen_width(self):\n        return self.SCREEN_WIDTH\n\n    def get_screen_height(self):\n        return self.SCREEN_HEIGHT\n\n    def get_block_size(self):\n        return self.BLOCK_SIZE\n",
  "SQLQueryBuilder": "class SQLQueryBuilder:\n    @staticmethod\n    def select(table, columns=None, where=None):\n        if columns is None:\n            columns = [\"*\"]\n        if where is None:\n            where = []\n\n        query = \"SELECT \"\n        if columns == [\"*\"]:\n            query += \"*\"\n        else:\n            query += \", \".join(columns)\n        \n        query += f\" FROM {table}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def insert(table, data):\n        if not data:\n            raise ValueError(\"Data must be provided for an INSERT query.\")\n        \n        columns = \", \".join(item[0] for item in data)\n        values = \", \".join(f\"'{item[1]}'\" for item in data)\n        \n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n        return query\n\n    @staticmethod\n    def delete_(table, where=None):\n        if where is None:\n            where = []\n        \n        query = f\"DELETE FROM {table}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        if not data:\n            raise ValueError(\"Data must be provided for an UPDATE query.\")\n        if where is None:\n            where = []\n        \n        set_clause = \", \".join(f\"{key}='{value}'\" for key, value in data)\n        query = f\"UPDATE {table} SET {set_clause}\"\n        \n        if where:\n            query += \" WHERE \"\n            query += \" AND \".join(f\"{key}='{value}'\" for key, value in where)\n        \n        return query\n",
  "StockPortfolioTracker": "class Stock:\n    def __init__(self, name, price, quantity):\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n\n    def __eq__(self, other):\n        return self.name == other.name and self.price == other.price and self.quantity == other.quantity\n\n\nclass StockSummary:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __eq__(self, other):\n        return self.name == other.name and self.value == other.value\n\n\nclass StockPortfolioTracker:\n    def __init__(self, cash_balance):\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        for pf in self.portfolio:\n            if pf.name == stock.name:\n                pf.quantity += stock.quantity\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        for i, pf in enumerate(self.portfolio):\n            if pf.name == stock.name and pf.quantity >= stock.quantity:\n                pf.quantity -= stock.quantity\n                if pf.quantity == 0:\n                    del self.portfolio[i]\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        if stock.price * stock.quantity > self.cash_balance:\n            return False\n        else:\n            self.add_stock(stock)\n            self.cash_balance -= stock.price * stock.quantity\n            return True\n\n    def sell_stock(self, stock):\n        if not self.remove_stock(stock):\n            return False\n        self.cash_balance += stock.price * stock.quantity\n        return True\n\n    def calculate_portfolio_value(self):\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock.price * stock.quantity\n        return total_value\n\n    def get_portfolio_summary(self):\n        summary = [StockSummary(stock.name, self.get_stock_value(stock)) for stock in self.portfolio]\n        return self.calculate_portfolio_value(), summary\n\n    def get_stock_value(self, stock):\n        return stock.price * stock.quantity\n\n    def get_portfolio(self):\n        return self.portfolio\n\n    def get_cash_balance(self):\n        return self.cash_balance\n\n    def set_portfolio(self, portfolio):\n        self.portfolio = portfolio\n",
  "StudentDatabaseProcessor": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        create_table_query = \"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY,\n                name TEXT,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        \"\"\"\n        self.execute_query(create_table_query, [])\n\n    def insert_student(self, student_data):\n        insert_query = \"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        \"\"\"\n        params = [\n            student_data['name'],\n            student_data['age'],\n            student_data['gender'],\n            student_data['grade']\n        ]\n        self.execute_query(insert_query, params)\n\n    def search_student_by_name(self, name):\n        select_query = \"\"\"\n            SELECT * FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        results = self.query_result(select_query, params)\n\n        students = []\n        for row in results:\n            student = {\n                'id': row[0],\n                'name': row[1],\n                'age': row[2],\n                'gender': row[3],\n                'grade': row[4]\n            }\n            students.append(student)\n\n        return students\n\n    def delete_student_by_name(self, name):\n        delete_query = \"\"\"\n            DELETE FROM students WHERE name = ?\n        \"\"\"\n        params = [name]\n        self.execute_query(delete_query, params)\n\n    def execute_query(self, query, params):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(query, params)\n        conn.commit()\n        cursor.close()\n        conn.close()\n\n    def query_result(self, query, params):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(query, params)\n        results = cursor.fetchall()\n        cursor.close()\n        conn.close()\n        return results\n",
  "TextFileProcessor": "import json\nimport re\n\nclass TextFileProcessor:\n    def __init__(self, filename):\n        self._filename = filename\n\n    def read_file_as_json(self):\n        with open(self._filename, 'r') as file:\n            return json.load(file)\n\n    def read_file(self):\n        with open(self._filename, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self._filename, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        # Using regular expression to filter out non-alphabetic characters\n        result = re.sub(r'[^a-zA-Z]', '', content)\n        self.write_file(result)\n        return result\n",
  "Thermostat": "class Thermostat:\n    def __init__(self, current_temperature, target_temperature, mode):\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n        self.auto_set_mode()\n\n    def get_target_temperature(self):\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        self.target_temperature = temperature\n        self.auto_set_mode()\n\n    def get_mode(self):\n        return self.mode\n\n    def set_mode(self, new_mode):\n        if new_mode in [\"heat\", \"cool\"]:\n            self.mode = new_mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        if self.current_temperature < self.target_temperature:\n            self.mode = \"heat\"\n        else:\n            self.mode = \"cool\"\n\n    def auto_check_conflict(self):\n        if self.current_temperature > self.target_temperature:\n            if self.mode == \"cool\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == \"heat\":\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == \"heat\":\n            while self.current_temperature < self.target_temperature:\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while self.current_temperature > self.target_temperature:\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time\n",
  "TimeUtils": "from datetime import datetime, timedelta\nimport time\n\nclass TimeUtils:\n    def __init__(self):\n        self.datetime = datetime.now()\n\n    def get_current_time(self) -> str:\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self) -> str:\n        return self.datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds: int) -> str:\n        self.datetime += timedelta(seconds=seconds)\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, str_time: str) -> time.struct_time:\n        return time.strptime(str_time, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime_obj: time.struct_time) -> str:\n        return time.strftime(\"%Y-%m-%d %H:%M:%S\", datetime_obj)\n\n    def get_minutes(self, string_time1: str, string_time2: str) -> int:\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        time_t1 = time.mktime(time1)\n        time_t2 = time.mktime(time2)\n        return int((time_t2 - time_t1) / 60)\n\n    def get_format_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        dt = datetime(year, month, day, hour, minute, second)\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
  "TwentyFourPointGame": "import random\nimport re\nfrom collections import defaultdict\nfrom operator import add, sub, mul, truediv, pow\n\nclass TwentyFourPointGame:\n    def __init__(self):\n        self.nums = []\n        self.generate_cards()\n\n    def get_my_cards(self):\n        self.generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == \"pass\":\n            return self.get_my_cards()\n\n        # Count digits in the expression\n        statistic = defaultdict(int)\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[int(c)] += 1\n\n        # Check if all digits used are from the generated set and not reused more than allowed\n        nums_used = statistic.copy()\n        for num in self.nums:\n            if nums_used[num] > 0:\n                nums_used[num] -= 1\n            else:\n                return []\n\n        if all(value == 0 for value in nums_used.values()):\n            if self.evaluate_expression(expression):\n                return [1]\n            else:\n                return []\n        else:\n            return []\n\n    def evaluate_expression(self, expression):\n        try:\n            if not re.match(r'^[\\d+\\-*/^(). ]+$', expression):\n                raise ValueError(\"Invalid characters in expression\")\n\n            calculator = Calculator()\n            result = calculator.calculate(expression)\n\n            return abs(result - 24.0) < 1e-6  # Allowing for floating-point precision issues\n        except Exception:\n            return False\n\n    def set_nums(self, now):\n        self.nums = now\n\n    def generate_cards(self):\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n\nclass Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': add,\n            '-': sub,\n            '*': mul,\n            '/': truediv,\n            '^': pow\n        }\n\n    def calculate(self, expression):\n        if not expression:\n            return 0.0\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for ch in expression:\n            if ch.isdigit() or ch == '.':\n                num_buffer += ch\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if ch in self.operators:\n                    while (operator_stack and operator_stack[-1] != '(' and\n                           self.precedence(operator_stack[-1]) >= self.precedence(ch)):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(ch)\n                elif ch == '(':\n                    operator_stack.append(ch)\n                elif ch == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else 0.0\n\n    def precedence(self, op):\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(op, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        op = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[op](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n",
  "URLHandler": "from urllib.parse import urlparse, parse_qs, unquote\n\nclass URLHandler:\n    def __init__(self, url: str):\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self) -> str:\n        return self.parsed_url.scheme\n\n    def get_host(self) -> str:\n        return self.parsed_url.netloc\n\n    def get_path(self) -> str:\n        return self.parsed_url.path\n\n    def get_query_params(self) -> dict:\n        # Using parse_qs to handle URL-encoded characters\n        query_params = parse_qs(self.parsed_url.query)\n        # Convert lists to single values if there's only one value\n        return {k: v[0] if len(v) == 1 else v for k, v in query_params.items()}\n\n    def get_fragment(self) -> str:\n        return self.parsed_url.fragment\n\n# Example usage:\n# handler = URLHandler(\"https://example.com/path?param1=value1&param2=value2#fragment\")\n# print(handler.get_scheme())  # Output: https\n# print(handler.get_host())    # Output: example.com\n# print(handler.get_path())    # Output: /path\n# print(handler.get_query_params())  # Output: {'param1': 'value1', 'param2': 'value2'}\n# print(handler.get_fragment())  # Output: fragment\n",
  "UrlPath": "import urllib.parse\n\nclass UrlPath:\n    def __init__(self):\n        self.segments = []\n        self._with_end_tag = False\n\n    def add(self, segment: str):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path: str, charset: str):\n        if not path:\n            return\n\n        if path.endswith('/'):\n            self._with_end_tag = True\n\n        fixed_path = self.fix_path(path)\n        if fixed_path:\n            for segment in fixed_path.split('/'):\n                # Decode percent-encoded characters\n                decoded_seg = urllib.parse.unquote(segment)\n                self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path: str) -> str:\n        if not path:\n            return \"\"\n\n        segment_str = path\n        if segment_str.startswith('/'):\n            segment_str = segment_str[1:]\n        if segment_str.endswith('/'):\n            segment_str = segment_str[:-1]\n        return segment_str\n\n    def get_segments(self) -> list:\n        return self.segments\n\n    def with_end_tag(self) -> bool:\n        return self._with_end_tag\n",
  "UserLoginDB": "import sqlite3\nfrom threading import Lock\n\nclass UserLoginDB:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connection = None\n        self.stmt = None\n        self.lock = Lock()\n        self._open_connection()\n        self.create_table()\n\n    def __del__(self):\n        self.finalize_statement()\n        self.close_connection()\n\n    def _open_connection(self):\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Cannot open database: {e}\")\n\n    def close_connection(self):\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n\n    def prepare_statement(self, query):\n        self.finalize_statement()\n        try:\n            self.stmt = self.connection.prepare(query)\n        except sqlite3.Error as e:\n            raise RuntimeError(f\"Failed to prepare statement: {e}\")\n\n    def finalize_statement(self):\n        if self.stmt:\n            self.stmt.close()\n            self.stmt = None\n\n    def insert_user(self, username, password):\n        with self.lock:\n            try:\n                cursor = self.connection.cursor()\n                cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to insert user: {e}\")\n\n    def search_user_by_username(self, username):\n        with self.lock:\n            try:\n                cursor = self.connection.cursor()\n                cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n                result = cursor.fetchone()\n                return result if result else None\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to search user: {e}\")\n\n    def delete_user_by_username(self, username):\n        with self.lock:\n            try:\n                cursor = self.connection.cursor()\n                cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Failed to delete user: {e}\")\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        return user is not None and user[1] == password\n\n    def create_table(self):\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT,\n            password TEXT\n        )\n        \"\"\"\n        with self.lock:\n            try:\n                cursor = self.connection.cursor()\n                cursor.execute(create_table_query)\n                self.connection.commit()\n            except sqlite3.Error as e:\n                raise RuntimeError(f\"Cannot create table: {e}\")\n",
  "VectorUtil": "import math\nfrom typing import List, Dict, Tuple\n\nclass VectorUtil:\n    @staticmethod\n    def similarity(vector_1: Tuple[float], vector_2: Tuple[float]) -> float:\n        norm_vec1 = VectorUtil.normalize(vector_1)\n        norm_vec2 = VectorUtil.normalize(vector_2)\n        dot_product = sum(a * b for a, b in zip(norm_vec1, norm_vec2))\n        return dot_product\n\n    @staticmethod\n    def cosine_similarities(vector_1: Tuple[float], vectors_all: List[Tuple[float]]) -> List[float]:\n        norm_vec1 = VectorUtil.norm(vector_1)\n        similarities = []\n        for vec in vectors_all:\n            norm_vec_all = VectorUtil.norm(vec)\n            if norm_vec_all == 0.0:\n                similarities.append(0.0)\n                continue\n            dot_product = sum(a * b for a, b in zip(vec, vector_1))\n            similarity = dot_product / (norm_vec1 * norm_vec_all)\n            similarities.append(similarity)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1: List[Tuple[float]], vector_list_2: List[Tuple[float]]) -> float:\n        if not vector_list_1 or not vector_list_2:\n            raise ValueError(\"At least one of the lists is empty.\")\n        \n        n = len(vector_list_1[0])\n        mean_vec1 = [sum(vec[i] for vec in vector_list_1) / len(vector_list_1) for i in range(n)]\n        mean_vec2 = [sum(vec[i] for vec in vector_list_2) / len(vector_list_2) for i in range(n)]\n\n        return VectorUtil.similarity(tuple(mean_vec1), tuple(mean_vec2))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: Dict[str, float]) -> Dict[str, float]:\n        result = {}\n        for key, count in number_dict.items():\n            idf_value = math.log((total_num + 1.0) / (count + 1.0))\n            result[key] = idf_value\n        return result\n\n    @staticmethod\n    def norm(vec: Tuple[float]) -> float:\n        return math.sqrt(sum(val * val for val in vec))\n\n    @staticmethod\n    def normalize(vec: Tuple[float]) -> Tuple[float]:\n        vec_norm = VectorUtil.norm(vec)\n        if vec_norm == 0.0:\n            return tuple(0.0 for _ in vec)\n        return tuple(val / vec_norm for val in vec)\n",
  "Warehouse": "class Warehouse:\n    def __init__(self):\n        self.inventory_ = {}\n        self.orders_ = {}\n\n    def add_product(self, product_id, name, quantity):\n        if product_id not in self.inventory_:\n            self.inventory_[product_id] = {\"name\": name, \"quantity\": quantity}\n        else:\n            self.inventory_[product_id][\"quantity\"] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        if product_id in self.inventory_:\n            self.inventory_[product_id][\"quantity\"] += quantity\n\n    def get_product_quantity(self, product_id):\n        return self.inventory_.get(product_id, {}).get(\"quantity\", 0)\n\n    def create_order(self, order_id, product_id, quantity):\n        available_quantity = self.get_product_quantity(product_id)\n        if available_quantity >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders_[order_id] = {\n                \"product_id\": product_id,\n                \"quantity\": quantity,\n                \"status\": \"Shipped\"\n            }\n            return True\n        return False\n\n    def change_order_status(self, order_id, status):\n        if order_id in self.orders_:\n            self.orders_[order_id][\"status\"] = status\n            return True\n        return False\n\n    def track_order(self, order_id):\n        return self.orders_.get(order_id, {}).get(\"status\", \"\")\n\n    def orders(self):\n        return self.orders_\n\n    def inventory(self):\n        return self.inventory_\n",
  "WeatherSystem": "class WeatherInfo:\n    def __init__(self, weather, temperature, temperature_units):\n        self.weather = weather\n        self.temperature = temperature\n        self.temperature_units = temperature_units\n\n\nclass WeatherSystem:\n    def __init__(self, city):\n        self.city = city\n        self.temperature = 0.0\n        self.weather = \"\"\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units=\"celsius\"):\n        self.weather_list = weather_list\n        weather_info = self.weather_list.get(self.city)\n        if not weather_info:\n            return 0.0, \"\"\n\n        self.temperature = weather_info.temperature\n        self.weather = weather_info.weather\n\n        if weather_info.temperature_units != tmp_units:\n            if tmp_units == \"celsius\":\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == \"fahrenheit\":\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        self.city = city\n\n    def set_temperature(self, temperature):\n        self.temperature = temperature\n\n    def celsius_to_fahrenheit(self):\n        return (self.temperature * 9 / 5) + 32\n\n    def fahrenheit_to_celsius(self):\n        return (self.temperature - 32) * 5 / 9\n\n    def get_city(self):\n        return self.city\n",
  "Words2Numbers": "import re\nfrom collections import defaultdict\n\nclass Words2Numbers:\n    def __init__(self):\n        self.units = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                      \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\",\n                      \"eighteen\", \"nineteen\"]\n        \n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        \n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n        \n        self.numwords = defaultdict(lambda: (1, 0))\n        for idx, unit in enumerate(self.units):\n            self.numwords[unit] = (1, idx)\n        for idx, ten in enumerate(self.tens):\n            self.numwords[ten] = (1, idx * 10)\n        for idx, scale in enumerate(self.scales):\n            self.numwords[scale] = (10 ** (idx * 3), 0)\n        self.numwords[\"hundred\"] = (100, 0)\n        \n        self.ordinal_words = {\"first\": 1, \"second\": 2, \"third\": 3, \"fifth\": 5, \"eighth\": 8,\n                             \"ninth\": 9, \"twelfth\": 12}\n        self.ordinal_endings = [(\"ieth\", \"y\"), (\"th\", \"\")]\n\n    def text2int(self, textnum):\n        text = re.sub(r'-', ' ', textnum.lower())\n        current = 0\n        result = 0\n        curstring = \"\"\n\n        for word in text.split():\n            if word in self.ordinal_words:\n                scale = 1\n                increment = self.ordinal_words[word]\n                current = current * scale + increment\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word in self.numwords:\n                    scale, increment = self.numwords[word]\n                    if scale == 1:\n                        current += increment\n                    else:\n                        current *= scale\n                        result += current\n                        current = 0\n                else:\n                    if current > 0:\n                        result += current\n                        current = 0\n                    curstring += word + \" \"\n\n        if current > 0:\n            result += current\n\n        curstring += str(result)\n        return curstring\n\n    def is_valid_input(self, textnum):\n        text = re.sub(r'-', ' ', textnum.lower())\n        for word in text.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = word[:-len(ending)] + replacement\n                        break\n\n                if word not in self.numwords:\n                    return False\n        return True\n"
}
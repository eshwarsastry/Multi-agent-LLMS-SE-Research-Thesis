{
  "AccessGatewayFilter": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <sstream> \n\n#include <string>\n#include <unordered_map>\n\nstruct User {\n    std::string name;\n    int level;\n    std::string address;\n};\n\nstruct Authorization {\n    User user;\n    std::string jwt;\n};\n\nstruct Request {\n    std::string path;\n    std::string method;\n    Authorization auth;\n};\n\nclass AccessGatewayFilter {\npublic:\n    AccessGatewayFilter() {}\n    bool filter(const Request& request);\n    bool is_start_with(const std::string& request_uri);\n    Authorization get_jwt_user(const Request& request);\n    void set_current_user_info_and_log(const User& user);\n};\n\n\nbool AccessGatewayFilter::filter(const Request& request) {\n    const std::string& request_uri = request.path;\n    const std::string& method = request.method;\n\n    if (is_start_with(request_uri)) {\n        return true;\n    }\n\n    try {\n        Authorization token = get_jwt_user(request);\n        User user = token.user;\n        if (user.level > 2) {\n            set_current_user_info_and_log(user);\n            return true;\n        }\n    }\n    catch (...) {\n        return false;\n    }\n    return false;\n}\n\nbool AccessGatewayFilter::is_start_with(const std::string& request_uri) {\n    static const std::string start_with[] = { \"/api\", \"/login\" };\n    for (const auto& s : start_with) {\n        if (request_uri.find(s) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nAuthorization AccessGatewayFilter::get_jwt_user(const Request& request) {\n    Authorization token = request.auth;\n    const User& user = token.user;\n\n    if (token.jwt.find(user.name) == 0) {\n        std::string jwt_str_date = token.jwt.substr(user.name.size());\n\n        std::time_t jwt_timestamp;\n        std::istringstream ss(jwt_str_date);\n        ss >> jwt_timestamp;\n\n        if (ss.fail()) {\n            return Authorization{};\n        }\n\n        std::time_t now = std::time(nullptr);\n        if (std::difftime(now, jwt_timestamp) >= 3 * 24 * 60 * 60) { \n            return Authorization{};\n        }\n    }\n    return token;\n}\n\nvoid AccessGatewayFilter::set_current_user_info_and_log(const User& user) {\n    std::cout << user.name << \" \" << user.address << \" \" << std::time(nullptr) << std::endl;\n}\n",
  "AreaCalculator": "#include <cmath>\n#include <stdexcept>\n#include <gtest/gtest.h>\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\nclass AreaCalculator {\npublic:\n    explicit AreaCalculator(double radius);\n\n    double calculate_circle_area() const;\n    double calculate_sphere_area() const;\n    double calculate_cylinder_area(double height) const;\n    double calculate_sector_area(double angle) const;\n    double calculate_annulus_area(double inner_radius, double outer_radius) const;\n\nprivate:\n    double radius;\n};\nAreaCalculator::AreaCalculator(double radius) : radius(radius) {\n    if (radius < 0) throw std::invalid_argument(\"Radius cannot be negative.\");\n}\n\ndouble AreaCalculator::calculate_circle_area() const {\n    return M_PI * radius * radius;\n}\n\ndouble AreaCalculator::calculate_sphere_area() const {\n    return 4 * M_PI * radius * radius;\n}\n\ndouble AreaCalculator::calculate_cylinder_area(double height) const {\n    if (height < 0) throw std::invalid_argument(\"Height cannot be negative.\");\n    return 2 * M_PI * radius * (radius + height);\n}\n\ndouble AreaCalculator::calculate_sector_area(double angle) const {\n    return 0.5 * radius * radius * angle;\n}\n\ndouble AreaCalculator::calculate_annulus_area(double inner_radius, double outer_radius) const {\n    if (inner_radius > outer_radius) throw std::invalid_argument(\"Inner radius cannot be greater than outer radius.\");\n    return M_PI * (outer_radius * outer_radius - inner_radius * inner_radius);\n}\n",
  "ArgumentParser": "\n#include <sstream>\n#include <utility>\n\n\n#include <string>\n#include <map>\n#include <set>\n#include <tuple>\n#include <functional>\n\nclass ArgumentParser {\npublic:\n    ArgumentParser();\n    std::tuple<bool, std::set<std::string>> parse_arguments(const std::string& command_string);\n    std::string get_argument(const std::string& key) const;\n    void add_argument(const std::string& arg, bool required = false, const std::string& type = \"string\");\n\n    std::map<std::string, std::string> arguments;\n    std::set<std::string> required;\n    std::map<std::string, std::string> types;\n    std::map<std::string, std::function<std::string(const std::string&)>> type_converters;\n\n    std::string convert_type(const std::string& arg, const std::string& value) const;\n    void initialize_converters();\n};\n\nArgumentParser::ArgumentParser()\n{\n    initialize_converters();\n}\n\nstd::tuple<bool, std::set<std::string>> ArgumentParser::parse_arguments(const std::string &command_string)\n{\n    std::istringstream iss(command_string);\n    std::string word;\n    std::getline(iss, word, ' '); \n\n    while (iss >> word)\n    {\n        if (word.find(\"--\") == 0)\n        {\n            auto key_value = word.substr(2);\n            size_t pos = key_value.find('=');\n            std::string key = key_value.substr(0, pos);\n            std::string value = pos == std::string::npos ? \"\" : key_value.substr(pos + 1);\n            arguments[key] = convert_type(key, value.empty() ? \"1\" : value);\n        }\n        else if (word.find(\"-\") == 0)\n        {\n            std::string key = word.substr(1);\n            std::string value;\n            char nxt = iss.peek();\n            if (!iss.eof() && iss.peek() != '-')\n            {\n                iss >> value;\n                arguments[key] = convert_type(key, value);\n            }\n            else\n            {\n                arguments[key] = convert_type(key, \"1\");\n            }\n        }\n    }\n\n    std::set<std::string> missing_args;\n    for (const auto &req : required)\n    {\n        if (arguments.find(req) == arguments.end())\n        {\n            missing_args.insert(req);\n        }\n    }\n\n    return {missing_args.empty(), missing_args};\n}\n\nstd::string ArgumentParser::get_argument(const std::string &key) const\n{\n    auto it = arguments.find(key);\n    if (it != arguments.end())\n    {\n        return it->second;\n    }\n    return \"\";\n}\n\nvoid ArgumentParser::add_argument(const std::string &arg, bool required, const std::string &type)\n{\n    if (required)\n    {\n        this->required.insert(arg);\n    }\n    types[arg] = type;\n}\n\nstd::string ArgumentParser::convert_type(const std::string &arg, const std::string &value) const\n{\n    if (types.find(arg) == types.end())\n    {\n        return value;\n    }\n    auto it = type_converters.find(types.at(arg));\n    if (it != type_converters.end())\n    {\n        return it->second(value);\n    }\n    return value;\n}\n\nvoid ArgumentParser::initialize_converters()\n{\n    type_converters[\"int\"] = [](const std::string &value)\n    {\n        try\n        {\n            return std::to_string(std::stoi(value));\n        }\n        catch (...)\n        {\n            return value;\n        }\n    };\n\n    type_converters[\"bool\"] = [](const std::string &value)\n    {\n        std::string tmp = value;\n        if (tmp == \"True\")\n            tmp = \"1\";\n        if (tmp == \"False\")\n            tmp = \"0\";\n        return tmp;\n    };\n}\n",
  "ArrangementCalculator": "#include <vector>\n#include <string>\n\nclass ArrangementCalculator {\npublic:\n    ArrangementCalculator(const std::vector<std::string>& datas);\n    static int count(int n, int m = -1);\n    static int count_all(int n);\n    std::vector<std::vector<std::string>> select(int m = -1) const;\n    std::vector<std::vector<std::string>> select_all() const;\n    static int factorial(int n);\n\nprivate:\n    std::vector<std::string> datas;\n    void permutations_recursive(std::vector<std::string>& current, std::vector<std::string>& remaining, int m, std::vector<std::vector<std::string>>& result) const;\n};\n\nArrangementCalculator::ArrangementCalculator(const std::vector<std::string>& datas) : datas(datas) {}\n\nint ArrangementCalculator::count(int n, int m) {\n    if (m == -1 || n == m) {\n        return ArrangementCalculator::factorial(n);\n    }\n    else {\n        return ArrangementCalculator::factorial(n) / ArrangementCalculator::factorial(n - m);\n    }\n}\n\nint ArrangementCalculator::count_all(int n) {\n    int total = 0;\n    for (int i = 1; i <= n; ++i) {\n        total += ArrangementCalculator::count(n, i);\n    }\n    return total;\n}\n\nvoid ArrangementCalculator::permutations_recursive(std::vector<std::string>& current, std::vector<std::string>& remaining, int m, std::vector<std::vector<std::string>>& result) const {\n    if (current.size() == m) {\n        result.push_back(current);\n    }\n    else {\n        for (size_t i = 0; i < remaining.size(); ++i) {\n            std::vector<std::string> new_current = current;\n            new_current.push_back(remaining[i]);\n            std::vector<std::string> new_remaining = remaining;\n            new_remaining.erase(new_remaining.begin() + i);\n            permutations_recursive(new_current, new_remaining, m, result);\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> ArrangementCalculator::select(int m) const {\n    std::vector<std::vector<std::string>> result;\n    if (m == -1) {\n        m = datas.size();\n    }\n\n    std::vector<std::string> current;\n    std::vector<std::string> remaining = datas;\n\n    permutations_recursive(current, remaining, m, result);\n\n    return result;\n}\n\nstd::vector<std::vector<std::string>> ArrangementCalculator::select_all() const {\n    std::vector<std::vector<std::string>> result;\n    for (size_t i = 1; i <= datas.size(); ++i) {\n        std::vector<std::vector<std::string>> partial_result = select(i);\n        result.insert(result.end(), partial_result.begin(), partial_result.end());\n    }\n    return result;\n}\n\nint ArrangementCalculator::factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n",
  "AssessmentSystem": "\n#include <numeric>\n#include <algorithm>\n\n#include <string>\n#include <map>\n#include <vector>\n#include <optional>\n\n\nstruct Student {\n    int grade;\n    std::string major;\n    std::map<std::string, int> courses;\n};\n\n\nclass AssessmentSystem {\npublic:\n    void add_student(const std::string& name, int grade, const std::string& major);\n    void add_course_score(const std::string& name, const std::string& course, int score);\n    std::optional<double> get_gpa(const std::string& name) const;\n    std::vector<std::string> get_all_students_with_fail_course() const;\n    std::optional<double> get_course_average(const std::string& course) const;\n    std::optional<std::string> get_top_student() const;\n    std::map<std::string, Student> students;\n};\n\nvoid AssessmentSystem::add_student(const std::string& name, int grade, const std::string& major) {\n    students[name] = { grade, major, {} };\n}\n\nvoid AssessmentSystem::add_course_score(const std::string& name, const std::string& course, int score) {\n    auto it = students.find(name);\n    if (it != students.end()) {\n        it->second.courses[course] = score;\n    }\n}\n\nstd::optional<double> AssessmentSystem::get_gpa(const std::string& name) const {\n    auto it = students.find(name);\n    if (it != students.end()) {\n        const auto& courses = it->second.courses;\n        if (!courses.empty()) {\n            double total_score = std::accumulate(courses.begin(), courses.end(), 0.0,\n                [](double sum, const auto& course) { return sum + course.second; });\n            return total_score / courses.size();\n        }\n    }\n    return std::nullopt;\n}\n\nstd::vector<std::string> AssessmentSystem::get_all_students_with_fail_course() const {\n    std::vector<std::string> students_with_fail;\n    for (const auto& [name, student] : students) {\n        if (std::any_of(student.courses.begin(), student.courses.end(), [](const auto& course) { return course.second < 60; })) {\n            students_with_fail.push_back(name);\n        }\n    }\n    return students_with_fail;\n}\n\nstd::optional<double> AssessmentSystem::get_course_average(const std::string& course) const {\n    double total = 0;\n    int count = 0;\n    for (const auto& [name, student] : students) {\n        auto it = student.courses.find(course);\n        if (it != student.courses.end()) {\n            total += it->second;\n            ++count;\n        }\n    }\n    return (count > 0) ? std::optional<double>(total / count) : std::nullopt;\n}\n\nstd::optional<std::string> AssessmentSystem::get_top_student() const {\n    std::optional<std::string> top_student;\n    std::optional<double> highest_gpa;\n    for (const auto& [name, student] : students) {\n        auto gpa = get_gpa(name);\n        if (gpa && (!highest_gpa || *gpa > *highest_gpa)) {\n            highest_gpa = gpa;\n            top_student = name;\n        }\n    }\n    return top_student;\n}\n",
  "AutomaticGuitarSimulator": "\n#include <sstream>\n#include <iostream>\n\n#include <string>\n#include <vector>\n\nstruct PlayItem {\n    std::string Chord;\n    std::string Tune;\n};\n\nclass AutomaticGuitarSimulator {\npublic:\n    AutomaticGuitarSimulator(const std::string& text);\n    std::vector<PlayItem> interpret(bool display = false);\n    std::string format_display(const std::string& key, const std::string& value);\n\nprivate:\n    std::string play_text;\n};\n\nAutomaticGuitarSimulator::AutomaticGuitarSimulator(const std::string& text) : play_text(text) {}\n\nstd::vector<PlayItem> AutomaticGuitarSimulator::interpret(bool display) {\n    std::vector<PlayItem> play_list;\n    if (play_text.empty()) {\n        return play_list;\n    }\n\n    std::istringstream iss(play_text);\n    std::string play_seg;\n\n    while (iss >> play_seg) {\n        size_t pos = 0;\n        while (pos < play_seg.size() && isalpha(play_seg[pos])) {\n            pos++;\n        }\n\n        std::string play_chord = play_seg.substr(0, pos);\n        std::string play_value = play_seg.substr(pos);\n\n        PlayItem item = { play_chord, play_value };\n        play_list.push_back(item);\n\n        if (display) {\n            std::cout << format_display(play_chord, play_value) << std::endl;\n        }\n    }\n    return play_list;\n}\n\nstd::string AutomaticGuitarSimulator::format_display(const std::string& key, const std::string& value) {\n    return \"Normal Guitar Playing -- Chord: \" + key + \", Play Tune: \" + value;\n}\n",
  "AvgPartition": "\n#include <vector>\n\nclass AvgPartition {\npublic:\n    AvgPartition(const std::vector<int>& lst, int limit);\n    std::pair<int, int> set_num() const;\n    std::vector<int> get(int index) const;\n\nprivate:\n    std::vector<int> lst;\n    int limit;\n};\nAvgPartition::AvgPartition(const std::vector<int>& lst, int limit)\n    : lst(lst), limit(limit) {}\n\nstd::pair<int, int> AvgPartition::set_num() const {\n    int size = lst.size() / limit;\n    int remainder = lst.size() % limit;\n    return { size, remainder };\n}\n\nstd::vector<int> AvgPartition::get(int index) const {\n    auto [size, remainder] = set_num();\n    int start = index * size + std::min(index, remainder);\n    int end = start + size;\n    if (index + 1 <= remainder) {\n        end += 1;\n    }\n    return std::vector<int>(lst.begin() + start, lst.begin() + end);\n}\n",
  "BalancedBrackets": "\n#include <algorithm>\n\n#include <stack>\n#include <string>\n\nclass BalancedBrackets {\npublic:\n    explicit BalancedBrackets(const std::string& expr);\n    bool check_balanced_brackets();\n\n    void clearExpr();\n\n    std::stack<char> stack;\n    const std::string leftBrackets = \"({[\";\n    const std::string rightBrackets = \")}]\";\n    std::string expr;\n};\n\nBalancedBrackets::BalancedBrackets(const std::string& expr) : expr(expr) {}\n\nvoid BalancedBrackets::clearExpr() {\n    expr.erase(std::remove_if(expr.begin(), expr.end(), [this](char c) {\n        return leftBrackets.find(c) == std::string::npos && rightBrackets.find(c) == std::string::npos;\n        }), expr.end());\n}\n\nbool BalancedBrackets::check_balanced_brackets() {\n    clearExpr();\n    for (char Brkt : expr) {\n        if (leftBrackets.find(Brkt) != std::string::npos) {\n            stack.push(Brkt);\n        }\n        else {\n            if (stack.empty()) return false;\n            char Current_Brkt = stack.top();\n            stack.pop();\n            if (Current_Brkt == '(' && Brkt != ')') return false;\n            if (Current_Brkt == '{' && Brkt != '}') return false;\n            if (Current_Brkt == '[' && Brkt != ']') return false;\n        }\n    }\n    return stack.empty();\n}\n",
  "BankAccount": "\n#include <stdexcept>\n\nclass BankAccount {\npublic:\n    BankAccount(double balance = 0);\n    double deposit(double amount);\n    double withdraw(double amount);\n    double view_balance() const;\n    void transfer(BankAccount& otherAccount, double amount);\n\nprivate:\n    double balance;\n};\n\nBankAccount::BankAccount(double balance) : balance(balance) {}\n\ndouble BankAccount::deposit(double amount) {\n    if (amount < 0) {\n        throw std::invalid_argument(\"Invalid amount\");\n    }\n    balance += amount;\n    return balance;\n}\n\ndouble BankAccount::withdraw(double amount) {\n    if (amount < 0) {\n        throw std::invalid_argument(\"Invalid amount\");\n    }\n    if (amount > balance) {\n        throw std::invalid_argument(\"Insufficient balance.\");\n    }\n    balance -= amount;\n    return balance;\n}\n\ndouble BankAccount::view_balance() const {\n    return balance;\n}\n\nvoid BankAccount::transfer(BankAccount& otherAccount, double amount) {\n    withdraw(amount);\n    otherAccount.deposit(amount);\n}\n",
  "BigNumCalculator": "\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\n\n#include <string>\n\nclass BigNumCalculator {\npublic:\n    static std::string add(const std::string& num1, const std::string& num2);\n    static std::string subtract(const std::string& num1, const std::string& num2);\n    static std::string multiply(const std::string& num1, const std::string& num2);\n};\n\nstd::string BigNumCalculator::add(const std::string& num1, const std::string& num2) {\n    int max_length = std::max(num1.size(), num2.size());\n    std::string num1_padded = std::string(max_length - num1.size(), '0') + num1;\n    std::string num2_padded = std::string(max_length - num2.size(), '0') + num2;\n\n    int carry = 0;\n    std::string result;\n    for (int i = max_length - 1; i >= 0; --i) {\n        int digit_sum = (num1_padded[i] - '0') + (num2_padded[i] - '0') + carry;\n        carry = digit_sum / 10;\n        int digit = digit_sum % 10;\n        result.insert(result.begin(), digit + '0');\n    }\n\n    if (carry > 0) {\n        result.insert(result.begin(), carry + '0');\n    }\n\n    return result;\n}\n\nstd::string BigNumCalculator::subtract(const std::string& num1, const std::string& num2) {\n    std::string num1_local = num1;\n    std::string num2_local = num2;\n    bool negative = false;\n\n    if (num1_local.size() < num2_local.size() || (num1_local.size() == num2_local.size() && num1_local < num2_local)) {\n        std::swap(num1_local, num2_local);\n        negative = true;\n    }\n\n    int max_length = std::max(num1_local.size(), num2_local.size());\n    num1_local = std::string(max_length - num1_local.size(), '0') + num1_local;\n    num2_local = std::string(max_length - num2_local.size(), '0') + num2_local;\n\n    int borrow = 0;\n    std::string result;\n    for (int i = max_length - 1; i >= 0; --i) {\n        int digit_diff = (num1_local[i] - '0') - (num2_local[i] - '0') - borrow;\n\n        if (digit_diff < 0) {\n            digit_diff += 10;\n            borrow = 1;\n        }\n        else {\n            borrow = 0;\n        }\n\n        result.insert(result.begin(), digit_diff + '0');\n    }\n\n    while (result.size() > 1 && result[0] == '0') {\n        result.erase(result.begin());\n    }\n\n    if (negative) {\n        result.insert(result.begin(), '-');\n    }\n\n    return result;\n}\n\nstd::string BigNumCalculator::multiply(const std::string& num1, const std::string& num2) {\n    int len1 = num1.size();\n    int len2 = num2.size();\n    std::vector<int> result(len1 + len2, 0);\n\n    for (int i = len1 - 1; i >= 0; --i) {\n        for (int j = len2 - 1; j >= 0; --j) {\n            int mul = (num1[i] - '0') * (num2[j] - '0');\n            int p1 = i + j;\n            int p2 = i + j + 1;\n            int total = mul + result[p2];\n\n            result[p1] += total / 10;\n            result[p2] = total % 10;\n        }\n    }\n\n    std::ostringstream oss;\n    bool leadingZero = true;\n    for (int num : result) {\n        if (num == 0 && leadingZero) continue;\n        leadingZero = false;\n        oss << num;\n    }\n\n    return oss.str().empty() ? \"0\" : oss.str();\n}\n",
  "BinaryDataProcessor": "\n#include <algorithm>\n#include <bitset>\n#include <sstream>\n#include <stdexcept>\n\n#include <string>\n#include <unordered_map>\n\nclass BinaryDataProcessor {\npublic:\n    BinaryDataProcessor(const std::string& binary_string);\n    void clean_non_binary_chars();\n    std::unordered_map<std::string, double> calculate_binary_info();\n    std::string convert_to_ascii();\n    std::string convert_to_utf8();\n\n    std::string binary_string;\n};\n\nBinaryDataProcessor::BinaryDataProcessor(const std::string& binary_string) {\n    this->binary_string = binary_string;\n    clean_non_binary_chars();\n}\n\nvoid BinaryDataProcessor::clean_non_binary_chars() {\n    binary_string.erase(std::remove_if(binary_string.begin(), binary_string.end(),\n        [](char c) { return c != '0' && c != '1'; }), binary_string.end());\n}\n\nstd::unordered_map<std::string, double> BinaryDataProcessor::calculate_binary_info() {\n    int zeroes_count = std::count(binary_string.begin(), binary_string.end(), '0');\n    int ones_count = binary_string.size() - zeroes_count;\n    int total_length = binary_string.size();\n\n    double zeroes_percentage = static_cast<double>(zeroes_count) / total_length;\n    double ones_percentage = static_cast<double>(ones_count) / total_length;\n\n    return {\n        {\"Zeroes\", zeroes_percentage},\n        {\"Ones\", ones_percentage},\n        {\"Bit length\", static_cast<double>(total_length)}\n    };\n}\n\nstd::string BinaryDataProcessor::convert_to_ascii() {\n    std::stringstream ss;\n    for (size_t i = 0; i < binary_string.size(); i += 8) {\n        std::bitset<8> byte(binary_string.substr(i, 8));\n        ss << static_cast<char>(byte.to_ulong());\n    }\n    return ss.str();\n}\n\nstd::string BinaryDataProcessor::convert_to_utf8() {\n    return convert_to_ascii(); \n}\n",
  "BitStatusUtil": "\n#include <vector>\n#include <string>\n#include <stdexcept>  \n\nclass BitStatusUtil {\npublic:\n    static int add(int states, int stat);\n    static bool has(int states, int stat);\n    static int remove(int states, int stat);\n    static void check(const std::vector<int>& args);\n\n    BitStatusUtil() = default; \n};\n\n\nint BitStatusUtil::add(int states, int stat) {\n    check({ states, stat });\n    return states | stat;\n}\n\n\nbool BitStatusUtil::has(int states, int stat) {\n    check({ states, stat });\n    return (states & stat) == stat;\n}\n\n\nint BitStatusUtil::remove(int states, int stat) {\n    check({ states, stat });\n    if (has(states, stat)) {\n        return states ^ stat;\n    }\n    return states;\n}\n\n\nvoid BitStatusUtil::check(const std::vector<int>& args) {\n    for (int arg : args) {\n        if (arg < 0) {\n            throw std::invalid_argument(std::to_string(arg) + \" must be greater than or equal to 0\");\n        }\n        if (arg % 2 != 0) {\n            throw std::invalid_argument(std::to_string(arg) + \" not even\");\n        }\n    }\n}\n",
  "BlackjackGame": "\n#include <algorithm>\n#include <random>\n#include <ctime>\n\n#include <vector>\n#include <string>\n\nclass BlackjackGame {\npublic:\n    BlackjackGame();\n    std::vector<std::string> create_deck();\n    int calculate_hand_value(const std::vector<std::string>& hand);\n    std::string check_winner(const std::vector<std::string>& player_hand, const std::vector<std::string>& dealer_hand);\n\nprivate:\n    std::vector<std::string> deck;\n    std::vector<std::string> player_hand;\n    std::vector<std::string> dealer_hand;\n};\n\nBlackjackGame::BlackjackGame() {\n    this->deck = create_deck();\n    this->player_hand = {};\n    this->dealer_hand = {};\n}\n\nstd::vector<std::string> BlackjackGame::create_deck() {\n    std::vector<std::string> deck;\n    std::vector<std::string> suits = { \"S\", \"C\", \"D\", \"H\" };\n    std::vector<std::string> ranks = { \"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\" };\n    for (const auto& suit : suits) {\n        for (const auto& rank : ranks) {\n            deck.push_back(rank + suit);\n        }\n    }\n    std::srand(std::time(0));\n    std::mt19937 gen(std::random_device{}());\n    std::shuffle(deck.begin(), deck.end(), gen);\n    return deck;\n}\n\nint BlackjackGame::calculate_hand_value(const std::vector<std::string>& hand) {\n    int value = 0;\n    int num_aces = 0;\n    for (const auto& card : hand) {\n        std::string rank = card.substr(0, card.size() - 1);\n        if (rank >= \"2\" && rank <= \"9\") {\n            value += std::stoi(rank);\n        }\n        else if (rank == \"A\") {\n            value += 11;\n            num_aces += 1;\n        }\n        else {\n            if (rank == \"J\" || rank == \"Q\" || rank == \"K\") value += 10;\n        }\n    }\n    while (value > 21 && num_aces > 0) {\n        value -= 10;\n        num_aces -= 1;\n    }\n    return value;\n}\n\nstd::string BlackjackGame::check_winner(const std::vector<std::string>& player_hand, const std::vector<std::string>& dealer_hand) {\n    int player_value = calculate_hand_value(player_hand);\n    int dealer_value = calculate_hand_value(dealer_hand);\n    if (player_value > 21 && dealer_value > 21) {\n        return player_value <= dealer_value ? \"Player wins\" : \"Dealer wins\";\n    }\n    else if (player_value > 21) {\n        return \"Dealer wins\";\n    }\n    else if (dealer_value > 21) {\n        return \"Player wins\";\n    }\n    else {\n        return player_value <= dealer_value ? \"Dealer wins\" : \"Player wins\";\n    }\n}",
  "BookManagement": "\n#include <string>\n#include <unordered_map>\n#include <stdexcept>\n\nclass BookManagement {\npublic:\n    BookManagement();\n\n    void add_book(const std::string& title, int quantity = 1);\n    void remove_book(const std::string& title, int quantity);\n    std::unordered_map<std::string, int> view_inventory() const;\n    int view_book_quantity(const std::string& title) const;\n\nprivate:\n    std::unordered_map<std::string, int> inventory;\n};\n\nBookManagement::BookManagement() {}\n\nvoid BookManagement::add_book(const std::string& title, int quantity) {\n    if (inventory.find(title) != inventory.end()) {\n        inventory[title] += quantity;\n    }\n    else {\n        inventory[title] = quantity;\n    }\n}\n\nvoid BookManagement::remove_book(const std::string& title, int quantity) {\n    auto it = inventory.find(title);\n    if (it == inventory.end() || it->second < quantity) {\n        throw std::runtime_error(\"Insufficient quantity or book not found\");\n    }\n    it->second -= quantity;\n    if (it->second == 0) {\n        inventory.erase(it);\n    }\n}\n\nstd::unordered_map<std::string, int> BookManagement::view_inventory() const {\n    return inventory;\n}\n\nint BookManagement::view_book_quantity(const std::string& title) const {\n    auto it = inventory.find(title);\n    if (it == inventory.end()) {\n        return 0;\n    }\n    return it->second;\n}\n",
  "BookManagementDB": "\n#include <stdexcept>\n\n#include <winsqlite/winsqlite3.h>\n#include <string>\n#include <vector>\n#include <tuple>\n\nclass BookManagementDB {\npublic:\n    explicit BookManagementDB(const std::string& db_name);\n    ~BookManagementDB();\n\n    void create_table();\n    void add_book(const std::string& title, const std::string& author);\n    void remove_book(int id);\n    void borrow_book(int id);\n    void return_book(int id);\n    std::vector<std::tuple<int, std::string, std::string, int>> search_books();\n    sqlite3* get_connection();\n\nprivate:\n    sqlite3* connection;\n};\n\nBookManagementDB::BookManagementDB(const std::string& db_name) {\n    if (sqlite3_open(db_name.c_str(), &connection) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to open database\");\n    }\n}\n\nBookManagementDB::~BookManagementDB() {\n    sqlite3_close(connection);\n}\n\nvoid BookManagementDB::create_table() {\n    const char* create_table_sql = R\"(\n        CREATE TABLE IF NOT EXISTS books (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            author TEXT NOT NULL,\n            available INTEGER NOT NULL\n        )\n    )\";\n    char* error_msg = nullptr;\n    if (sqlite3_exec(connection, create_table_sql, nullptr, nullptr, &error_msg) != SQLITE_OK) {\n        throw std::runtime_error(error_msg);\n    }\n}\n\nvoid BookManagementDB::add_book(const std::string& title, const std::string& author) {\n    const char* insert_sql = \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(connection, insert_sql, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_bind_text(stmt, 1, title.c_str(), -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, author.c_str(), -1, SQLITE_TRANSIENT);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_finalize(stmt);\n}\n\nvoid BookManagementDB::remove_book(int id) {\n    const char* delete_sql = \"DELETE FROM books WHERE id = ?\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(connection, delete_sql, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_bind_int(stmt, 1, id);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_finalize(stmt);\n}\n\nvoid BookManagementDB::borrow_book(int id) {\n    const char* update_sql = \"UPDATE books SET available = 0 WHERE id = ?\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(connection, update_sql, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_bind_int(stmt, 1, id);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_finalize(stmt);\n}\n\nvoid BookManagementDB::return_book(int id) {\n    const char* update_sql = \"UPDATE books SET available = 1 WHERE id = ?\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(connection, update_sql, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_bind_int(stmt, 1, id);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n    sqlite3_finalize(stmt);\n}\n\nstd::vector<std::tuple<int, std::string, std::string, int>> BookManagementDB::search_books() {\n    const char* select_sql = \"SELECT * FROM books\";\n    sqlite3_stmt* stmt;\n    std::vector<std::tuple<int, std::string, std::string, int>> books;\n\n    if (sqlite3_prepare_v2(connection, select_sql, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(sqlite3_errmsg(connection));\n    }\n\n    while (sqlite3_step(stmt) == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        std::string title(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1)));\n        std::string author(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2)));\n        int available = sqlite3_column_int(stmt, 3);\n        books.emplace_back(id, title, author, available);\n    }\n    sqlite3_finalize(stmt);\n    return books;\n}\n\nsqlite3* BookManagementDB::get_connection()\n{\n    return this->connection;\n}\n",
  "BoyerMooreSearch": "#include <string>\n#include <vector>\n\nclass BoyerMooreSearch {\npublic:\n    BoyerMooreSearch(const std::string& text, const std::string& pattern);\n\n    int match_in_pattern(char c) const;\n    int mismatch_in_text(int currentPos) const;\n    std::vector<int> bad_character_heuristic() const;\n\nprivate:\n    std::string text;\n    std::string pattern;\n    int text_len;\n    int pat_len;\n};\n\nBoyerMooreSearch::BoyerMooreSearch(const std::string& text, const std::string& pattern)\n    : text(text), pattern(pattern), text_len(text.size()), pat_len(pattern.size()) {}\n\nint BoyerMooreSearch::match_in_pattern(char c) const {\n    for (int i = pat_len - 1; i >= 0; --i) {\n        if (c == pattern[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint BoyerMooreSearch::mismatch_in_text(int currentPos) const {\n    for (int i = pat_len - 1; i >= 0; --i) {\n        if (pattern[i] != text[currentPos + i]) {\n            return currentPos + i;\n        }\n    }\n    return -1;\n}\n\nstd::vector<int> BoyerMooreSearch::bad_character_heuristic() const {\n    std::vector<int> positions;\n    int i = 0;\n    while (i <= text_len - pat_len) {\n        int mismatch_index = mismatch_in_text(i);\n        if (mismatch_index == -1) {\n            positions.push_back(i);\n            i += 1;  \n        }\n        else {\n            char mismatched_char = text[mismatch_index];\n            int match_index = match_in_pattern(mismatched_char);\n            if (match_index == -1) {\n                i += (mismatch_index - i + 1);\n            }\n            else {\n                i += (mismatch_index - match_index);\n            }\n        }\n    }\n    return positions;\n}\n\n",
  "Calculator": "\n#include <sstream>\n\n#include <string>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <stdexcept>\n#include <unordered_map>\n#include <functional>\n\nclass Calculator {\npublic:\n    Calculator();\n    double calculate(const std::string& expression);\n    int precedence(char op);\n    std::pair<std::stack<double>, std::stack<char>> apply_operator(std::stack<double> operand_stack, std::stack<char> operator_stack);\nprivate:\n    std::unordered_map<char, std::function<double(double, double)>> operators;\n};\n\nCalculator::Calculator() {\n    operators['+'] = [](double x, double y) { return x + y; };\n    operators['-'] = [](double x, double y) { return x - y; };\n    operators['*'] = [](double x, double y) { return x * y; };\n    operators['/'] = [](double x, double y) { return x / y; };\n    operators['^'] = [](double x, double y) { return std::pow(x, y); };\n}\n\ndouble Calculator::calculate(const std::string& expression) {\n    if (expression.empty()) {\n        return 0.0; \n    }\n\n    std::stack<double> operand_stack;\n    std::stack<char> operator_stack;\n    std::string num_buffer;\n\n    for (char ch : expression) {\n        if (std::isdigit(ch) || ch == '.') {\n            num_buffer += ch;\n        }\n        else {\n            if (!num_buffer.empty()) {\n                operand_stack.push(std::stod(num_buffer));\n                num_buffer.clear();\n            }\n\n            if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^') {\n                while (!operator_stack.empty() && operator_stack.top() != '(' &&\n                    precedence(operator_stack.top()) >= precedence(ch)) {\n                    auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n                    operand_stack = std::move(operands);\n                    operator_stack = std::move(operators);\n                }\n                operator_stack.push(ch);\n            }\n            else if (ch == '(') {\n                operator_stack.push(ch);\n            }\n            else if (ch == ')') {\n                while (!operator_stack.empty() && operator_stack.top() != '(') {\n                    auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n                    operand_stack = std::move(operands);\n                    operator_stack = std::move(operators);\n                }\n                operator_stack.pop(); \n            }\n        }\n    }\n\n    if (!num_buffer.empty()) {\n        operand_stack.push(std::stod(num_buffer));\n    }\n\n    while (!operator_stack.empty()) {\n        auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n        operand_stack = std::move(operands);\n        operator_stack = std::move(operators);\n    }\n\n    return !operand_stack.empty() ? operand_stack.top() : 0.0; \n}\n\nint Calculator::precedence(char op) {\n    switch (op) {\n    case '+': case '-': return 1;\n    case '*': case '/': return 2;\n    case '^': return 3;\n    default: return 0;\n    }\n}\n\nstd::pair<std::stack<double>, std::stack<char>> Calculator::apply_operator(std::stack<double> operand_stack, std::stack<char> operator_stack) {\n    char op = operator_stack.top();\n    operator_stack.pop();\n\n    double operand2 = operand_stack.top();\n    operand_stack.pop();\n    double operand1 = operand_stack.top();\n    operand_stack.pop();\n\n    double result = operators[op](operand1, operand2);\n    operand_stack.push(result);\n\n    return { operand_stack, operator_stack };\n}\n",
  "CalendarUtil": "\n#include <ctime>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <iomanip>\n\n#include <chrono>\n#include <string>\n#include <vector>\n#include <map>\n\nclass CalendarUtil {\npublic:\n    struct Event {\n        std::chrono::system_clock::time_point date;\n        std::chrono::system_clock::time_point start_time;\n        std::chrono::system_clock::time_point end_time;\n        std::string description;\n\n        bool operator==(const Event& other) const {\n            return date == other.date &&\n                start_time == other.start_time &&\n                end_time == other.end_time &&\n                description == other.description;\n        }\n    };\n\n    void add_event(const Event& event);\n    void remove_event(const Event& event);\n    std::vector<Event> get_events(const std::chrono::system_clock::time_point& date);\n    bool is_available(const std::chrono::system_clock::time_point& start_time,\n        const std::chrono::system_clock::time_point& end_time);\n    std::vector<std::pair<std::chrono::system_clock::time_point, std::chrono::system_clock::time_point>> get_available_slots(const std::chrono::system_clock::time_point& date);\n    std::vector<Event> get_upcoming_events(size_t num_events);\n    std::vector<Event> events;\n};\n\nstd::chrono::system_clock::time_point time_from_timestamp(time_t timestamp);\n\nvoid CalendarUtil::add_event(const Event& event) {\n    events.push_back(event);\n}\n\nvoid CalendarUtil::remove_event(const Event& event) {\n    auto it = std::find(events.begin(), events.end(), event);\n    if (it != events.end()) {\n        events.erase(it);\n    }\n}\n\nstd::vector<CalendarUtil::Event> CalendarUtil::get_events(const std::chrono::system_clock::time_point& date) {\n    std::vector<Event> events_on_date;\n    auto date_tm = std::chrono::system_clock::to_time_t(date);\n    std::tm date_tm_struct;\n    localtime_s(&date_tm_struct, &date_tm);\n    for (const auto& event : events) {\n        auto event_date_tm = std::chrono::system_clock::to_time_t(event.date);\n        std::tm event_date_tm_struct;\n        localtime_s(&event_date_tm_struct, &event_date_tm);\n        if (date_tm_struct.tm_year == event_date_tm_struct.tm_year &&\n            date_tm_struct.tm_mon == event_date_tm_struct.tm_mon &&\n            date_tm_struct.tm_mday == event_date_tm_struct.tm_mday) {\n            events_on_date.push_back(event);\n        }\n    }\n    return events_on_date;\n}\n\nbool CalendarUtil::is_available(const std::chrono::system_clock::time_point& start_time,\n    const std::chrono::system_clock::time_point& end_time) {\n    for (const auto& event : events) {\n        if (start_time < event.end_time && end_time > event.start_time) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<std::pair<std::chrono::system_clock::time_point, std::chrono::system_clock::time_point>> CalendarUtil::get_available_slots(const std::chrono::system_clock::time_point& date) {\n    std::vector<std::pair<std::chrono::system_clock::time_point, std::chrono::system_clock::time_point>> available_slots;\n    auto start_time = date;\n    auto end_time = date + std::chrono::hours(24) - std::chrono::seconds(1);\n\n    while (start_time < end_time) {\n        auto slot_end_time = start_time + std::chrono::hours(1);\n        if (is_available(start_time, slot_end_time)) {\n            available_slots.emplace_back(start_time, slot_end_time);\n        }\n        start_time = slot_end_time;\n    }\n\n    return available_slots;\n}\n\nstd::vector<CalendarUtil::Event> CalendarUtil::get_upcoming_events(size_t num_events) {\n    auto now = std::chrono::system_clock::now();\n    std::vector<Event> upcoming_events;\n    for (const auto& event : events) {\n        if (event.start_time >= now) {\n            upcoming_events.push_back(event);\n            if (upcoming_events.size() == num_events) {\n                break;\n            }\n        }\n    }\n    return upcoming_events;\n}\n\nstd::chrono::system_clock::time_point time_from_timestamp(time_t timestamp) {\n    std::tm tm;\n    localtime_s(&tm, &timestamp);\n    return std::chrono::system_clock::from_time_t(std::mktime(&tm));\n}\n",
  "CamelCaseMap": "#include <algorithm>\n#include <cctype>\n\n#include <unordered_map>\n#include <string>\n#include <vector>\n\nclass CamelCaseMap {\npublic:\n    std::unordered_map<std::string, std::string> data;\n    std::vector<std::string> insertion_order;\n    static std::string to_camel_case(const std::string& key);\n    std::string convert_key(const std::string& key) const;\n    void set_item(const std::string& key, const std::string& value);\n    std::string get_item(const std::string& key) const;\n    void del_item(const std::string& key);\n    size_t len() const;\n    std::vector<std::string>::const_iterator begin() const;\n    std::vector<std::string>::const_iterator end() const;\n};\n\nstd::string CamelCaseMap::to_camel_case(const std::string& key) {\n    std::string camel_case_key;\n    bool capitalize = false;\n    for (char c : key) {\n        if (c == '_') {\n            capitalize = true;\n        }\n        else {\n            camel_case_key += capitalize ? std::toupper(c) : c;\n            capitalize = false;\n        }\n    }\n    return camel_case_key;\n}\n\nstd::string CamelCaseMap::convert_key(const std::string& key) const {\n    return to_camel_case(key);\n}\n\nvoid CamelCaseMap::set_item(const std::string& key, const std::string& value) {\n    std::string camel_key = convert_key(key);\n    if (data.find(camel_key) == data.end()) {\n        insertion_order.push_back(camel_key);\n    }\n    data[camel_key] = value;\n}\n\nstd::string CamelCaseMap::get_item(const std::string& key) const {\n    return data.at(convert_key(key));\n}\n\nvoid CamelCaseMap::del_item(const std::string& key) {\n    std::string camel_key = convert_key(key);\n    data.erase(camel_key);\n    insertion_order.erase(std::remove(insertion_order.begin(), insertion_order.end(), camel_key), insertion_order.end());\n}\n\nsize_t CamelCaseMap::len() const {\n    return data.size();\n}\n\nstd::vector<std::string>::const_iterator CamelCaseMap::begin() const {\n    return insertion_order.begin();\n}\n\nstd::vector<std::string>::const_iterator CamelCaseMap::end() const {\n    return insertion_order.end();\n}\n",
  "ChandrasekharSieve": "#include <vector>\n\nclass ChandrasekharSieve {\npublic:\n    ChandrasekharSieve(int n);\n    std::vector<int> get_primes() const;\n\nprivate:\n    int n;\n    std::vector<int> primes;\n\n    std::vector<int> generate_primes();\n};\n\nChandrasekharSieve::ChandrasekharSieve(int n) : n(n) {\n    primes = generate_primes();\n}\n\nstd::vector<int> ChandrasekharSieve::generate_primes() {\n    if (n < 2) {\n        return {};\n    }\n\n    std::vector<bool> sieve(n + 1, true);\n    sieve[0] = sieve[1] = false;\n\n    int p = 2;\n    while (p * p <= n) {\n        if (sieve[p]) {\n            for (int i = p * p; i <= n; i += p) {\n                sieve[i] = false;\n            }\n        }\n        p++;\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i <= n; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\nstd::vector<int> ChandrasekharSieve::get_primes() const {\n    return primes;\n}\n",
  "Chat": "\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n#include <sstream>\n\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nclass Chat {\npublic:\n    struct Message {\n        std::string sender;\n        std::string receiver;\n        std::string message;\n        std::string timestamp;\n    };\n\n    bool add_user(const std::string& username);\n    bool remove_user(const std::string& username);\n    bool send_message(const std::string& sender, const std::string& receiver, const std::string& message);\n    std::vector<Message> get_messages(const std::string& username) const;\n    std::unordered_map<std::string, std::vector<Message>> get_users() const;\n    std::string get_current_time() const;\n\nprivate:\n    std::unordered_map<std::string, std::vector<Message>> users;\n};\n\nbool Chat::add_user(const std::string& username) {\n    if (users.find(username) != users.end()) {\n        return false;\n    }\n    users[username] = {};\n    return true;\n}\n\nbool Chat::remove_user(const std::string& username) {\n    return users.erase(username) > 0;\n}\n\nbool Chat::send_message(const std::string& sender, const std::string& receiver, const std::string& message) {\n    if (users.find(sender) == users.end() || users.find(receiver) == users.end()) {\n        return false;\n    }\n\n    std::string timestamp = get_current_time();\n    Message message_info = { sender, receiver, message, timestamp };\n    users[sender].push_back(message_info);\n    users[receiver].push_back(message_info);\n    return true;\n}\n\nstd::vector<Chat::Message> Chat::get_messages(const std::string& username) const {\n    if (users.find(username) == users.end()) {\n        return {};\n    }\n    return users.at(username);\n}\n\nstd::unordered_map<std::string, std::vector<Chat::Message>> Chat::get_users() const {\n    return users;\n}\n\nstd::string Chat::get_current_time() const {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    std::tm now_tm = *std::localtime(&now_c);\n\n    std::ostringstream oss;\n    oss << std::put_time(&now_tm, \"%Y-%m-%d %H:%M:%S\");\n    return oss.str();\n}\n",
  "ClassRegistrationSystem": "#include <string>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nclass Student {\npublic:\n    Student(const std::string& name, const std::string& major);\n\n    std::string get_name() const;\n    std::string get_major() const;\n\n    void set_name(const std::string& name);\n    void set_major(const std::string& major);\n\n    bool operator==(const Student& other) const;\n\n    std::string name;\n    std::string major;\n};\n\nclass ClassRegistrationSystem {\npublic:\n    int register_student(const Student new_student);\n    std::vector<std::string> register_class(const std::string& student_name, const std::string& class_name);\n    std::vector<std::string> get_students_by_major(const std::string& major) const;\n    std::vector<std::string> get_all_major() const;\n    std::string get_most_popular_class_in_major(const std::string& major) const;\n    std::vector<Student> students;\n    std::unordered_map<std::string, std::vector<std::string>> students_registration_classes;\n};\n\n\nStudent::Student(const std::string& name, const std::string& major) : name(name), major(major) {}\n\nstd::string Student::get_name() const {\n    return name;\n}\n\nstd::string Student::get_major() const {\n    return major;\n}\n\nvoid Student::set_name(const std::string& name) {\n    this->name = name;\n}\n\nvoid Student::set_major(const std::string& major) {\n    this->major = major;\n}\n\nbool Student::operator==(const Student& other) const {\n    return name == other.name && major == other.major;\n}\n\n\nint ClassRegistrationSystem::register_student(const Student new_student) {\n    \n    std::string name = new_student.get_name();\n    std::string major = new_student.get_major();\n    for (const auto& student : students) {\n        if (student.get_name() == name) {\n            return 0; \n        }\n    }\n    students.emplace_back(name, major);\n    return 1; \n}\n\nstd::vector<std::string> ClassRegistrationSystem::register_class(const std::string& student_name, const std::string& class_name) {\n    auto& classes = students_registration_classes[student_name];\n    if (std::find(classes.begin(), classes.end(), class_name) == classes.end()) {\n        classes.push_back(class_name);\n    }\n    return classes;\n}\n\nstd::vector<std::string> ClassRegistrationSystem::get_students_by_major(const std::string& major) const {\n    std::vector<std::string> student_list;\n    for (const auto& student : students) {\n        if (student.get_major() == major) {\n            student_list.push_back(student.get_name());\n        }\n    }\n    return student_list;\n}\n\nstd::vector<std::string> ClassRegistrationSystem::get_all_major() const {\n    std::set<std::string> majors;\n    for (const auto& student : students) {\n        \n        majors.insert(student.get_major());\n    }\n    return std::vector<std::string>(majors.begin(), majors.end());\n}\n\nstd::string ClassRegistrationSystem::get_most_popular_class_in_major(const std::string& major) const {\n    std::unordered_map<std::string, int> class_count;\n\n    \n    for (const auto& student : students) {\n        if (student.get_major() == major) {\n            auto it = students_registration_classes.find(student.get_name());\n            if (it != students_registration_classes.end()) {\n                for (const auto& class_name : it->second) {\n                    class_count[class_name]++;\n                }\n            }\n        }\n    }\n\n    \n    std::string most_popular_class;\n    int max_count = 0;\n    for (const auto& [class_name, count] : class_count) {\n        if (count > max_count) {\n            most_popular_class = class_name;\n            max_count = count;\n        }\n    }\n\n    return most_popular_class;\n}\n\n",
  "Classroom": "\n#include <algorithm>\n#include <iomanip>\n#include <sstream>\n#include <stdexcept>\n#include <iostream>\n\n#include <string>\n#include <vector>\n#include <ctime>\n\nstruct Course {\n    std::string name;\n    std::string start_time;  \n    std::string end_time;    \n\n    bool operator==(const Course& other) const {\n        return name == other.name && start_time == other.start_time && end_time == other.end_time;\n    }\n};\n\nclass Classroom {\npublic:\n    explicit Classroom(int id);\n\n    void add_course(const Course& course);\n    void remove_course(const Course& course);\n    bool is_free_at(const std::string& check_time) const;\n    bool check_course_conflict(const Course& new_course) const;\n    bool has_course(const Course& course) const;\n\nprivate:\n    int id;\n    std::vector<Course> courses;\n\n    std::tm string_to_tm(const std::string& time_str) const;\n    std::time_t tm_to_time_t(const std::tm& tm) const;\n    bool is_time_conflict(const std::tm& start1, const std::tm& end1, const std::tm& start2, const std::tm& end2) const;\n};\n\n\nClassroom::Classroom(int id) : id(id) {}\n\nvoid Classroom::add_course(const Course& course) {\n    if (std::find(courses.begin(), courses.end(), course) == courses.end()) {\n        courses.push_back(course);\n    }\n}\n\nvoid Classroom::remove_course(const Course& course) {\n    auto it = std::find(courses.begin(), courses.end(), course);\n    if (it != courses.end()) {\n        courses.erase(it);\n    }\n}\n\nbool Classroom::is_free_at(const std::string& check_time) const {\n    std::tm check_tm = string_to_tm(check_time);\n\n    for (const auto& course : courses) {\n        std::tm start_tm = string_to_tm(course.start_time);\n        std::tm end_tm = string_to_tm(course.end_time);\n        std::time_t check_tt = tm_to_time_t(check_tm);\n        std::time_t start_tt = tm_to_time_t(start_tm);\n        std::time_t end_tt = tm_to_time_t(end_tm);\n\n        if (check_tt == -1 || start_tt == -1 || end_tt == -1) {\n            std::cerr << \"Time conversion failed\" << std::endl;\n            return false;\n        }\n\n        if (check_tt >= start_tt && check_tt <= end_tt) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool Classroom::check_course_conflict(const Course& new_course) const {\n    std::tm new_start_tm = string_to_tm(new_course.start_time);\n    std::tm new_end_tm = string_to_tm(new_course.end_time);\n\n    if (new_start_tm.tm_hour == -1 || new_end_tm.tm_hour == -1) {\n        std::cerr << \"Time conversion failed\" << std::endl;\n        return true; \n    }\n\n    for (const auto& course : courses) {\n        std::tm start_tm = string_to_tm(course.start_time);\n        std::tm end_tm = string_to_tm(course.end_time);\n\n        if (start_tm.tm_hour == -1 || end_tm.tm_hour == -1) {\n            std::cerr << \"Time conversion failed\" << std::endl;\n            return true; \n        }\n\n        if (is_time_conflict(start_tm, end_tm, new_start_tm, new_end_tm)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool Classroom::has_course(const Course& course) const {\n    return std::find(courses.begin(), courses.end(), course) != courses.end();\n}\n\nstd::tm Classroom::string_to_tm(const std::string& time_str) const {\n    std::tm tm = {};\n    std::istringstream ss(time_str);\n    ss >> std::get_time(&tm, \"%H:%M\");\n\n    \n    if (ss.fail()) {\n        throw std::invalid_argument(\"Invalid time format: \" + time_str);\n    }\n\n    \n    tm.tm_year = 120; \n    tm.tm_mon = 0;    \n    tm.tm_mday = 1;   \n\n    return tm;\n}\n\nstd::time_t Classroom::tm_to_time_t(const std::tm& tm) const {\n    std::tm tm_copy = tm;\n    std::time_t time_tt = std::mktime(&tm_copy);\n\n    \n    if (time_tt == -1) {\n        throw std::runtime_error(\"Failed to convert std::tm to std::time_t\");\n    }\n\n    return time_tt;\n}\n\nbool Classroom::is_time_conflict(const std::tm& start1, const std::tm& end1, const std::tm& start2, const std::tm& end2) const {\n    std::time_t t1_start = tm_to_time_t(start1);\n    std::time_t t1_end = tm_to_time_t(end1);\n    std::time_t t2_start = tm_to_time_t(start2);\n    std::time_t t2_end = tm_to_time_t(end2);\n\n    return (t1_start <= t2_end && t1_end >= t2_start);\n}\n",
  "CombinationCalculator": "#include <vector>\n#include <string>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nclass CombinationCalculator {\npublic:\n    explicit CombinationCalculator(const std::vector<std::string>& datas);\n\n    static int count(int n, int m);\n    static double count_all(int n);\n\n    std::vector<std::vector<std::string>> select(int m) const;\n    std::vector<std::vector<std::string>> select_all() const;\n\n    void _select(int dataIndex, std::vector<std::string>& resultList, int resultIndex, std::vector<std::vector<std::string>>& result) const;\n    std::vector<std::string> datas;\n};\n\nCombinationCalculator::CombinationCalculator(const std::vector<std::string>& datas)\n    : datas(datas) {}\n\nint CombinationCalculator::count(int n, int m) {\n    if (m == 0 || n == m) {\n        return 1;\n    }\n    return std::tgamma(n + 1) / (std::tgamma(m + 1) * std::tgamma(n - m + 1));\n}\n\ndouble CombinationCalculator::count_all(int n) {\n    if (n < 0) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n    if (n > 63) {\n        return std::numeric_limits<double>::infinity();\n    }\n    return (n != 63) ? (1 << n) - 1 : std::numeric_limits<double>::infinity();\n}\n\nstd::vector<std::vector<std::string>> CombinationCalculator::select(int m) const {\n    std::vector<std::vector<std::string>> result;\n    if (m < 0 || m > static_cast<int>(datas.size())) {\n        return result;\n    }\n    std::vector<std::string> resultList(m);\n    _select(0, resultList, 0, result);\n    return result;\n}\n\nstd::vector<std::vector<std::string>> CombinationCalculator::select_all() const {\n    std::vector<std::vector<std::string>> result;\n    for (int i = 1; i <= static_cast<int>(datas.size()); ++i) {\n        std::vector<std::vector<std::string>> combinations = select(i);\n        result.insert(result.end(), combinations.begin(), combinations.end());\n    }\n    return result;\n}\n\nvoid CombinationCalculator::_select(int dataIndex, std::vector<std::string>& resultList, int resultIndex, std::vector<std::vector<std::string>>& result) const {\n    if (resultIndex == resultList.size()) {\n        result.push_back(resultList);\n        return;\n    }\n\n    for (int i = dataIndex; i <= static_cast<int>(datas.size()) - (resultList.size() - resultIndex); ++i) {\n        resultList[resultIndex] = datas[i];\n        _select(i + 1, resultList, resultIndex + 1, result);\n    }\n}\n",
  "ComplexCalculator": "#include <complex>\n\nclass ComplexCalculator {\npublic:\n    static std::complex<double> add(const std::complex<double>& c1, const std::complex<double>& c2);\n\n    static std::complex<double> subtract(const std::complex<double>& c1, const std::complex<double>& c2);\n\n    static std::complex<double> multiply(const std::complex<double>& c1, const std::complex<double>& c2);\n\n    static std::complex<double> divide(const std::complex<double>& c1, const std::complex<double>& c2);\n};\n\nstd::complex<double> ComplexCalculator::add(const std::complex<double>& c1, const std::complex<double>& c2) {\n    double real = c1.real() + c2.real();\n    double imaginary = c1.imag() + c2.imag();\n    return std::complex<double>(real, imaginary);\n}\n\nstd::complex<double> ComplexCalculator::subtract(const std::complex<double>& c1, const std::complex<double>& c2) {\n    double real = c1.real() - c2.real();\n    double imaginary = c1.imag() - c2.imag();\n    return std::complex<double>(real, imaginary);\n}\n\nstd::complex<double> ComplexCalculator::multiply(const std::complex<double>& c1, const std::complex<double>& c2) {\n    double real = c1.real() * c2.real() - c1.imag() * c2.imag();\n    double imaginary = c1.real() * c2.imag() + c1.imag() * c2.real();\n    return std::complex<double>(real, imaginary);\n}\n\nstd::complex<double> ComplexCalculator::divide(const std::complex<double>& c1, const std::complex<double>& c2) {\n    double denominator = c2.real() * c2.real() + c2.imag() * c2.imag();\n    double real = (c1.real() * c2.real() + c1.imag() * c2.imag()) / denominator;\n    double imaginary = (c1.imag() * c2.real() - c1.real() * c2.imag()) / denominator;\n    return std::complex<double>(real, imaginary);\n}\n",
  "CookiesUtil": "\n#include <fstream>\n#include <sstream>\n#include <iostream>\n\n#include <string>\n#include <unordered_map>\n#include <nlohmann/json.hpp> \n\nclass CookiesUtil {\npublic:\n    explicit CookiesUtil(const std::string& cookiesFile);\n\n    void get_cookies(const nlohmann::json& response);\n    nlohmann::json load_cookies();\n    bool _save_cookies();\n    void set_cookies(nlohmann::json& request);\n\n    std::string cookies_file;\n    std::unordered_map<std::string, std::string> cookies;\n};\n\nusing json = nlohmann::json;\n\nCookiesUtil::CookiesUtil(const std::string& cookiesFile) : cookies_file(cookiesFile) {}\n\nvoid CookiesUtil::get_cookies(const nlohmann::json& response) {\n    if (response.contains(\"cookies\")) {\n        cookies = response[\"cookies\"].get<std::unordered_map<std::string, std::string>>();\n    }\n    _save_cookies();\n}\n\n\njson CookiesUtil::load_cookies() {\n    json cookiesData;\n    std::ifstream file(cookies_file);\n\n    if (file.is_open()) {\n        try {\n            file >> cookiesData;\n        }\n        catch (const std::exception& e) {\n            std::cerr << \"Error reading JSON file: \" << e.what() << std::endl;\n        }\n    }\n\n    return cookiesData;\n}\n\nbool CookiesUtil::_save_cookies() {\n    json cookiesJson(cookies);\n    std::ofstream file(cookies_file);\n\n    if (file.is_open()) {\n        try {\n            file << cookiesJson.dump(4); \n            return true;\n        }\n        catch (const std::exception& e) {\n            std::cerr << \"Error writing JSON file: \" << e.what() << std::endl;\n            return false;\n        }\n    }\n\n    return false;\n}\n\nvoid CookiesUtil::set_cookies(json& request) {\n    std::ostringstream oss;\n    for (const auto& [key, value] : cookies) {\n        if (oss.tellp() > 0) {\n            oss << \"; \";\n        }\n        oss << key << \"=\" << value;\n    }\n    request[\"cookies\"] = oss.str();\n}\n",
  "CSVProcessor": "#include <fstream>\n#include <sstream>\n#include <algorithm>\n\n#include <vector>\n#include <string>\n#include <utility>\n#include<algorithm>\n\nclass CSVProcessor {\npublic:\n    CSVProcessor();\n    std::pair<std::vector<std::string>, std::vector<std::vector<std::string>>> read_csv(const std::string& file_name);\n    int write_csv(const std::vector<std::vector<std::string>>& data, const std::string& file_name);\n    int process_csv_data(int N, const std::string& save_file_name);\n};\n\nCSVProcessor::CSVProcessor() {}\n\nstd::pair<std::vector<std::string>, std::vector<std::vector<std::string>>> CSVProcessor::read_csv(const std::string& file_name) {\n    std::ifstream file(file_name);\n    std::vector<std::string> title;\n    std::vector<std::vector<std::string>> data;\n\n    if (!file.is_open()) {\n        return { title, data };\n    }\n\n    std::string line;\n    std::getline(file, line);\n    std::istringstream s(line);\n    std::string item;\n    while (std::getline(s, item, ',')) {\n        title.push_back(item);\n    }\n\n    while (std::getline(file, line)) {\n        std::istringstream ss(line);\n        std::vector<std::string> row;\n        while (std::getline(ss, item, ',')) {\n            row.push_back(item);\n        }\n        data.push_back(row);\n    }\n\n    file.close();\n    return { title, data };\n}\n\nint CSVProcessor::write_csv(const std::vector<std::vector<std::string>>& data, const std::string& file_name) {\n    std::ofstream file(file_name);\n\n    if (!file.is_open()) {\n        return 0;\n    }\n\n    for (const auto& row : data) {\n        for (size_t i = 0; i < row.size(); ++i) {\n            file << row[i];\n            if (i < row.size() - 1) {\n                file << \",\";\n            }\n        }\n        file << \"\\n\";\n    }\n\n    file.close();\n    return 1;\n}\n\nint CSVProcessor::process_csv_data(int N, const std::string& save_file_name) {\n    auto [title, data] = read_csv(save_file_name);\n    if (N >= data[0].size()) {\n        return 0;\n    }\n\n    std::vector<std::string> column_data;\n    for (const auto& row : data) {\n        if (N < row.size()) {\n            std::string upper_str = row[N];\n            std::transform(upper_str.begin(), upper_str.end(), upper_str.begin(), ::toupper);\n            column_data.push_back(upper_str);\n        }\n    }\n\n    std::vector<std::vector<std::string>> new_data = { title, column_data };\n    return write_csv(new_data, save_file_name.substr(0, save_file_name.find_last_of('.')) + \"_process.csv\");\n}\n\n\n",
  "CurrencyConverter": "#include <unordered_map>\n#include <string>\n#include <vector>\n\nclass CurrencyConverter {\npublic:\n    CurrencyConverter();\n\n    double convert(double amount, const std::string& from_currency, const std::string& to_currency);\n    std::vector<std::string> get_supported_currencies();\n    bool add_currency_rate(const std::string& currency, double rate);\n    bool update_currency_rate(const std::string& currency, double new_rate);\n\n    std::unordered_map<std::string, double> rates;\n    std::vector<std::string> currency_order;\n};\n\nCurrencyConverter::CurrencyConverter() {\n    rates = {\n        {\"USD\", 1.0},\n        {\"EUR\", 0.85},\n        {\"GBP\", 0.72},\n        {\"JPY\", 110.15},\n        {\"CAD\", 1.23},\n        {\"AUD\", 1.34},\n        {\"CNY\", 6.40},\n    };\n\n    currency_order = { \"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CNY\" };\n}\n\ndouble CurrencyConverter::convert(double amount, const std::string& from_currency, const std::string& to_currency) {\n    if (from_currency == to_currency) {\n        return amount;\n    }\n\n    if (rates.find(from_currency) == rates.end() || rates.find(to_currency) == rates.end()) {\n        return false;\n    }\n\n    double from_rate = rates[from_currency];\n    double to_rate = rates[to_currency];\n\n    double converted_amount = (amount / from_rate) * to_rate;\n    return converted_amount;\n}\n\nstd::vector<std::string> CurrencyConverter::get_supported_currencies() {\n    return currency_order;\n}\n\nbool CurrencyConverter::add_currency_rate(const std::string& currency, double rate) {\n    if (rates.find(currency) != rates.end()) {\n        return false;\n    }\n    rates[currency] = rate;\n    currency_order.push_back(currency);\n    return true;\n}\n\nbool CurrencyConverter::update_currency_rate(const std::string& currency, double new_rate) {\n    if (rates.find(currency) == rates.end()) {\n        return false;\n    }\n    rates[currency] = new_rate;\n    return true;\n}\n",
  "DatabaseProcessor": "\n#include <stdexcept>\n\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <winsqlite/winsqlite3.h>\n\nclass DatabaseProcessor {\npublic:\n    explicit DatabaseProcessor(const std::string& database_name);\n\n    void create_table(const std::string& table_name, const std::string& key1, const std::string& key2);\n    void insert_into_database(const std::string& table_name, const std::vector<std::unordered_map<std::string, std::string>>& data);\n    std::vector<std::vector<std::string>> search_database(const std::string& table_name, const std::string& name);\n    void delete_from_database(const std::string& table_name, const std::string& name);\n\nprivate:\n    std::string database_name;\n    sqlite3* open_database();\n};\n\nDatabaseProcessor::DatabaseProcessor(const std::string& database_name)\n    : database_name(database_name) {}\n\nsqlite3* DatabaseProcessor::open_database() {\n    sqlite3* db;\n    if (sqlite3_open(database_name.c_str(), &db) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to open database\");\n    }\n    return db;\n}\n\nvoid DatabaseProcessor::create_table(const std::string& table_name, const std::string& key1, const std::string& key2) {\n    sqlite3* db = open_database();\n    std::string create_table_query = \"CREATE TABLE IF NOT EXISTS \" + table_name + \" (id INTEGER PRIMARY KEY, \" + key1 + \" TEXT, \" + key2 + \" INTEGER)\";\n    char* err_msg = nullptr;\n    if (sqlite3_exec(db, create_table_query.c_str(), nullptr, nullptr, &err_msg) != SQLITE_OK) {\n        std::string error_msg = \"Failed to create table: \" + std::string(err_msg);\n        sqlite3_free(err_msg);\n        sqlite3_close(db);\n        throw std::runtime_error(error_msg);\n    }\n    sqlite3_close(db);\n}\n\nvoid DatabaseProcessor::insert_into_database(const std::string& table_name, const std::vector<std::unordered_map<std::string, std::string>>& data) {\n    sqlite3* db = open_database();\n    sqlite3_stmt* stmt;\n    std::string insert_query = \"INSERT INTO \" + table_name + \" (name, age) VALUES (?, ?)\";\n    if (sqlite3_prepare_v2(db, insert_query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n        std::string error_msg = \"Failed to prepare statement: \" + std::string(sqlite3_errmsg(db));\n        sqlite3_close(db);\n        throw std::runtime_error(error_msg);\n    }\n\n    for (const auto& item : data) {\n        sqlite3_bind_text(stmt, 1, item.at(\"name\").c_str(), -1, SQLITE_STATIC);\n        sqlite3_bind_int(stmt, 2, std::stoi(item.at(\"age\")));\n\n        if (sqlite3_step(stmt) != SQLITE_DONE) {\n            std::string error_msg = \"Failed to execute statement: \" + std::string(sqlite3_errmsg(db));\n            sqlite3_finalize(stmt);\n            sqlite3_close(db);\n            throw std::runtime_error(error_msg);\n        }\n        sqlite3_reset(stmt);\n    }\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n}\n\nstd::vector<std::vector<std::string>> DatabaseProcessor::search_database(const std::string& table_name, const std::string& name) {\n    sqlite3* db;\n    sqlite3_stmt* stmt;\n    std::vector<std::vector<std::string>> result;\n\n    int rc = sqlite3_open(database_name.c_str(), &db);\n    if (rc != SQLITE_OK) {\n        sqlite3_close(db);\n        return result;\n    }\n\n    std::string query = \"SELECT * FROM \" + table_name + \" WHERE name = ?\";\n    rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n    if (rc != SQLITE_OK) {\n        sqlite3_close(db);\n        return result;\n    }\n\n    sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_STATIC);\n\n    while (sqlite3_step(stmt) == SQLITE_ROW) {\n        std::vector<std::string> row;\n        int column_count = sqlite3_column_count(stmt);\n        for (int i = 0; i < column_count; ++i) {\n            const unsigned char* text = sqlite3_column_text(stmt, i);\n            row.push_back(text ? std::string(reinterpret_cast<const char*>(text)) : std::string());\n        }\n        result.push_back(row);\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n    return result;\n}\n\n\nvoid DatabaseProcessor::delete_from_database(const std::string& table_name, const std::string& name) {\n    sqlite3* db = open_database();\n    sqlite3_stmt* stmt;\n    std::string delete_query = \"DELETE FROM \" + table_name + \" WHERE name = ?\";\n    if (sqlite3_prepare_v2(db, delete_query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n        std::string error_msg = \"Failed to prepare statement: \" + std::string(sqlite3_errmsg(db));\n        sqlite3_close(db);\n        throw std::runtime_error(error_msg);\n    }\n\n    sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_STATIC);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        std::string error_msg = \"Failed to execute statement: \" + std::string(sqlite3_errmsg(db));\n        sqlite3_finalize(stmt);\n        sqlite3_close(db);\n        throw std::runtime_error(error_msg);\n    }\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n}\n",
  "DataStatistics": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <stdexcept>\n\nclass DataStatistics {\npublic:\n    double mean(const std::vector<double>& data) const;\n\n    double median(std::vector<double> data) const;\n\n    std::vector<int> mode(const std::vector<int>& data) const;\n};\n\n\ndouble DataStatistics::mean(const std::vector<double>& data) const {\n    if (data.empty()) {\n        throw std::invalid_argument(\"Data vector is empty.\");\n    }\n    double sum = std::accumulate(data.begin(), data.end(), 0.0);\n    return std::round(sum / data.size() * 100) / 100; \n}\n\n\ndouble DataStatistics::median(std::vector<double> data) const {\n    if (data.empty()) {\n        throw std::invalid_argument(\"Data vector is empty.\");\n    }\n    std::sort(data.begin(), data.end());\n    size_t n = data.size();\n    if (n % 2 == 0) {\n        return std::round(((data[n / 2 - 1] + data[n / 2]) / 2) * 100) / 100; \n    }\n    else {\n        return data[n / 2];\n    }\n}\n\n\nstd::vector<int> DataStatistics::mode(const std::vector<int>& data) const {\n    if (data.empty()) {\n        throw std::invalid_argument(\"Data vector is empty.\");\n    }\n\n    std::map<int, int> count_map;\n    for (int num : data) {\n        ++count_map[num];\n    }\n\n    int max_count = 0;\n    for (const auto& pair : count_map) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    std::vector<int> modes;\n    for (const auto& pair : count_map) {\n        if (pair.second == max_count) {\n            modes.push_back(pair.first);\n        }\n    }\n\n    return modes;\n}\n",
  "DataStatistics2": "\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nclass DataStatistics2 {\npublic:\n    DataStatistics2(const std::vector<double>& data);\n\n    double get_sum() const;\n    double get_min() const;\n    double get_max() const;\n    double get_variance() const;\n    double get_std_deviation() const;\n    double get_correlation() const;\n\nprivate:\n    std::vector<double> data;\n};\n\nDataStatistics2::DataStatistics2(const std::vector<double>& data) : data(data) {}\n\ndouble DataStatistics2::get_sum() const {\n    return std::accumulate(data.begin(), data.end(), 0.0);\n}\n\ndouble DataStatistics2::get_min() const {\n    return *std::min_element(data.begin(), data.end());\n}\n\ndouble DataStatistics2::get_max() const {\n    return *std::max_element(data.begin(), data.end());\n}\n\ndouble DataStatistics2::get_variance() const {\n    double mean = get_sum() / data.size();\n    double variance = 0.0;\n    for (const auto& value : data) {\n        variance += std::pow(value - mean, 2);\n    }\n    variance /= data.size();\n    return std::round(variance * 100) / 100;  \n}\n\ndouble DataStatistics2::get_std_deviation() const {\n    double variance = get_variance();\n    double std_dev = std::sqrt(variance);\n    return std::round(std_dev * 100) / 100;  \n}\n\ndouble DataStatistics2::get_correlation() const {\n    if (data.size() < 2) return 1.0;  \n    double mean = get_sum() / data.size();\n    double sum_prod = 0.0, sum_sq = 0.0;\n    for (const auto& value : data) {\n        sum_prod += (value - mean) * (value - mean);\n        sum_sq += (value - mean) * (value - mean);\n    }\n    return sum_prod / sum_sq;\n}\n",
  "DataStatistics4": "#include <vector>\n#include <cmath>\n\nclass DataStatistics4 {\npublic:\n    static double correlation_coefficient(const std::vector<double>& data1, const std::vector<double>& data2);\n    static double skewness(const std::vector<double>& data);\n    static double kurtosis(const std::vector<double>& data);\n    static std::vector<double> pdf(const std::vector<double>& data, double mu, double sigma);\n};\n\nconst double pai = 3.141592653589793;\ndouble DataStatistics4::correlation_coefficient(const std::vector<double>& data1, const std::vector<double>& data2) {\n    size_t n = data1.size();\n    double mean1 = 0.0, mean2 = 0.0;\n\n    for (size_t i = 0; i < n; ++i) {\n        mean1 += data1[i];\n        mean2 += data2[i];\n    }\n    mean1 /= n;\n    mean2 /= n;\n\n    double numerator = 0.0, denominator1 = 0.0, denominator2 = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        double diff1 = data1[i] - mean1;\n        double diff2 = data2[i] - mean2;\n        numerator += diff1 * diff2;\n        denominator1 += diff1 * diff1;\n        denominator2 += diff2 * diff2;\n    }\n\n    double denominator = std::sqrt(denominator1) * std::sqrt(denominator2);\n    return (denominator != 0) ? (numerator / denominator) : 0;\n}\n\ndouble DataStatistics4::skewness(const std::vector<double>& data) {\n    size_t n = data.size();\n    double mean = 0.0;\n\n    for (double x : data) {\n        mean += x;\n    }\n    mean /= n;\n\n    double variance = 0.0;\n    for (double x : data) {\n        variance += (x - mean) * (x - mean);\n    }\n    variance /= n;\n\n    double std_deviation = std::sqrt(variance);\n\n    if (std_deviation == 0) {\n        return 0.0;\n    }\n\n    double skewness = 0.0;\n    for (double x : data) {\n        skewness += std::pow((x - mean), 3);\n    }\n\n    skewness *= static_cast<double>(n) / ((n - 1) * (n - 2) * std::pow(std_deviation, 3));\n    return skewness;\n}\n\ndouble DataStatistics4::kurtosis(const std::vector<double>& data) {\n    size_t n = data.size();\n    double mean = 0.0;\n\n    for (double x : data) {\n        mean += x;\n    }\n    mean /= n;\n\n    double variance = 0.0;\n    for (double x : data) {\n        variance += (x - mean) * (x - mean);\n    }\n    variance /= n;\n\n    double std_dev = std::sqrt(variance);\n\n    if (std_dev == 0) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n\n    double fourth_moment = 0.0;\n    for (double x : data) {\n        fourth_moment += std::pow((x - mean), 4);\n    }\n    fourth_moment /= n;\n\n    double kurtosis_value = (fourth_moment / std::pow(std_dev, 4)) - 3.0;\n    return kurtosis_value;\n}\n\nstd::vector<double> DataStatistics4::pdf(const std::vector<double>& data, double mu, double sigma) {\n    std::vector<double> pdf_values;\n    pdf_values.reserve(data.size());\n\n    for (double x : data) {\n        double value = (1 / (sigma * std::sqrt(2 * pai))) * std::exp(-0.5 * std::pow((x - mu) / sigma, 2));\n        pdf_values.push_back(value);\n    }\n\n    return pdf_values;\n}\n",
  "DecryptionUtils": "\n#include <cctype>\n#include <vector>\n\n#include <string>\n#include <vector>\n\nclass DecryptionUtils {\npublic:\n    DecryptionUtils(const std::string& key);\n\n    std::string caesar_decipher(const std::string& ciphertext, int shift);\n    std::string vigenere_decipher(const std::string& ciphertext);\n    std::string rail_fence_decipher(const std::string& encrypted_text, int rails);\n\nprivate:\n    std::string key_;\n};\n\nDecryptionUtils::DecryptionUtils(const std::string& key) : key_(key) {}\n\nstd::string DecryptionUtils::caesar_decipher(const std::string& ciphertext, int shift) {\n    shift = shift % 26; \n    std::string plaintext;\n    for (char c : ciphertext) {\n        if (std::isalpha(c)) {\n            char base = std::isupper(c) ? 'A' : 'a';\n            char shifted_char = (c - base - shift + 26) % 26 + base;\n            plaintext += shifted_char;\n        }\n        else {\n            plaintext += c;\n        }\n    }\n    return plaintext;\n}\n\nstd::string DecryptionUtils::vigenere_decipher(const std::string& ciphertext) {\n    std::string decrypted_text;\n    size_t key_length = key_.length();\n    size_t key_index = 0;\n\n    for (char c : ciphertext) {\n        if (std::isalpha(c)) {\n            int shift = std::tolower(key_[key_index % key_length]) - 'a';\n            char base = std::islower(c) ? 'a' : 'A';\n            char decrypted_char = (std::tolower(c) - 'a' - shift + 26) % 26 + 'a';\n            decrypted_text += std::isupper(c) ? std::toupper(decrypted_char) : decrypted_char;\n            ++key_index;\n        }\n        else {\n            decrypted_text += c;\n        }\n    }\n    return decrypted_text;\n}\n\nstd::string DecryptionUtils::rail_fence_decipher(const std::string& encrypted_text, int rails) {\n    std::string plain_text;\n    size_t n = encrypted_text.length();\n    if (rails <= 1) return encrypted_text;\n\n    std::vector<std::string> fence(rails, std::string(n, '\\n'));\n\n    int direction = -1;\n    int row = 0;\n    int col = 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (row == 0 || row == rails - 1) {\n            direction = -direction;\n        }\n        fence[row][col++] = '*';\n        row += direction;\n    }\n\n    size_t index = 0;\n    for (int r = 0; r < rails; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (fence[r][c] == '*') {\n                fence[r][c] = encrypted_text[index++];\n            }\n        }\n    }\n\n    direction = -1;\n    row = 0;\n    col = 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (row == 0 || row == rails - 1) {\n            direction = -direction;\n        }\n        plain_text += fence[row][col++];\n        row += direction;\n    }\n\n    return plain_text;\n}\n",
  "DiscountStrategy": "#include <map>\n#include <vector>\n#include <string>\n\nclass DiscountStrategy {\npublic:\n    enum PromoType {\n        FidelityPromo,\n        BulkItemPromo,\n        LargeOrderPromo,\n        NoPromo\n    };\n\n    DiscountStrategy(const std::map<std::string, double>& customer,\n        const std::vector<std::map<std::string, double>>& cart,\n        PromoType promo = NoPromo);\n\n    double total() const;\n    double due() const;\n    double promotion(const DiscountStrategy& order) const;\n\nprivate:\n    std::map<std::string, double> customer_;\n    std::vector<std::map<std::string, double>> cart_;\n    PromoType promo_;\n\n    double fidelity_discount() const;\n    double bulk_item_discount() const;\n    double large_order_discount() const;\n};\n\n\nDiscountStrategy::DiscountStrategy(const std::map<std::string, double>& customer,\n    const std::vector<std::map<std::string, double>>& cart,\n    PromoType promo)\n    : customer_(customer), cart_(cart), promo_(promo) {}\n\ndouble DiscountStrategy::total() const {\n    double total = 0.0;\n    for (const auto& item : cart_) {\n        total += item.at(\"quantity\") * item.at(\"price\");\n    }\n    return total;\n}\n\ndouble DiscountStrategy::due() const {\n    return total() - promotion(*this);\n}\n\ndouble DiscountStrategy::promotion(const DiscountStrategy& order) const {\n    switch (promo_) {\n    case FidelityPromo:\n        return fidelity_discount();\n    case BulkItemPromo:\n        return bulk_item_discount();\n    case LargeOrderPromo:\n        return large_order_discount();\n    default:\n        return 0.0;\n    }\n}\n\ndouble DiscountStrategy::fidelity_discount() const {\n    double total = 0.0;\n    double fidelity = customer_.at(\"fidelity\");\n    if (fidelity >= 1000.0) {\n        total = 0.05 * this->total(); \n    }\n    return total;\n}\n\ndouble DiscountStrategy::bulk_item_discount() const {\n    double discount = 0.0;\n    for (const auto& item : cart_) {\n        if (item.at(\"quantity\") >= 20) {\n            discount += item.at(\"quantity\") * item.at(\"price\") * 0.1; \n        }\n    }\n    return discount;\n}\n\ndouble DiscountStrategy::large_order_discount() const {\n    int num_items = cart_.size();\n    double discount = 0.0;\n    if (num_items >= 10) {\n        discount = 0.07 * total(); \n    }\n    return discount;\n}\n",
  "EightPuzzle": "\n#include <queue>\n#include <algorithm>\n\n#include <vector>\n#include <string>\n\nclass EightPuzzle {\npublic:\n    EightPuzzle(const std::vector<std::vector<int>>& initial_state);\n    EightPuzzle(); \n\n    std::pair<int, int> find_blank(const std::vector<std::vector<int>>& state) const;\n    std::vector<std::vector<int>> move(const std::vector<std::vector<int>>& state, const std::string& direction) const;\n    std::vector<std::string> get_possible_moves(const std::vector<std::vector<int>>& state) const;\n    std::vector<std::string> solve();\n    EightPuzzle operator = (const std::vector<std::vector<int>>& initial_state);\n\nprivate:\n    std::vector<std::vector<int>> initialState;\n    const std::vector<std::vector<int>> goalState = { {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n};\n\nEightPuzzle::EightPuzzle() : initialState({}) {}\n\nEightPuzzle::EightPuzzle(const std::vector<std::vector<int>>& initial_state) : initialState(initial_state) {}\n\nstd::pair<int, int> EightPuzzle::find_blank(const std::vector<std::vector<int>>& state) const {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (state[i][j] == 0) {\n                return { i, j };\n            }\n        }\n    }\n    return { -1, -1 };  \n}\n\nstd::vector<std::vector<int>> EightPuzzle::move(const std::vector<std::vector<int>>& state, const std::string& direction) const {\n    auto [i, j] = find_blank(state);\n    std::vector<std::vector<int>> newState = state;\n\n    if (direction == \"up\" && i > 0) {\n        std::swap(newState[i][j], newState[i - 1][j]);\n    }\n    else if (direction == \"down\" && i < 2) {\n        std::swap(newState[i][j], newState[i + 1][j]);\n    }\n    else if (direction == \"left\" && j > 0) {\n        std::swap(newState[i][j], newState[i][j - 1]);\n    }\n    else if (direction == \"right\" && j < 2) {\n        std::swap(newState[i][j], newState[i][j + 1]);\n    }\n\n    return newState;\n}\n\nstd::vector<std::string> EightPuzzle::get_possible_moves(const std::vector<std::vector<int>>& state) const {\n    std::vector<std::string> moves;\n    auto [i, j] = find_blank(state);\n\n    if (i > 0) {\n        moves.push_back(\"up\");\n    }\n    if (i < 2) {\n        moves.push_back(\"down\");\n    }\n    if (j > 0) {\n        moves.push_back(\"left\");\n    }\n    if (j < 2) {\n        moves.push_back(\"right\");\n    }\n\n    return moves;\n}\n\nstd::vector<std::string> EightPuzzle::solve() {\n    std::queue<std::pair<std::vector<std::vector<int>>, std::vector<std::string>>> openList;\n    std::vector<std::vector<std::vector<int>>> closedList;\n\n    openList.push({ initialState, {} });\n\n    while (!openList.empty()) {\n        auto [currentState, path] = openList.front();\n        openList.pop();\n        closedList.push_back(currentState);\n\n        if (currentState == goalState) {\n            return path;\n        }\n\n        for (const auto& move : get_possible_moves(currentState)) {\n            auto newState = this->move(currentState, move);\n            if (std::find(closedList.begin(), closedList.end(), newState) == closedList.end()) {\n                std::vector<std::string> newPath = path;\n                newPath.push_back(move);\n                openList.push({ newState, newPath });\n            }\n        }\n    }\n\n    return {};\n}\n\n\nEightPuzzle EightPuzzle::operator=(const std::vector<std::vector<int>>& initial_state)\n{\n    return EightPuzzle(initial_state);\n}\n",
  "EmailClient": "\n#include <iostream>\n#include <sstream>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <ctime>\n\nclass EmailClient {\npublic:\n    EmailClient(const std::string& addr, int capacity);\n    bool send_to(EmailClient& recv, const std::string& content, int size);\n    std::map<std::string, std::string> fetch();\n    bool is_full_with_one_more_email(int size);\n    int get_occupied_size();\n    void clear_inbox(int size);\n    std::string addr;\n    int capacity;\n    std::vector<std::map<std::string, std::string>> inbox;\n\n    std::string get_current_time();\n};\n\n\nEmailClient::EmailClient(const std::string& addr, int capacity)\n    : addr(addr), capacity(capacity) {}\n\n\nstd::string EmailClient::get_current_time() {\n    time_t now = time(nullptr);\n    tm* ltm = localtime(&now);\n    std::ostringstream oss;\n    oss << 1900 + ltm->tm_year << \"-\"\n        << 1 + ltm->tm_mon << \"-\"\n        << ltm->tm_mday << \" \"\n        << ltm->tm_hour << \":\"\n        << ltm->tm_min << \":\"\n        << ltm->tm_sec;\n    return oss.str();\n}\n\n\nbool EmailClient::send_to(EmailClient& recv, const std::string& content, int size) {\n    if (!recv.is_full_with_one_more_email(size)) {\n        std::map<std::string, std::string> email = {\n            {\"sender\", this->addr},\n            {\"receiver\", recv.addr},\n            {\"content\", content},\n            {\"size\", std::to_string(size)},\n            {\"time\", get_current_time()},\n            {\"state\", \"unread\"}\n        };\n        recv.inbox.push_back(email);\n        return true;\n    }\n    else {\n        this->clear_inbox(size);\n        return false;\n    }\n}\n\n\nstd::map<std::string, std::string> EmailClient::fetch() {\n    if (inbox.empty()) {\n        return {};\n    }\n    for (auto& email : inbox) {\n        if (email[\"state\"] == \"unread\") {\n            email[\"state\"] = \"read\";\n            return email;\n        }\n    }\n    return {};\n}\n\n\nbool EmailClient::is_full_with_one_more_email(int size) {\n    int occupied_size = get_occupied_size();\n    return occupied_size + size > capacity;\n}\n\n\nint EmailClient::get_occupied_size() {\n    int occupied_size = 0;\n    for (const auto& email : inbox) {\n        occupied_size += std::stoi(email.at(\"size\"));\n    }\n    return occupied_size;\n}\n\n\nvoid EmailClient::clear_inbox(int size) {\n    if (addr.empty()) return;\n\n    int freed_space = 0;\n    while (freed_space < size && !inbox.empty()) {\n        freed_space += std::stoi(inbox.front()[\"size\"]);\n        inbox.erase(inbox.begin());\n    }\n}\n\n",
  "EncryptionUtils": "\n#include <cctype>\n#include <stdexcept>\n\n#include <string>\n\nclass EncryptionUtils {\npublic:\n    EncryptionUtils(const std::string& key);\n    std::string caesar_cipher(const std::string& plaintext, int shift) const;\n    std::string vigenere_cipher(const std::string& plain_text) const;\n    std::string rail_fence_cipher(const std::string& plain_text, int rails) const;\n\nprivate:\n    std::string key;\n};\n\n\n\nEncryptionUtils::EncryptionUtils(const std::string& key) : key(key) {}\n\n\nstd::string EncryptionUtils::caesar_cipher(const std::string& plaintext, int shift) const {\n    std::string ciphertext;\n    for (char ch : plaintext) {\n        if (std::isalpha(ch)) {\n            int ascii_offset = std::isupper(ch) ? 65 : 97;\n            char shifted_char = static_cast<char>((std::tolower(ch) - 'a' + shift) % 26 + ascii_offset);\n            ciphertext += shifted_char;\n        }\n        else {\n            ciphertext += ch;\n        }\n    }\n    return ciphertext;\n}\n\n\nstd::string EncryptionUtils::vigenere_cipher(const std::string& plain_text) const {\n    std::string encrypted_text;\n    size_t key_index = 0;\n    for (char ch : plain_text) {\n        if (std::isalpha(ch)) {\n            int shift = std::tolower(key[key_index % key.length()]) - 'a';\n            char encrypted_char = static_cast<char>((std::tolower(ch) - 'a' + shift) % 26 + 'a');\n            encrypted_text += std::isupper(ch) ? std::toupper(encrypted_char) : encrypted_char;\n            key_index++;\n        }\n        else {\n            encrypted_text += ch;\n        }\n    }\n    return encrypted_text;\n}\n\n\nstd::string EncryptionUtils::rail_fence_cipher(const std::string& plain_text, int rails) const {\n    if (rails <= 0) {\n        throw std::invalid_argument(\"Rails must be greater than zero.\");\n    }\n    const int N = 101;\n    std::string fence[N];\n    int direction = -1;\n    int row = 0;\n\n    for (char ch : plain_text) {\n        if (row == 0 || row == rails - 1) {\n            direction = -direction;\n        }\n\n        fence[row] += ch;\n        row += direction;\n    }\n\n    std::string encrypted_text;\n    for (int i = 0; i < rails; ++i) {\n        encrypted_text += fence[i];\n    }\n\n    return encrypted_text;\n}\n",
  "ExcelProcessor": "\n#include <OpenXLSX.hpp>\n#include <iostream>\n#include <variant>\n#include <string>\n#include <vector>\n\n#include <string>\n#include <vector>\n#include <variant>\n\nclass ExcelProcessor {\npublic:\n    ExcelProcessor() = default;\n\n    std::vector<std::vector<std::variant<std::string, int>>> read_excel(const std::string& file_name);\n\n    int write_excel(const std::vector<std::vector<std::variant<std::string, int>>>& data, const std::string& file_name);\n\n    std::pair<int, std::string> process_excel_data(size_t N, const std::string& save_file_name);\n};\n\nstd::vector<std::vector<std::variant<std::string, int>>> ExcelProcessor::read_excel(const std::string& file_name) {\n    std::vector<std::vector<std::variant<std::string, int>>> data;\n    try {\n        OpenXLSX::XLDocument doc;\n        doc.open(file_name);\n        auto sheet = doc.workbook().worksheet(\"Sheet1\");\n\n        unsigned int rowCount = sheet.rowCount();\n        unsigned int colCount = sheet.columnCount();\n\n        for (unsigned int rowIndex = 1; rowIndex <= rowCount; ++rowIndex) {\n            std::vector<std::variant<std::string, int>> rowData;\n            for (unsigned int colIndex = 1; colIndex <= colCount; ++colIndex) {\n                auto cell = sheet.cell(rowIndex, colIndex);\n\n                if (cell.value().type() == OpenXLSX::XLValueType::Integer) {\n                    rowData.emplace_back(static_cast<int>(cell.value().get<int64_t>()));\n                }\n                else if (cell.value().type() == OpenXLSX::XLValueType::String) {\n                    rowData.emplace_back(cell.value().get<std::string>());\n                }\n            }\n            data.push_back(rowData);\n        }\n        doc.close();\n    }\n    catch (...) {\n        return {};\n    }\n    return data;\n}\n\nint ExcelProcessor::write_excel(const std::vector<std::vector<std::variant<std::string, int>>>& data, const std::string& file_name) {\n    try {\n        OpenXLSX::XLDocument doc;\n        doc.create(file_name);\n        auto sheet = doc.workbook().worksheet(\"Sheet1\");\n\n        for (unsigned int rowIndex = 0; rowIndex < data.size(); ++rowIndex) {\n            for (unsigned int colIndex = 0; colIndex < data[rowIndex].size(); ++colIndex) {\n                auto cell = sheet.cell(rowIndex + 1, colIndex + 1);\n                if (std::holds_alternative<int>(data[rowIndex][colIndex])) {\n                    cell.value() = std::get<int>(data[rowIndex][colIndex]);\n                }\n                else {\n                    cell.value() = std::get<std::string>(data[rowIndex][colIndex]);\n                }\n            }\n        }\n        doc.save();\n        doc.close();\n        return 1;\n    }\n    catch (...) {\n        return 0;\n    }\n}\n\nstd::pair<int, std::string> ExcelProcessor::process_excel_data(size_t N, const std::string& save_file_name) {\n    auto data = read_excel(save_file_name);\n    if (data.empty() || N >= data[0].size()) {\n        return { 0, \"\" };\n    }\n\n    std::vector<std::vector<std::variant<std::string, int>>> new_data;\n    for (const auto& row : data) {\n        std::vector<std::variant<std::string, int>> new_row(row);\n        if (auto value = std::get_if<std::string>(&row[N])) {\n            if (!std::isdigit((*value)[0])) {\n                std::string now = *value;\n                for (int i = 0; i < now.size(); ++i)\n                {\n                    if (now[i] > 'Z')\n                    {\n                        now[i] -= 32;\n                    }\n                }\n                new_row.emplace_back(now);\n            }\n            else {\n                new_row.emplace_back(value->substr(0, 1));\n            }\n        }\n        else {\n            new_row.emplace_back(std::get<int>(row[N]));\n        }\n        new_data.push_back(new_row);\n    }\n\n    std::string new_file_name = save_file_name.substr(0, save_file_name.find_last_of('.')) + \"_process.xlsx\";\n    int success = write_excel(new_data, new_file_name);\n    return { success, new_file_name };\n}\n",
  "ExpressionCalculator": "\n#include <sstream>\n#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stdexcept>\n#include <cctype>\n\n#include <deque>\n#include <string>\n#include <stdexcept>\n#include <regex>\n#include <cctype>\n#include <unordered_map>\n#include <vector>\n\nclass ExpressionCalculator {\npublic:\n    ExpressionCalculator();\n\n    double calculate(const std::string& expression);\n    void prepare(const std::string& expression);\n    static bool is_operator(const std::string& c);\n    bool compare(const std::string& cur, const std::string& peek);\n    static double _calculate(const std::string& first_value, const std::string& second_value, const std::string& current_op);\n    static std::string transform(const std::string& expression);\n\n    std::deque<std::string> postfix_stack;\n\nprivate:\n    std::vector<int> operat_priority;\n};\n\nExpressionCalculator::ExpressionCalculator() : operat_priority{ 0, 3, 2, 1, -1, 1, 0, 2 } {}\n\ndouble ExpressionCalculator::calculate(const std::string& expression) {\n    prepare(transform(expression));\n\n    std::deque<std::string> result_stack;\n    std::deque<std::string> reversed_postfix_stack = postfix_stack;\n    std::reverse(reversed_postfix_stack.begin(), reversed_postfix_stack.end());\n\n    while (!reversed_postfix_stack.empty()) {\n        std::string current_op = reversed_postfix_stack.back();\n        reversed_postfix_stack.pop_back();\n\n        if (!is_operator(current_op)) {\n            current_op = std::regex_replace(current_op, std::regex(\"~\"), \"-\");\n            result_stack.push_back(current_op);\n        }\n        else {\n            std::string second_value = result_stack.back();\n            result_stack.pop_back();\n            std::string first_value = result_stack.back();\n            result_stack.pop_back();\n\n            first_value = std::regex_replace(first_value, std::regex(\"~\"), \"-\");\n            second_value = std::regex_replace(second_value, std::regex(\"~\"), \"-\");\n\n            double temp_result = _calculate(first_value, second_value, current_op);\n            result_stack.push_back(std::to_string(temp_result));\n        }\n    }\n\n    std::string result_str = \"\";\n    for (const auto& val : result_stack) {\n        result_str += val + \"*\";\n    }\n    result_str.pop_back(); \n    return std::stod(result_str); \n}\n\nvoid ExpressionCalculator::prepare(const std::string& expression) {\n    std::deque<std::string> op_stack{ \",\" };\n    std::string arr = expression;\n    size_t current_index = 0;\n    size_t count = 0;\n    postfix_stack.clear();\n    for (size_t i = 0; i < arr.length(); ++i) {\n        std::string current_op(1, arr[i]);\n\n        if (is_operator(current_op)) {\n            if (count > 0) {\n                postfix_stack.push_back(arr.substr(current_index, count));\n            }\n            std::string peek_op = op_stack.back();\n\n            if (current_op == \")\") {\n                while (op_stack.back() != \"(\") {\n                    postfix_stack.push_back(op_stack.back());\n                    op_stack.pop_back();\n                }\n                op_stack.pop_back();\n            }\n            else {\n                while (current_op != \"(\" && peek_op != \",\" && compare(current_op, peek_op)) {\n                    postfix_stack.push_back(op_stack.back());\n                    op_stack.pop_back();\n                    peek_op = op_stack.back();\n                }\n                op_stack.push_back(current_op);\n            }\n\n            count = 0;\n            current_index = i + 1;\n        }\n        else {\n            ++count;\n        }\n    }\n\n    if (count > 1 || (count == 1 && !is_operator(arr.substr(current_index, count)))) {\n        postfix_stack.push_back(arr.substr(current_index, count));\n    }\n\n    while (op_stack.back() != \",\") {\n        postfix_stack.push_back(op_stack.back());\n        op_stack.pop_back();\n    }\n}\n\nbool ExpressionCalculator::is_operator(const std::string& c) {\n    static const std::unordered_map<std::string, bool> operators{\n        {\"+\", true}, {\"-\", true}, {\"*\", true}, {\"/\", true}, {\"(\", true}, {\")\", true}, {\"%\", true}\n    };\n    return operators.find(c) != operators.end();\n}\n\nbool ExpressionCalculator::compare(const std::string& cur, const std::string& peek) {\n    std::string cur_op = cur == \"%\" ? \"/\" : cur;\n    std::string peek_op = peek == \"%\" ? \"/\" : peek;\n    return operat_priority[peek_op[0] - 40] >= operat_priority[cur_op[0] - 40];\n}\n\ndouble ExpressionCalculator::_calculate(const std::string& first_value, const std::string& second_value, const std::string& current_op) {\n    double f = std::stod(first_value);\n    double s = std::stod(second_value);\n\n    if (current_op == \"+\") return f + s;\n    if (current_op == \"-\") return f - s;\n    if (current_op == \"*\") return f * s;\n    if (current_op == \"/\") return f / s;\n    if (current_op == \"%\") return std::fmod(f, s);\n\n    throw std::invalid_argument(\"Unexpected operator: \" + current_op);\n}\n\nstd::string ExpressionCalculator::transform(const std::string& expression) {\n    std::string expr = std::regex_replace(expression, std::regex(\"\\\\s+\"), \"\");\n    expr = std::regex_replace(expr, std::regex(\"=$\"), \"\");\n\n    for (size_t i = 0; i < expr.length(); ++i) {\n        if (expr[i] == '-') {\n            if (i == 0) {\n                expr[i] = '~';\n            }\n            else {\n                char prev_c = expr[i - 1];\n                if (prev_c == '+' || prev_c == '-' || prev_c == '*' || prev_c == '/' || prev_c == '(' || prev_c == 'E' || prev_c == 'e') {\n                    expr[i] = '~';\n                }\n            }\n        }\n    }\n\n    if (expr[0] == '~' && expr.length() > 1 && expr[1] == '(') {\n        expr[0] = '-';\n        return \"0\" + expr;\n    }\n    else {\n        return expr;\n    }\n}\n",
  "FitnessTracker": "#include <string>\n#include <vector>\n#include <unordered_map>\n#include <cmath>\nclass FitnessTracker {\npublic:\n    FitnessTracker(double height, double weight, int age, const std::string& sex);\n    double get_BMI() const;\n    int condition_judge() const;\n    double calculate_calorie_intake() const;\n\nprivate:\n    double height;\n    double weight;\n    int age;\n    std::string sex;\n    static const std::unordered_map<std::string, std::vector<double>> BMI_std;\n};\n\n\nconst std::unordered_map<std::string, std::vector<double>> FitnessTracker::BMI_std = {\n    {\"male\", {20.0, 25.0}},\n    {\"female\", {19.0, 24.0}}\n};\n\nFitnessTracker::FitnessTracker(double height, double weight, int age, const std::string& sex)\n    : height(height), weight(weight), age(age), sex(sex) {}\n\ndouble FitnessTracker::get_BMI() const {\n    return weight / (height * height);\n}\n\nint FitnessTracker::condition_judge() const {\n    double BMI = get_BMI();\n    const auto& BMI_range = BMI_std.at(sex);\n    if (BMI > BMI_range[1]) {\n        \n        return 1;\n    }\n    else if (BMI < BMI_range[0]) {\n        \n        return -1;\n    }\n    else {\n        \n        return 0;\n    }\n}\n\ndouble FitnessTracker::calculate_calorie_intake() const {\n    double BMR;\n    if (sex == \"male\") {\n        BMR = 10 * weight + 6.25 * height - 5 * age + 5;\n    }\n    else {\n        BMR = 10 * weight + 6.25 * height - 5 * age - 161;\n    }\n\n    int condition = condition_judge();\n    double calorie_intake;\n    if (condition == 1) {\n        calorie_intake = BMR * 1.2;  \n    }\n    else if (condition == -1) {\n        calorie_intake = BMR * 1.6;  \n    }\n    else {\n        calorie_intake = BMR * 1.4;  \n    }\n    return calorie_intake;\n}\n",
  "GomokuGame": "#include <vector>\n#include <optional>\n\nclass GomokuGame {\npublic:\n    explicit GomokuGame(int board_size);\n    bool make_move(int row, int col);\n    std::optional<char> check_winner() const;\n    std::vector<std::vector<char>> getBoard() const;\n    bool _check_five_in_a_row(int row, int col, std::pair<int, int> direction) const;\n    int board_size;\n    std::vector<std::vector<char>> board;\n    char current_player;\n};\n\nGomokuGame::GomokuGame(int board_size)\n    : board_size(board_size),\n    board(board_size, std::vector<char>(board_size, ' ')),\n    current_player('X')\n{}\n\nbool GomokuGame::make_move(int row, int col) {\n    if (board[row][col] == ' ') {\n        board[row][col] = current_player;\n        current_player = (current_player == 'X') ? 'O' : 'X';\n        return true;\n    }\n    return false;\n}\n\nstd::optional<char> GomokuGame::check_winner() const {\n    const std::vector<std::pair<int, int>> directions = { {0, 1}, {1, 0}, {1, 1}, {1, -1} };\n    for (int row = 0; row < board_size; ++row) {\n        for (int col = 0; col < board_size; ++col) {\n            if (board[row][col] != ' ') {\n                for (const auto& direction : directions) {\n                    if (_check_five_in_a_row(row, col, direction)) {\n                        return board[row][col];\n                    }\n                }\n            }\n        }\n    }\n    return std::nullopt;\n}\n\nstd::vector<std::vector<char>> GomokuGame::getBoard() const {\n    return board;\n}\n\nbool GomokuGame::_check_five_in_a_row(int row, int col, std::pair<int, int> direction) const {\n    int dx = direction.first;\n    int dy = direction.second;\n    int count = 1;\n    char symbol = board[row][col];\n    for (int i = 1; i < 5; ++i) {\n        int new_row = row + dx * i;\n        int new_col = col + dy * i;\n        if (!(0 <= new_row && new_row < board_size && 0 <= new_col && new_col < board_size)) {\n            return false;\n        }\n        if (board[new_row][new_col] != symbol) {\n            return false;\n        }\n        ++count;\n    }\n    return count == 5;\n}\n",
  "Hotel": "#include <string>\n#include <unordered_map>\n\nclass Hotel {\npublic:\n    Hotel(const std::string& name, const std::unordered_map<std::string, int>& rooms);\n\n    std::string book_room(const std::string& room_type, int room_number, const std::string& name);\n    bool check_in(const std::string& room_type, int room_number, const std::string& name);\n    void check_out(const std::string& room_type, int room_number);\n    int get_available_rooms(const std::string& room_type) const;\n    std::string name;\n    std::unordered_map<std::string, int> available_rooms;\n    std::unordered_map<std::string, std::unordered_map<std::string, int>> booked_rooms;\n};\n\nHotel::Hotel(const std::string& name, const std::unordered_map<std::string, int>& rooms)\n    : name(name), available_rooms(rooms) {}\n\nstd::string Hotel::book_room(const std::string& room_type, int room_number, const std::string& name) {\n    if (available_rooms.find(room_type) == available_rooms.end()) {\n        return \"False.\";\n    }\n\n    if (room_number <= available_rooms[room_type]) {\n        if (booked_rooms.find(room_type) == booked_rooms.end()) {\n            booked_rooms[room_type] = {};\n        }\n        booked_rooms[room_type][name] = room_number;\n        available_rooms[room_type] -= room_number;\n        return \"Success!\";\n    }\n    else if (available_rooms[room_type] != 0) {\n        return std::to_string(available_rooms[room_type]);\n    }\n    else {\n        return \"False.\";\n    }\n}\n\nbool Hotel::check_in(const std::string& room_type, int room_number, const std::string& name) {\n    if (booked_rooms.find(room_type) == booked_rooms.end()) {\n        return false;\n    }\n\n    if (booked_rooms[room_type].find(name) != booked_rooms[room_type].end()) {\n        if (room_number > booked_rooms[room_type][name]) {\n            return false;\n        }\n        else if (room_number == booked_rooms[room_type][name]) {\n            booked_rooms[room_type].erase(name);\n        }\n        else {\n            booked_rooms[room_type][name] -= room_number;\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid Hotel::check_out(const std::string& room_type, int room_number) {\n    if (available_rooms.find(room_type) != available_rooms.end()) {\n        available_rooms[room_type] += room_number;\n    }\n    else {\n        available_rooms[room_type] = room_number;\n    }\n}\n\nint Hotel::get_available_rooms(const std::string& room_type) const {\n    auto it = available_rooms.find(room_type);\n    if (it != available_rooms.end()) {\n        return it->second;\n    }\n    return 0;\n}\n",
  "HRManagementSystem": "#include <string>\n#include <map>\n#include <variant>\n#include <optional>\n#include<unordered_map>\n\nclass HRManagementSystem {\npublic:\n    HRManagementSystem();\n    bool add_employee(int employee_id, const std::string& name, const std::string& position, const std::string& department, int salary);\n    bool remove_employee(int employee_id);\n    bool update_employee(int employee_id, const std::unordered_map<std::string, std::variant<std::string, int>>& employee_info);\n    std::optional<std::unordered_map<std::string, std::variant<std::string, int>>> get_employee(int employee_id) const;\n    std::unordered_map<int, std::unordered_map<std::string, std::variant<std::string, int>>> employees;\n    std::unordered_map<int, std::unordered_map<std::string, std::variant<std::string, int>>> list_employees() const;\n};\n\nHRManagementSystem::HRManagementSystem() : employees() {}\n\nbool HRManagementSystem::add_employee(int employee_id, const std::string& name, const std::string& position, const std::string& department, int salary) {\n    if (employees.find(employee_id) != employees.end()) {\n        return false;\n    }\n    else {\n        employees[employee_id] = {\n            {\"name\", name},\n            {\"position\", position},\n            {\"department\", department},\n            {\"salary\", salary}\n        };\n        return true;\n    }\n}\n\nbool HRManagementSystem::remove_employee(int employee_id) {\n    auto it = employees.find(employee_id);\n    if (it != employees.end()) {\n        employees.erase(it);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nbool HRManagementSystem::update_employee(int employee_id, const std::unordered_map<std::string, std::variant<std::string, int>>& employee_info) {\n    auto employee_it = employees.find(employee_id);\n    if (employee_it == employees.end()) {\n        return false;\n    }\n\n    for (const auto& [key, value] : employee_info) {\n        if (employee_it->second.find(key) == employee_it->second.end()) {\n            return false;\n        }\n    }\n\n    for (const auto& [key, value] : employee_info) {\n        employee_it->second[key] = value;\n    }\n\n    return true;\n}\n\nstd::optional<std::unordered_map<std::string, std::variant<std::string, int>>> HRManagementSystem::get_employee(int employee_id) const {\n    auto it = employees.find(employee_id);\n    if (it != employees.end()) {\n        return it->second;\n    }\n    return std::nullopt;\n}\n\nstd::unordered_map<int, std::unordered_map<std::string, std::variant<std::string, int>>> HRManagementSystem::list_employees() const {\n    std::unordered_map<int, std::unordered_map<std::string, std::variant<std::string, int>>> employee_data;\n\n    for (const auto& [employee_id, employee_info] : employees) {\n        std::unordered_map<std::string, std::variant<std::string, int>> employee_details;\n        employee_details[\"employee_ID\"] = employee_id;\n        for (const auto& [key, value] : employee_info) {\n            employee_details[key] = value;\n        }\n        employee_data[employee_id] = employee_details;\n    }\n\n    return employee_data;\n}\n\n",
  "Interpolation": "#include <vector>\n\nclass Interpolation {\npublic:\n    Interpolation() = default;\n\n    \n    static std::vector<double> interpolate_1d(const std::vector<double>& x,\n        const std::vector<double>& y,\n        const std::vector<double>& x_interp);\n\n    \n    static std::vector<double> interpolate_2d(const std::vector<double>& x,\n        const std::vector<double>& y,\n        const std::vector<std::vector<double>>& z,\n        const std::vector<double>& x_interp,\n        const std::vector<double>& y_interp);\n};\n\nstd::vector<double> Interpolation::interpolate_1d(const std::vector<double>& x,\n    const std::vector<double>& y,\n    const std::vector<double>& x_interp) {\n    std::vector<double> y_interp;\n    for (double xi : x_interp) {\n        for (size_t i = 0; i < x.size() - 1; ++i) {\n            if (x[i] <= xi && xi <= x[i + 1]) {\n                double yi = y[i] + (y[i + 1] - y[i]) * (xi - x[i]) / (x[i + 1] - x[i]);\n                y_interp.push_back(yi);\n                break;\n            }\n        }\n    }\n    return y_interp;\n}\n\nstd::vector<double> Interpolation::interpolate_2d(const std::vector<double>& x,\n    const std::vector<double>& y,\n    const std::vector<std::vector<double>>& z,\n    const std::vector<double>& x_interp,\n    const std::vector<double>& y_interp) {\n    std::vector<double> z_interp;\n    for (size_t k = 0; k < x_interp.size(); ++k) {\n        double xi = x_interp[k];\n        double yi = y_interp[k];\n        for (size_t i = 0; i < x.size() - 1; ++i) {\n            if (x[i] <= xi && xi <= x[i + 1]) {\n                for (size_t j = 0; j < y.size() - 1; ++j) {\n                    if (y[j] <= yi && yi <= y[j + 1]) {\n                        double z00 = z[i][j];\n                        double z01 = z[i][j + 1];\n                        double z10 = z[i + 1][j];\n                        double z11 = z[i + 1][j + 1];\n                        double zi = (z00 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                            z10 * (xi - x[i]) * (y[j + 1] - yi) +\n                            z01 * (x[i + 1] - xi) * (yi - y[j]) +\n                            z11 * (xi - x[i]) * (yi - y[j])) / ((x[i + 1] - x[i]) * (y[j + 1] - y[j]));\n                        z_interp.push_back(zi);\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return z_interp;\n}\n",
  "IPAddress": "\n#include <sstream>\n#include <iomanip>\n#include <bitset>\n\n#include <string>\n#include <vector>\n\nclass IPAddress {\npublic:\n    explicit IPAddress(const std::string& ip_address);\n    bool is_valid() const;\n    std::vector<std::string> get_octets() const;\n    std::string get_binary() const;\n\nprivate:\n    std::string ip_address;\n    bool is_valid_octet(const std::string& octet) const;\n};\n\nIPAddress::IPAddress(const std::string& ip_address) : ip_address(ip_address) {}\n\nbool IPAddress::is_valid() const {\n    std::stringstream ss(ip_address);\n    std::string octet;\n    std::vector<std::string> octets;\n\n    while (std::getline(ss, octet, '.')) {\n        octets.push_back(octet);\n    }\n\n    if (octets.size() != 4) {\n        return false;\n    }\n\n    for (const std::string& octet : octets) {\n        if (!is_valid_octet(octet)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<std::string> IPAddress::get_octets() const {\n    if (is_valid()) {\n        std::stringstream ss(ip_address);\n        std::string octet;\n        std::vector<std::string> octets;\n\n        while (std::getline(ss, octet, '.')) {\n            octets.push_back(octet);\n        }\n\n        return octets;\n    }\n    else {\n        return {};\n    }\n}\n\nstd::string IPAddress::get_binary() const {\n    if (is_valid()) {\n        std::stringstream result;\n        std::vector<std::string> octets = get_octets();\n\n        for (size_t i = 0; i < octets.size(); ++i) {\n            int num = std::stoi(octets[i]);\n            if (i > 0) {\n                result << '.';\n            }\n            result << std::setw(8) << std::setfill('0') << std::bitset<8>(num);\n        }\n        return result.str();\n    }\n    else {\n        return \"\";\n    }\n}\n\nbool IPAddress::is_valid_octet(const std::string& octet) const {\n    if (octet.empty() || octet.size() > 3) {\n        return false;\n    }\n\n    for (char c : octet) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    int value = std::stoi(octet);\n    return value >= 0 && value <= 255;\n}\n",
  "IpUtil": "\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n#include <iostream>\n#include <cstring>\n\n\n#pragma comment(lib, \"Ws2_32.lib\")\n#pragma comment(lib, \"Iphlpapi.lib\")\n\n#include <string>\n\nclass IpUtil {\npublic:\n    static bool is_valid_ipv4(const std::string& ip_address);\n    static bool is_valid_ipv6(const std::string& ip_address);\n    static std::string get_hostname(const std::string& ip_address);\n};\n\nbool IpUtil::is_valid_ipv4(const std::string& ip_address) {\n    struct sockaddr_in sa;\n    int result = inet_pton(AF_INET, ip_address.c_str(), &(sa.sin_addr));\n    return result == 1;\n}\n\nbool IpUtil::is_valid_ipv6(const std::string& ip_address) {\n    struct sockaddr_in6 sa;\n    int result = inet_pton(AF_INET6, ip_address.c_str(), &(sa.sin6_addr));\n    return result == 1;\n}\n\nstd::string IpUtil::get_hostname(const std::string& ip_address) {\n    if (ip_address == \"0.0.0.0\") {\n        char hostname[NI_MAXHOST];\n        if (gethostname(hostname, sizeof(hostname)) == 0) {\n            \n            return std::string(hostname);\n        }\n        else {\n            \n            return \"\";\n        }\n    }\n\n    struct sockaddr_in sa;\n    sa.sin_family = AF_INET;\n    inet_pton(AF_INET, ip_address.c_str(), &(sa.sin_addr));\n\n    char host[NI_MAXHOST];\n\n    int result = getnameinfo((struct sockaddr*)&sa, sizeof(sa), host, sizeof(host), nullptr, 0, 0);\n    if (result == 0) {\n        return std::string(host);\n    }\n    else {\n        return \"\";\n    }\n}\n",
  "JobMarketplace": "#include <string>\n#include <vector>\n#include <algorithm>\n\nstruct Job {\n    std::string job_title;\n    std::string company;\n    std::vector<std::string> requirements;\n    bool operator==(const Job& other) const {\n        return job_title == other.job_title &&\n            company == other.company &&\n            requirements == other.requirements;\n    }\n};\n\nstruct Resume {\n    std::string name;\n    std::vector<std::string> skills;\n    std::string experience;\n    bool operator==(const Resume& other) const {\n        return name == other.name &&\n            skills == other.skills &&\n            experience == other.experience;\n    }\n};\n\nclass JobMarketplace {\npublic:\n    JobMarketplace();\n\n    void post_job(const std::string& job_title, const std::string& company, const std::vector<std::string>& requirements);\n    void remove_job(const Job& job);\n    void submit_resume(const std::string& name, const std::vector<std::string>& skills, const std::string& experience);\n    void withdraw_resume(const Resume& resume);\n    std::vector<Job> search_jobs(const std::string& criteria) const;\n    std::vector<Resume> get_job_applicants(const Job& job) const;\n\n    static bool matches_requirements(const Resume& resume, const std::vector<std::string>& requirements);\n\n    std::vector<Job> job_listings;\n    std::vector<Resume> resumes;\n};\n\n\nJobMarketplace::JobMarketplace() {}\n\nvoid JobMarketplace::post_job(const std::string& job_title, const std::string& company, const std::vector<std::string>& requirements) {\n    job_listings.push_back({ job_title, company, requirements });\n}\n\nvoid JobMarketplace::remove_job(const Job& job) {\n    auto it = std::remove(job_listings.begin(), job_listings.end(), job);\n    job_listings.erase(it, job_listings.end());\n}\n\nvoid JobMarketplace::submit_resume(const std::string& name, const std::vector<std::string>& skills, const std::string& experience) {\n    resumes.push_back({ name, skills, experience });\n}\n\nvoid JobMarketplace::withdraw_resume(const Resume& resume) {\n    auto it = std::remove(resumes.begin(), resumes.end(), resume);\n    resumes.erase(it, resumes.end());\n}\n\nstd::vector<Job> JobMarketplace::search_jobs(const std::string& criteria) const {\n    std::vector<Job> matching_jobs;\n    for (const auto& job_listing : job_listings) {\n        bool found = (job_listing.job_title.find(criteria) != std::string::npos);\n        if (!found) {\n            for (const auto& requirement : job_listing.requirements) {\n                if (requirement.find(criteria) != std::string::npos) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (found) {\n            matching_jobs.push_back(job_listing);\n        }\n    }\n    return matching_jobs;\n}\n\nstd::vector<Resume> JobMarketplace::get_job_applicants(const Job& job) const {\n    std::vector<Resume> applicants;\n    for (const auto& resume : resumes) {\n        if (matches_requirements(resume, job.requirements)) {\n            applicants.push_back(resume);\n        }\n    }\n    return applicants;\n}\n\nbool JobMarketplace::matches_requirements(const Resume& resume, const std::vector<std::string>& requirements) {\n    for (const auto& skill : resume.skills) {\n        if (std::find(requirements.begin(), requirements.end(), skill) == requirements.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "JSONProcessor": "\n#include <fstream>\n#include <iostream>\n#include <sys/stat.h>\n\n#include <string>\n#include <nlohmann/json.hpp>\n\nclass JSONProcessor {\npublic:\n    \n    int read_json(const std::string& file_path, nlohmann::json& output);\n\n    \n    int write_json(const nlohmann::json& data, const std::string& file_path);\n\n    \n    int process_json(const std::string& file_path, const std::string& remove_key);\n};\n\n\nint JSONProcessor::read_json(const std::string& file_path, nlohmann::json& output) {\n    std::ifstream file(file_path);\n    if (!file.is_open()) {\n        return 0;  \n    }\n\n    try {\n        file >> output;\n        if (output.is_null()) {\n            return -1;  \n        }\n    }\n    catch (...) {\n        return -1;  \n    }\n\n    return 1;  \n}\n\n\nint JSONProcessor::write_json(const nlohmann::json& data, const std::string& file_path) {\n    std::ofstream file(file_path);\n    if (!file.is_open()) {\n        return -1;  \n    }\n\n    try {\n        file << data.dump(4);  \n    }\n    catch (...) {\n        return -1;  \n    }\n\n    return 1;\n}\n\n\nint JSONProcessor::process_json(const std::string& file_path, const std::string& remove_key) {\n    nlohmann::json data;\n    int result = read_json(file_path, data);\n\n    if (result != 1) {\n        return 0;  \n    }\n\n    if (data.contains(remove_key)) {\n        data.erase(remove_key);\n        return write_json(data, file_path);  \n    }\n    else {\n        return 0;  \n    }\n}\n",
  "KappaCalculator": "\n#include <Eigen/Dense>\n#include <numeric> \n\n\n#include <vector>\n\nclass KappaCalculator {\npublic:\n    static double kappa(const std::vector<std::vector<int>>& testData, int k);\n    static double fleiss_kappa(const std::vector<std::vector<int>>& testData, int N, int k, int n);\n};\n\ndouble KappaCalculator::kappa(const std::vector<std::vector<int>>& testData, int k) {\n    Eigen::MatrixXd dataMat(testData.size(), k);\n\n    for (size_t i = 0; i < testData.size(); ++i) {\n        for (int j = 0; j < k; ++j) {\n            dataMat(i, j) = testData[i][j];\n        }\n    }\n\n    double P0 = 0.0;\n    for (int i = 0; i < k; ++i) {\n        P0 += dataMat(i, i);\n    }\n\n    Eigen::VectorXd xsum = dataMat.rowwise().sum();\n    Eigen::VectorXd ysum = dataMat.colwise().sum();\n    double sum = dataMat.sum();\n\n    double Pe = (ysum.dot(xsum)) / (sum * sum);\n    P0 /= sum;\n\n    double cohens_coefficient = (P0 - Pe) / (1 - Pe);\n    return cohens_coefficient;\n}\n\ndouble KappaCalculator::fleiss_kappa(const std::vector<std::vector<int>>& testData, int N, int k, int n) {\n    Eigen::MatrixXd dataMat(testData.size(), k);\n\n    for (size_t i = 0; i < testData.size(); ++i) {\n        for (int j = 0; j < k; ++j) {\n            dataMat(i, j) = testData[i][j];\n        }\n    }\n\n    double sum = 0.0;\n    double P0 = 0.0;\n\n    for (int i = 0; i < N; ++i) {\n        double temp = 0.0;\n        for (int j = 0; j < k; ++j) {\n            sum += dataMat(i, j);\n            temp += std::pow(dataMat(i, j), 2);\n        }\n        temp -= n;\n        temp /= (n - 1) * n;\n        P0 += temp;\n    }\n\n    P0 /= N;\n\n    Eigen::VectorXd ysum = dataMat.colwise().sum();\n    ysum = ysum.array() / sum;\n    ysum = ysum.array().square();\n\n    double Pe = ysum.sum();\n\n    double ans = (P0 - Pe) / (1 - Pe);\n    return ans;\n}\n",
  "LongestWord": "\n#include <sstream>\n#include <cctype>\n#include <algorithm>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <regex>\n\nclass LongestWord {\npublic:\n    LongestWord();\n    void add_word(const std::string& word);\n    std::string find_longest_word(const std::string& sentence) const;\n    std::vector<std::string> get_word_list() const; \n\nprivate:\n    std::vector<std::string> word_list;\n};\n\nLongestWord::LongestWord() : word_list() {}\n\nvoid LongestWord::add_word(const std::string& word) {\n    word_list.push_back(word);\n}\n\nstd::string LongestWord::find_longest_word(const std::string& sentence) const {\n    std::string longest_word;\n    std::string lower_sentence = sentence;\n\n    \n    std::transform(lower_sentence.begin(), lower_sentence.end(), lower_sentence.begin(), ::tolower);\n\n    \n    lower_sentence.erase(std::remove_if(lower_sentence.begin(), lower_sentence.end(),\n        [](unsigned char c) { return std::ispunct(c); }), lower_sentence.end());\n\n    \n    std::istringstream stream(lower_sentence);\n    std::string word;\n\n    while (stream >> word) {\n        if (std::find(word_list.begin(), word_list.end(), word) != word_list.end() &&\n            word.length() > longest_word.length()) {\n            longest_word = word;\n        }\n    }\n\n    return longest_word;\n}\n\nstd::vector<std::string> LongestWord::get_word_list() const {\n    return word_list; \n}\n",
  "MahjongConnect": "\n#include <algorithm>\n\n#include <vector>\n#include <utility>\n#include <set>\n#include <cstdlib>\n\nclass MahjongConnect {\npublic:\n    MahjongConnect(const std::pair<int, int>& boardSize, const std::vector<char>& icons);\n\n    bool is_valid_move(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2);\n    void remove_icons(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2);\n    bool is_game_over() const;\n\n    std::pair<int, int> BOARD_SIZE;\n    std::vector<char> ICONS;\n    std::vector<std::vector<char>> board;\n\n    std::vector<std::vector<char>> create_board();\n    bool has_path(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2) const;\n};\n\n\nMahjongConnect::MahjongConnect(const std::pair<int, int>& boardSize, const std::vector<char>& icons)\n    : BOARD_SIZE(boardSize), ICONS(icons), board(create_board()) {}\n\nstd::vector<std::vector<char>> MahjongConnect::create_board() {\n    std::vector<std::vector<char>> newBoard(BOARD_SIZE.first, std::vector<char>(BOARD_SIZE.second));\n\n    for (int i = 0; i < BOARD_SIZE.first; ++i) {\n        for (int j = 0; j < BOARD_SIZE.second; ++j) {\n            newBoard[i][j] = ICONS[rand() % ICONS.size()];\n        }\n    }\n\n    return newBoard;\n}\n\nbool MahjongConnect::is_valid_move(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2) {\n    int x1 = pos1.first, y1 = pos1.second;\n    int x2 = pos2.first, y2 = pos2.second;\n\n    \n    if (!(0 <= x1 && x1 < BOARD_SIZE.first && 0 <= y1 && y1 < BOARD_SIZE.second &&\n        0 <= x2 && x2 < BOARD_SIZE.first && 0 <= y2 && y2 < BOARD_SIZE.second)) {\n        return false;\n    }\n\n    \n    if (pos1 == pos2) {\n        return false;\n    }\n\n    \n    if (board[x1][y1] != board[x2][y2]) {\n        return false;\n    }\n\n    \n    return has_path(pos1, pos2);\n}\n\nbool MahjongConnect::has_path(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2) const {\n    std::set<std::pair<int, int>> visited;\n    std::vector<std::pair<int, int>> stack;\n    stack.push_back(pos1);\n\n    while (!stack.empty()) {\n        std::pair<int, int> currentPos = stack.back();\n        stack.pop_back();\n\n        if (currentPos == pos2) {\n            return true;\n        }\n\n        if (visited.find(currentPos) != visited.end()) {\n            continue;\n        }\n\n        visited.insert(currentPos);\n        int x = currentPos.first, y = currentPos.second;\n\n        \n        for (const auto& direction : std::vector<std::pair<int, int>>{ {0, 1}, {0, -1}, {1, 0}, {-1, 0} }) {\n            int newX = x + direction.first, newY = y + direction.second;\n            if (0 <= newX && newX < BOARD_SIZE.first && 0 <= newY && newY < BOARD_SIZE.second) {\n                if (visited.find({ newX, newY }) == visited.end() && board[newX][newY] == board[x][y]) {\n                    stack.push_back({ newX, newY });\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid MahjongConnect::remove_icons(const std::pair<int, int>& pos1, const std::pair<int, int>& pos2) {\n    board[pos1.first][pos1.second] = ' ';\n    board[pos2.first][pos2.second] = ' ';\n}\n\nbool MahjongConnect::is_game_over() const {\n    for (const auto& row : board) {\n        if (std::any_of(row.begin(), row.end(), [](char icon) { return icon != ' '; })) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "Manacher": "\n#include <string>\n\nclass Manacher {\nprivate:\n    std::string input_string;\n\npublic:\n    Manacher(const std::string& input_string);\n    int palindromic_length(int center, int diff, const std::string& str);\n    std::string palindromic_string();\n};\n\nManacher::Manacher(const std::string& input_string) {\n    this->input_string = input_string;\n}\n\nint Manacher::palindromic_length(int center, int diff, const std::string& str) {\n    if ((center - diff == -1) || (center + diff == str.length()) || (str[center - diff] != str[center + diff])) {\n        return 0;\n    }\n    return 1 + palindromic_length(center, diff + 1, str);\n}\n\nstd::string Manacher::palindromic_string() {\n    int max_length = 0;\n    std::string new_input_string = \"\";\n    std::string output_string = \"\";\n\n    for (size_t i = 0; i < input_string.length() - 1; ++i) {\n        new_input_string += input_string[i] + std::string(\"|\");\n    }\n    new_input_string += input_string.back();\n\n    int start = 0;\n    for (size_t i = 0; i < new_input_string.length(); ++i) {\n        int length = palindromic_length(static_cast<int>(i), 1, new_input_string);\n\n        if (max_length < length) {\n            max_length = length;\n            start = static_cast<int>(i);\n        }\n    }\n\n    for (int i = start - max_length; i <= start + max_length; ++i) {\n        if (new_input_string[i] != '|') {\n            output_string += new_input_string[i];\n        }\n    }\n\n    return output_string;\n}\n",
  "MetricsCalculator": "#include <vector>\n\nclass MetricsCalculator {\npublic:\n    int true_positives;\n    int false_positives;\n    int false_negatives;\n    int true_negatives;\n\n    MetricsCalculator();\n\n    void update(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels);\n    double precision(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels);\n    double recall(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels);\n    double f1_score(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels);\n    double accuracy(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels);\n};\nMetricsCalculator::MetricsCalculator() {\n    true_positives = 0;\n    false_positives = 0;\n    false_negatives = 0;\n    true_negatives = 0;\n}\n\nvoid MetricsCalculator::update(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels) {\n    for (size_t i = 0; i < predicted_labels.size(); ++i) {\n        int predicted = predicted_labels[i];\n        int true_label = true_labels[i];\n\n        if (predicted == 1 && true_label == 1) {\n            true_positives++;\n        }\n        else if (predicted == 1 && true_label == 0) {\n            false_positives++;\n        }\n        else if (predicted == 0 && true_label == 1) {\n            false_negatives++;\n        }\n        else if (predicted == 0 && true_label == 0) {\n            true_negatives++;\n        }\n    }\n}\n\ndouble MetricsCalculator::precision(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels) {\n    update(predicted_labels, true_labels);\n    if (true_positives + false_positives == 0) {\n        return 0.0;\n    }\n    return static_cast<double>(true_positives) / (true_positives + false_positives);\n}\n\ndouble MetricsCalculator::recall(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels) {\n    update(predicted_labels, true_labels);\n    if (true_positives + false_negatives == 0) {\n        return 0.0;\n    }\n    return static_cast<double>(true_positives) / (true_positives + false_negatives);\n}\n\ndouble MetricsCalculator::f1_score(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels) {\n    update(predicted_labels, true_labels);\n    double precision_value = precision(predicted_labels, true_labels);\n    double recall_value = recall(predicted_labels, true_labels);\n    if (precision_value + recall_value == 0.0) {\n        return 0.0;\n    }\n    return 2.0 * precision_value * recall_value / (precision_value + recall_value);\n}\n\ndouble MetricsCalculator::accuracy(const std::vector<int>& predicted_labels, const std::vector<int>& true_labels) {\n    update(predicted_labels, true_labels);\n    int total = true_positives + true_negatives + false_positives + false_negatives;\n    if (total == 0) {\n        return 0.0;\n    }\n    return static_cast<double>(true_positives + true_negatives) / total;\n}\n",
  "MetricsCalculator2": "\n#include <stdexcept>\n#include <algorithm>\n#include <numeric>\n\n#include <vector>\n#include <utility>\n\nclass MetricsCalculator2 {\npublic:\n    static std::pair<double, std::vector<double>> mrr(const std::vector<std::pair<std::vector<int>, int>>& data);\n    static std::pair<double, std::vector<double>> map(const std::vector<std::pair<std::vector<int>, int>>& data);\n};\n\nnamespace {\n    double calculate_mrr(const std::vector<int>& vec, int k) {\n        auto it = std::find(vec.begin(), vec.end(), 1);\n        if (it == vec.end()) return 0.0;\n        return 1.0 / (std::distance(vec.begin(), it) + 1);\n    }\n\n    double calculate_map(const std::vector<int>& vec, int k) {\n        double sum = 0.0;\n        int count = 0;\n        for (int i = 0; i < vec.size(); ++i) {\n            if (vec[i] == 1) {\n                ++count;\n                sum += count / static_cast<double>(i + 1);\n            }\n        }\n        return count ? sum / count : 0.0;\n    }\n}\n\nstd::pair<double, std::vector<double>> MetricsCalculator2::mrr(const std::vector<std::pair<std::vector<int>, int>>& data) {\n    if (data.empty()) return { 0.0, std::vector<double>{0.0} };\n\n    double sum_mrr = 0.0;\n    std::vector<double> individual_mrr;\n\n    for (const auto& [vec, k] : data) {\n        if (k <= 0 || vec.empty()) {\n            individual_mrr.push_back(0.0);\n        }\n        else {\n            double mrr = calculate_mrr(vec, k);\n            individual_mrr.push_back(mrr);\n            sum_mrr += mrr;\n        }\n    }\n\n    double average_mrr = data.size() ? sum_mrr / data.size() : 0.0;\n    return { average_mrr, individual_mrr };\n}\n\nstd::pair<double, std::vector<double>> MetricsCalculator2::map(const std::vector<std::pair<std::vector<int>, int>>& data) {\n    if (data.empty()) {\n        return { 0.0, {0.0} };\n    }\n\n    std::vector<double> separate_result;\n\n    for (const auto& [sub_list, total_num] : data) {\n        if (total_num == 0) {\n            separate_result.push_back(0.0);\n            continue;\n        }\n\n        size_t len = sub_list.size();\n        std::vector<double> ranking_array(len);\n        std::iota(ranking_array.begin(), ranking_array.end(), 1.0);\n        std::transform(ranking_array.begin(), ranking_array.end(), ranking_array.begin(),\n            [](double i) { return 1.0 / i; });\n\n        std::vector<double> right_ranking_list(len, 0.0);\n        int count = 1;\n\n        for (size_t i = 0; i < len; ++i) {\n            if (sub_list[i] != 0) {\n                right_ranking_list[i] = count++;\n            }\n        }\n\n        double ap = std::inner_product(right_ranking_list.begin(), right_ranking_list.end(),\n            ranking_array.begin(), 0.0) / total_num;\n        separate_result.push_back(ap);\n    }\n\n    double mean_ap = std::accumulate(separate_result.begin(), separate_result.end(), 0.0) / separate_result.size();\n    return { mean_ap, separate_result };\n}\n",
  "MovieBookingSystem": "\n#include <sstream>\n#include <iomanip>\n#include <stdexcept>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <ctime>\n\nclass MovieBookingSystem {\npublic:\n    MovieBookingSystem();\n\n    void add_movie(const std::string& name, double price, const std::string& start_time, const std::string& end_time, int n);\n    std::string book_ticket(const std::string& name, const std::vector<std::pair<int, int>>& seats);\n    std::vector<std::string> available_movies(const std::string& start_time, const std::string& end_time) const;\n\n    struct Movie {\n        std::string name;\n        double price;\n        std::tm start_time;\n        std::tm end_time;\n        std::vector<std::vector<int>> seats;\n    };\n\n    std::vector<Movie> movies;\n\n    std::tm parse_time(const std::string& time_str) const;\n    bool is_time_in_range(const std::tm& start, const std::tm& end, const std::tm& check) const;\n};\n\n\nstd::tm MovieBookingSystem::parse_time(const std::string& time_str) const {\n    std::tm tm = {};\n    std::istringstream ss(time_str);\n    ss >> std::get_time(&tm, \"%H:%M\");\n    if (ss.fail()) {\n        throw std::runtime_error(\"Failed to parse time\");\n    }\n    return tm;\n}\n\n\nbool MovieBookingSystem::is_time_in_range(const std::tm& start, const std::tm& end, const std::tm& check) const {\n    auto time_to_seconds = [](const std::tm& tm) -> int {\n        return tm.tm_hour * 3600 + tm.tm_min * 60;\n        };\n    return time_to_seconds(start) <= time_to_seconds(check) && time_to_seconds(check) <= time_to_seconds(end);\n}\n\nMovieBookingSystem::MovieBookingSystem() {}\n\nvoid MovieBookingSystem::add_movie(const std::string& name, double price, const std::string& start_time, const std::string& end_time, int n) {\n    Movie movie;\n    movie.name = name;\n    movie.price = price;\n    movie.start_time = parse_time(start_time);\n    movie.end_time = parse_time(end_time);\n    movie.seats.resize(n, std::vector<int>(n, 0));\n    movies.push_back(movie);\n}\n\nstd::string MovieBookingSystem::book_ticket(const std::string& name, const std::vector<std::pair<int, int>>& seats_to_book) {\n    for (auto& movie : movies) {\n        if (movie.name == name) {\n            for (const auto& seat : seats_to_book) {\n                int row = seat.first;\n                int col = seat.second;\n                if (row >= 0 && row < movie.seats.size() && col >= 0 && col < movie.seats[row].size()) {\n                    if (movie.seats[row][col] == 0) {\n                        movie.seats[row][col] = 1;\n                    }\n                    else {\n                        return \"Booking failed.\";\n                    }\n                }\n                else {\n                    return \"Booking failed.\"; \n                }\n            }\n            return \"Booking success.\";\n        }\n    }\n    return \"Movie not found.\";\n}\n\nstd::vector<std::string> MovieBookingSystem::available_movies(const std::string& start_time, const std::string& end_time) const {\n    std::tm start = parse_time(start_time);\n    std::tm end = parse_time(end_time);\n\n    std::vector<std::string> available_movies;\n    for (const auto& movie : movies) {\n        if (is_time_in_range(start, end, movie.start_time) && is_time_in_range(start, end, movie.end_time)) {\n            available_movies.push_back(movie.name);\n        }\n    }\n    return available_movies;\n}\n",
  "MovieTicketDB": "\n#include <iostream>\n#include <stdexcept>\n\n#include <winsqlite/winsqlite3.h>\n#include <string>\n#include <vector>\n\nclass MovieTicketDB {\npublic:\n    MovieTicketDB(const std::string& dbName);\n    ~MovieTicketDB();\n\n    void create_table();\n    void insert_ticket(const std::string& movieName, const std::string& theaterName,\n        const std::string& seatNumber, const std::string& customerName);\n    std::vector<std::vector<std::string>> search_tickets_by_customer(const std::string& customerName);\n    void delete_ticket(const std::string& ticketId);\n    void close_connection();\n\nprivate:\n    sqlite3* db;\n    std::string dbName;\n};\n\nMovieTicketDB::MovieTicketDB(const std::string& dbName) : dbName(dbName) {\n    if (sqlite3_open(dbName.c_str(), &db) != SQLITE_OK) {\n        throw std::runtime_error(\"Unable to open database\");\n    }\n    create_table();\n}\n\nMovieTicketDB::~MovieTicketDB() {\n    close_connection();\n}\n\nvoid MovieTicketDB::create_table() {\n    const char* create_tableSQL = R\"(\n        CREATE TABLE IF NOT EXISTS tickets (\n            id INTEGER PRIMARY KEY,\n            movie_name TEXT,\n            theater_name TEXT,\n            seat_number TEXT,\n            customer_name TEXT\n        )\n    )\";\n    char* errMsg = nullptr;\n    if (sqlite3_exec(db, create_tableSQL, nullptr, nullptr, &errMsg) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to create table: \" + std::string(errMsg));\n    }\n}\n\nvoid MovieTicketDB::insert_ticket(const std::string& movieName, const std::string& theaterName,\n    const std::string& seatNumber, const std::string& customerName) {\n    const char* insertSQL = R\"(\n        INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n        VALUES (?, ?, ?, ?)\n    )\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(db, insertSQL, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to prepare statement\");\n    }\n    sqlite3_bind_text(stmt, 1, movieName.c_str(), -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 2, theaterName.c_str(), -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 3, seatNumber.c_str(), -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 4, customerName.c_str(), -1, SQLITE_STATIC);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(\"Failed to insert ticket\");\n    }\n    sqlite3_finalize(stmt);\n}\n\nstd::vector<std::vector<std::string>> MovieTicketDB::search_tickets_by_customer(const std::string& customerName) {\n    const char* searchSQL = R\"(\n        SELECT * FROM tickets WHERE customer_name = ?\n    )\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(db, searchSQL, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to prepare statement\");\n    }\n    sqlite3_bind_text(stmt, 1, customerName.c_str(), -1, SQLITE_STATIC);\n\n    std::vector<std::vector<std::string>> results;\n    while (sqlite3_step(stmt) == SQLITE_ROW) {\n        std::vector<std::string> row;\n        for (int i = 0; i < sqlite3_column_count(stmt); ++i) {\n            row.emplace_back(reinterpret_cast<const char*>(sqlite3_column_text(stmt, i)));\n        }\n        results.emplace_back(std::move(row));\n    }\n    sqlite3_finalize(stmt);\n    return results;\n}\n\nvoid MovieTicketDB::delete_ticket(const std::string& ticketId) {\n    const char* deleteSQL = R\"(\n        DELETE FROM tickets WHERE id = ?\n    )\";\n    sqlite3_stmt* stmt;\n    if (sqlite3_prepare_v2(db, deleteSQL, -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to prepare statement\");\n    }\n    sqlite3_bind_text(stmt, 1, ticketId.c_str(), -1, SQLITE_STATIC);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(\"Failed to delete ticket\");\n    }\n    sqlite3_finalize(stmt);\n}\n\nvoid MovieTicketDB::close_connection() {\n    if (db) {\n        sqlite3_close(db);\n        db = nullptr;\n    }\n}\n",
  "MusicPlayer": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <random>\n\nclass MusicPlayer {\npublic:\n    MusicPlayer();\n\n    void add_song(const std::string& song);\n    void remove_song(const std::string& song);\n    std::string play();\n    bool stop();\n    bool switch_song();\n    bool previous_song();\n    bool set_volume(int volume);\n    bool shuffle();\n\n    \n    std::vector<std::string> playlist;\n    std::string current_song;\n    int volume;\n\nprivate:\n    bool is_valid_volume(int volume) const;\n};\n\nMusicPlayer::MusicPlayer() : volume(50) {\n    std::srand(static_cast<unsigned>(std::time(0))); \n}\n\nvoid MusicPlayer::add_song(const std::string& song) {\n    playlist.push_back(song);\n}\n\nvoid MusicPlayer::remove_song(const std::string& song) {\n    auto it = std::find(playlist.begin(), playlist.end(), song);\n    if (it != playlist.end()) {\n        playlist.erase(it);\n        if (current_song == song) {\n            stop();\n        }\n    }\n}\n\nstd::string MusicPlayer::play() {\n    if (!playlist.empty()) {\n        if (!current_song.empty()) {\n            for (auto x : playlist)\n            {\n                if (x == current_song)\n                {\n                    return current_song;\n                }\n            }\n            return *playlist.begin();\n        }\n        else {\n            return playlist.front();\n        }\n    }\n    return \"\"; \n}\n\nbool MusicPlayer::stop() {\n    if (!current_song.empty()) {\n        current_song.clear();\n        return true;\n    }\n    return false;\n}\n\nbool MusicPlayer::switch_song() {\n    if (!current_song.empty()) {\n        auto it = std::find(playlist.begin(), playlist.end(), current_song);\n        if (it != playlist.end() && (it + 1) != playlist.end()) {\n            current_song = *(it + 1);\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\nbool MusicPlayer::previous_song() {\n    if (!current_song.empty()) {\n        auto it = std::find(playlist.begin(), playlist.end(), current_song);\n        if (it != playlist.begin()) {\n            current_song = *(it - 1);\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool MusicPlayer::set_volume(int volume) {\n    if (is_valid_volume(volume)) {\n        this->volume = volume;\n        return true;\n    }\n    return false;\n}\n\nbool MusicPlayer::shuffle() {\n    if (!playlist.empty()) {\n        std::random_device rd;\n        std::mt19937 g(rd());\n        std::shuffle(playlist.begin(), playlist.end(), g);\n        return true;\n    }\n    return false;\n}\n\nbool MusicPlayer::is_valid_volume(int volume) const {\n    return volume >= 0 && volume <= 100;\n}\n",
  "NLPDataProcessor": "\n#include <algorithm> \n#include <sstream>\n\n#include <vector>\n#include <string>\n\nclass NLPDataProcessor {\npublic:\n    std::vector<std::string> construct_stop_word_list();\n    std::vector<std::vector<std::string>> remove_stop_words(\n        const std::vector<std::string>& string_list,\n        const std::vector<std::string>& stop_word_list);\n    std::vector<std::vector<std::string>> process(const std::vector<std::string>& string_list);\n};\n\nstd::vector<std::string> NLPDataProcessor::construct_stop_word_list() {\n    return { \"a\", \"an\", \"the\" };\n}\n\nstd::vector<std::vector<std::string>> NLPDataProcessor::remove_stop_words(\n    const std::vector<std::string>& string_list,\n    const std::vector<std::string>& stop_word_list) {\n\n    std::vector<std::vector<std::string>> answer;\n\n    for (const auto& str : string_list) {\n        std::vector<std::string> string_split;\n        std::string word;\n        std::istringstream stream(str);\n\n        \n        while (stream >> word) {\n            if (std::find(stop_word_list.begin(), stop_word_list.end(), word) == stop_word_list.end()) {\n                string_split.push_back(word);\n            }\n        }\n\n        answer.push_back(string_split);\n    }\n\n    return answer;\n}\n\n\nstd::vector<std::vector<std::string>> NLPDataProcessor::process(const std::vector<std::string>& string_list) {\n    std::vector<std::string> stop_word_list = construct_stop_word_list();\n    return remove_stop_words(string_list, stop_word_list);\n}\n",
  "NLPDataProcessor2": "\n#include <algorithm>\n#include <cctype>\n#include <map>\n#include <regex>\n#include <string>\n#include <vector>\n#include <locale>\n\n#include <vector>\n#include <string>\n#include <map>\n\nclass NLPDataProcessor2 {\npublic:\n    std::vector<std::vector<std::string>> process_data(const std::vector<std::string>& string_list);\n    std::map<std::string, int> calculate_word_frequency(const std::vector<std::vector<std::string>>& words_list);\n    std::map<std::string, int> process(const std::vector<std::string>& string_list);\n};\n\n\nstd::string to_lowercase(const std::string& str) {\n    std::string result;\n    std::locale loc;\n    for (char c : str) {\n        result += std::tolower(c, loc);\n    }\n    return result;\n}\n\n\nstd::string remove_non_alpha(const std::string& str) {\n    std::string result;\n    std::locale loc;\n    for (char c : str) {\n        if (std::isalpha(c, loc) || std::isspace(c, loc)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\nstd::vector<std::vector<std::string>> NLPDataProcessor2::process_data(const std::vector<std::string>& string_list) {\n    std::vector<std::vector<std::string>> words_list;\n    std::regex word_regex(\"\\\\s+\");\n\n    for (const auto& str : string_list) {\n        std::string processed_string = to_lowercase(remove_non_alpha(str));\n        std::sregex_token_iterator iter(processed_string.begin(), processed_string.end(), word_regex, -1);\n        std::sregex_token_iterator end;\n\n        std::vector<std::string> words;\n        for (; iter != end; ++iter) {\n            if (!iter->str().empty()) {  \n                words.push_back(iter->str());\n            }\n        }\n        words_list.push_back(words);\n    }\n\n    return words_list;\n}\n\nstd::map<std::string, int> first_appear;\n\nint cmp(const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) \n{\n    if (a.second == b.second)\n    {\n        return first_appear[a.first] < first_appear[b.first];\n    }\n    return b.second < a.second;\n}\n\nstd::map<std::string, int> NLPDataProcessor2::calculate_word_frequency(const std::vector<std::vector<std::string>>& words_list) {\n    std::map<std::string, int> word_frequency;\n    first_appear.clear();\n    int js = 0;\n    for (const auto& words : words_list) {\n        for (const auto& word : words) {\n            if (!word_frequency[word])\n            {\n                first_appear[word] = ++js;\n            }\n            word_frequency[word]++;\n        }\n    }\n\n    std::vector<std::pair<std::string, int>> sorted_word_frequency(word_frequency.begin(), word_frequency.end());\n    std::sort(sorted_word_frequency.begin(), sorted_word_frequency.end(),cmp);\n\n    std::map<std::string, int> top_5_word_frequency;\n    for (size_t i = 0; i < std::min<size_t>(5, sorted_word_frequency.size()); ++i) {\n        top_5_word_frequency[sorted_word_frequency[i].first] = sorted_word_frequency[i].second;\n    }\n\n    return top_5_word_frequency;\n}\n\nstd::map<std::string, int> NLPDataProcessor2::process(const std::vector<std::string>& string_list) {\n    std::vector<std::vector<std::string>> words_list = process_data(string_list);\n    return calculate_word_frequency(words_list);\n}\n",
  "NumberConverter": "\n#include <bitset>\n#include <sstream>\n#include <iomanip>\n\n#include <string>\n\nclass NumberConverter {\npublic:\n    static std::string decimal_to_binary(int decimal_num);\n    static int binary_to_decimal(const std::string& binary_num);\n    static std::string decimal_to_octal(int decimal_num);\n    static int octal_to_decimal(const std::string& octal_num);\n    static std::string decimal_to_hex(int decimal_num);\n    static int hex_to_decimal(const std::string& hex_num);\n};\n\nstd::string NumberConverter::decimal_to_binary(int decimal_num) {\n    std::string binary_num = std::bitset<32>(decimal_num).to_string();\n    binary_num.erase(0, binary_num.find_first_not_of('0')); \n    return binary_num.empty() ? \"0\" : binary_num;\n}\n\nint NumberConverter::binary_to_decimal(const std::string& binary_num) {\n    return std::stoi(binary_num, nullptr, 2);\n}\n\nstd::string NumberConverter::decimal_to_octal(int decimal_num) {\n    std::stringstream ss;\n    ss << std::oct << decimal_num;\n    return ss.str();\n}\n\nint NumberConverter::octal_to_decimal(const std::string& octal_num) {\n    return std::stoi(octal_num, nullptr, 8);\n}\n\nstd::string NumberConverter::decimal_to_hex(int decimal_num) {\n    std::stringstream ss;\n    ss << std::hex << decimal_num;\n    return ss.str();\n}\n\nint NumberConverter::hex_to_decimal(const std::string& hex_num) {\n    return std::stoi(hex_num, nullptr, 16);\n}\n",
  "NumberWordFormatter": "\n#include <algorithm> \n#include <sstream>   \n\n#include <string>\n\nclass NumberWordFormatter {\npublic:\n    NumberWordFormatter();\n\n    std::string format(int x);\n    std::string format(double x);\n    std::string format(const std::string& x);\n    std::string format(std::nullptr_t);\n    std::string trans_two(const std::string& s);\n    std::string trans_three(const std::string& s);\n    std::string parse_more(int i);\n\nprivate:\n    const std::string NUMBER[10];\n    const std::string NUMBER_TEEN[10];\n    const std::string NUMBER_TEN[9];\n    const std::string NUMBER_MORE[4];\n    const std::string NUMBER_SUFFIX[20];\n};\n\n\nNumberWordFormatter::NumberWordFormatter()\n    : NUMBER{ \"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\" },\n    NUMBER_TEEN{ \"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\", \"EIGHTEEN\", \"NINETEEN\" },\n    NUMBER_TEN{ \"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\" },\n    NUMBER_MORE{ \"\", \"THOUSAND\", \"MILLION\", \"BILLION\" },\n    NUMBER_SUFFIX{ \"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\" } {}\n\nstd::string NumberWordFormatter::format(int x) {\n    std::stringstream ss;\n    ss << x;\n    return format(ss.str());\n}\n\nstd::string NumberWordFormatter::format(double x) {\n    std::stringstream ss;\n    ss << x;\n    return format(ss.str());\n}\n\nstd::string NumberWordFormatter::format(const std::string& x) {\n    std::string lstr = x.substr(0, x.find('.'));\n    std::string rstr;\n    auto now = x.find('.');\n    if (x.find('.') != std::string::npos)\n    {\n        rstr = x.substr(x.find('.') + 1);\n    }\n    std::reverse(lstr.begin(), lstr.end());\n\n    if (lstr.size() % 3 == 1) lstr += \"00\";\n    else if (lstr.size() % 3 == 2) lstr += \"0\";\n\n    std::string a[5] = { \"\", \"\", \"\", \"\", \"\" };\n    std::string lm = \"\";\n\n    for (size_t i = 0; i < lstr.size() / 3; ++i) {\n        a[i] = std::string(1, lstr[3 * i + 2]) + std::string(1, lstr[3 * i + 1]) + std::string(1, lstr[3 * i]);\n        \n        if (a[i] != \"000\") {\n            lm = trans_three(a[i]) + \" \" + parse_more(i) + \" \" + lm;\n        }\n        else {\n            lm += trans_three(a[i]);\n        }\n    }\n    std::string xs = !rstr.empty() ? \"AND CENTS \" + trans_two(rstr) + \" \" : \"\";\n    if (lm.empty()) {\n        return \"ZERO ONLY\";\n    }\n    else {\n        int nowpos = 0;\n        for (int i = lm.size() - 1; i >= 0; --i)\n        {\n            if (lm[i] != ' ')\n            {\n                nowpos = i;\n                break;\n            }\n        }\n        lm = lm.substr(0, nowpos + 1);\n        return lm + \" \" + xs + \"ONLY\";\n    }\n}\n\nstd::string NumberWordFormatter::format(std::nullptr_t) {\n    return \"\";\n}\n\nstd::string NumberWordFormatter::trans_two(const std::string& s) {\n    std::string ss = s;\n    if (ss.size() == 1) ss = \"0\" + ss;\n\n    if (ss[0] == '0') {\n        return NUMBER[ss[1] - '0'];\n    }\n    else if (ss[0] == '1') {\n        return NUMBER_TEEN[std::stoi(ss) - 10];\n    }\n    else if (ss[1] == '0') {\n        return NUMBER_TEN[ss[0] - '1'];\n    }\n    else {\n        return NUMBER_TEN[ss[0] - '1'] + \" \" + NUMBER[ss[1] - '0'];\n    }\n}\n\nstd::string NumberWordFormatter::trans_three(const std::string& s) {\n    if (s[0] == '0') {\n        return trans_two(s.substr(1));\n    }\n    else if (s.substr(1) == \"00\") {\n        return NUMBER[s[0] - '0'] + \" HUNDRED\";\n    }\n    else {\n        return NUMBER[s[0] - '0'] + \" HUNDRED AND \" + trans_two(s.substr(1));\n    }\n}\n\nstd::string NumberWordFormatter::parse_more(int i) {\n    return NUMBER_MORE[i];\n}\n",
  "NumericEntityUnescaper": "\n#include <cctype>\n#include <sstream>\n\n#include <string>\n\nclass NumericEntityUnescaper {\npublic:\n    NumericEntityUnescaper() = default;\n    std::string replace(const std::string& input);\n    static bool is_hex_char(char c);\n};\n\nstd::string NumericEntityUnescaper::replace(const std::string& input) {\n    std::string out;\n    size_t pos = 0;\n    size_t length = input.size();\n    if (input.empty())\n    {\n        return \"\";\n    }\n    while (pos < length - 2) {\n        if (input[pos] == '&' && input[pos + 1] == '#') {\n            size_t start = pos + 2;\n            bool is_hex = false;\n\n            if (start < length && (input[start] == 'x' || input[start] == 'X')) {\n                ++start;\n                is_hex = true;\n            }\n\n            if (start == length) {\n                return out; \n            }\n\n            size_t end = start;\n            while (end < length && is_hex_char(input[end])) {\n                ++end;\n            }\n\n            if (end < length && input[end] == ';') {\n                try {\n                    int entity_value;\n                    std::string number_str = input.substr(start, end - start);\n                    std::stringstream ss;\n                    if (is_hex) {\n                        ss << std::hex << number_str;\n                    }\n                    else {\n                        ss << number_str;\n                    }\n                    ss >> entity_value;\n\n                    if (ss.fail()) {\n                        return out; \n                    }\n\n                    out.push_back(static_cast<char>(entity_value));\n                    pos = end + 1;\n                    continue;\n                }\n                catch (const std::exception&) {\n                    return out; \n                }\n            }\n        }\n\n        out.push_back(input[pos]);\n        ++pos;\n    }\n\n    return out;\n}\n\nbool NumericEntityUnescaper::is_hex_char(char c) {\n    return std::isdigit(c) || (std::tolower(c) >= 'a' && std::tolower(c) <= 'f');\n}\n",
  "Order": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n\nstruct Dish {\n    std::string dish;\n    double price;\n    int count;\n};\n\nclass Order {\npublic:\n    Order();\n    bool add_dish(const Dish& dish);\n    double calculate_total() const;\n    double checkout();\n\n    std::vector<Dish> menu;\n    std::vector<Dish> selected_dishes;\n    std::unordered_map<std::string, double> sales;\n};\n\nOrder::Order() {}\n\n\nbool Order::add_dish(const Dish& dish) {\n    for (auto& menu_dish : menu) {\n        if (dish.dish == menu_dish.dish) {\n            if (menu_dish.count < dish.count) {\n                return false;\n            }\n            else {\n                menu_dish.count -= dish.count;\n                break;\n            }\n        }\n    }\n    selected_dishes.push_back(dish);\n    return true;\n}\n\n\ndouble Order::calculate_total() const {\n    double total = 0;\n    for (const auto& dish : selected_dishes) {\n        auto it = sales.find(dish.dish);\n        if (it != sales.end()) {\n            total += dish.price * dish.count * it->second;\n        }\n    }\n    return total;\n}\n\n\ndouble Order::checkout() {\n    if (selected_dishes.empty()) {\n        return 0;\n    }\n    double total = calculate_total();\n    selected_dishes.clear();\n    return total;\n}\n",
  "PageUtil": "\n#include <algorithm>\n#include <cmath>\n\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <variant>\n\nclass PageUtil {\npublic:\n    PageUtil(const std::vector<int>& data, int page_size);\n\n    std::vector<int> get_page(int page_number) const;\n\n    std::unordered_map<std::string, std::variant<int, std::vector<int>, bool>> get_page_info(int page_number) const;\n\n    std::unordered_map<std::string, std::variant<std::string, int, std::vector<int>>> search(const std::string& keyword) const;\n\n    std::vector<int> data;\n    int page_size;\n    int total_items;\n    int total_pages;\n};\n\nPageUtil::PageUtil(const std::vector<int>& data, int page_size)\n    : data(data), page_size(page_size) {\n    total_items = data.size();\n    total_pages = (total_items + page_size - 1) / page_size;\n}\n\nstd::vector<int> PageUtil::get_page(int page_number) const {\n    if (page_number < 1 || page_number > total_pages) {\n        return {};\n    }\n\n    int start_index = (page_number - 1) * page_size;\n    int end_index = start_index + page_size;\n    if (end_index > total_items) {\n        end_index = total_items;\n    }\n    return std::vector<int>(data.begin() + start_index, data.begin() + end_index);\n}\n\nstd::unordered_map<std::string, std::variant<int, std::vector<int>, bool>> PageUtil::get_page_info(int page_number) const {\n    if (page_number < 1 || page_number > total_pages) {\n        return {};\n    }\n\n    int start_index = (page_number - 1) * page_size;\n    int end_index = std::min(start_index + page_size, total_items);\n    std::vector<int> page_data(data.begin() + start_index, data.begin() + end_index);\n\n    std::unordered_map<std::string, std::variant<int, std::vector<int>, bool>> page_info = {\n        {\"current_page\", page_number},\n        {\"per_page\", page_size},\n        {\"total_pages\", total_pages},\n        {\"total_items\", total_items},\n        {\"has_previous\", page_number > 1},\n        {\"has_next\", page_number < total_pages},\n        {\"data\", page_data}\n    };\n\n    return page_info;\n}\n\nstd::unordered_map<std::string, std::variant<std::string, int, std::vector<int>>> PageUtil::search(const std::string& keyword) const {\n    std::vector<int> results;\n    for (int item : data) {\n        if (std::to_string(item).find(keyword) != std::string::npos) {\n            results.push_back(item);\n        }\n    }\n\n    int num_results = results.size();\n    int num_pages = (num_results + page_size - 1) / page_size;\n\n    std::unordered_map<std::string, std::variant<std::string, int, std::vector<int>>> search_info = {\n        {\"keyword\", keyword},\n        {\"total_results\", num_results},\n        {\"total_pages\", num_pages},\n        {\"results\", results}\n    };\n\n    return search_info;\n}\n",
  "PersonRequest": "#include <string>\n\nclass PersonRequest {\npublic:\n    PersonRequest(const std::string& name, const std::string& sex, const std::string& phoneNumber);\n\n    std::string name;\n    std::string sex;\n    std::string phoneNumber;\n\nprivate:\n    std::string validate_name(const std::string& name);\n    std::string validate_sex(const std::string& sex);\n    std::string validate_phone_number(const std::string& phoneNumber);\n    bool is_all_digits(const std::string& s);\n};\n\n\nPersonRequest::PersonRequest(const std::string& name, const std::string& sex, const std::string& phoneNumber)\n    : name(validate_name(name)), sex(validate_sex(sex)), phoneNumber(validate_phone_number(phoneNumber)) {}\n\n\nstd::string PersonRequest::validate_name(const std::string& name) {\n    if (name.empty() || name.length() > 33) {\n        return \"\";\n    }\n    return name;\n}\n\n\nstd::string PersonRequest::validate_sex(const std::string& sex) {\n    if (sex != \"Man\" && sex != \"Woman\" && sex != \"UGM\") {\n        return \"\";\n    }\n    return sex;\n}\n\n\nstd::string PersonRequest::validate_phone_number(const std::string& phoneNumber) {\n    if (phoneNumber.empty() || phoneNumber.length() != 11 || !is_all_digits(phoneNumber)) {\n        return \"\";\n    }\n    return phoneNumber;\n}\n\n\nbool PersonRequest::is_all_digits(const std::string& s) {\n    for (char c : s) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "PushBoxGame": "#include <vector>\n#include <string>\n#include <utility>\n\nclass PushBoxGame {\npublic:\n    PushBoxGame(const std::vector<std::string>& map);\n    PushBoxGame();\n\n    std::vector<std::string> gat_map() const;\n    bool is_game_over() const;\n    int get_player_col() const;\n    int get_player_row() const;\n    std::vector<std::pair<int, int>> get_targets() const;\n    std::vector<std::pair<int, int>> get_boxes() const;\n    int get_target_count() const;\n    bool check_win();\n    bool move(char direction);\n\n    void init_game();\n\n    std::vector<std::string> map;\n    int player_row;\n    int player_col;\n    std::vector<std::pair<int, int>> targets;\n    std::vector<std::pair<int, int>> boxes;\n    int target_count;\n    bool _is_game_over;\n};\n\n\nPushBoxGame::PushBoxGame(const std::vector<std::string>& map)\n    : map(map), player_row(0), player_col(0), target_count(0), _is_game_over(false) {\n    init_game();\n}\n\nPushBoxGame::PushBoxGame()\n    : map({}), player_row(0), player_col(0), target_count(0), _is_game_over(false) {\n    init_game();\n}\n\nstd::vector<std::string> PushBoxGame::gat_map() const {\n    return map;\n}\n\nbool PushBoxGame::is_game_over() const {\n    return _is_game_over;\n}\n\nint PushBoxGame::get_player_col() const {\n    return player_col;\n}\n\nint PushBoxGame::get_player_row() const {\n    return player_row;\n}\n\nstd::vector<std::pair<int, int>> PushBoxGame::get_targets() const {\n    return targets;\n}\n\nstd::vector<std::pair<int, int>> PushBoxGame::get_boxes() const {\n    return boxes;\n}\n\nint PushBoxGame::get_target_count() const {\n    return target_count;\n}\n\nvoid PushBoxGame::init_game() {\n    for (size_t row = 0; row < map.size(); ++row) {\n        for (size_t col = 0; col < map[row].size(); ++col) {\n            if (map[row][col] == 'O') {\n                player_row = static_cast<int>(row);\n                player_col = static_cast<int>(col);\n            }\n            else if (map[row][col] == 'G') {\n                targets.emplace_back(row, col);\n                ++target_count;\n            }\n            else if (map[row][col] == 'X') {\n                boxes.emplace_back(row, col);\n            }\n        }\n    }\n}\n\nbool PushBoxGame::check_win() {\n    int box_on_target_count = 0;\n    for (const auto& box : boxes) {\n        if (std::find(targets.begin(), targets.end(), box) != targets.end()) {\n            ++box_on_target_count;\n        }\n    }\n    if (box_on_target_count == target_count) {\n        _is_game_over = true;\n    }\n    return _is_game_over;\n}\n\nbool PushBoxGame::move(char direction) {\n    int new_player_row = player_row;\n    int new_player_col = player_col;\n\n    if (direction == 'w') {\n        --new_player_row;\n    }\n    else if (direction == 's') {\n        ++new_player_row;\n    }\n    else if (direction == 'a') {\n        --new_player_col;\n    }\n    else if (direction == 'd') {\n        ++new_player_col;\n    }\n\n    if (map[new_player_row][new_player_col] != '#') {\n        if (std::find(boxes.begin(), boxes.end(), std::make_pair(new_player_row, new_player_col)) != boxes.end()) {\n            int new_box_row = new_player_row + (new_player_row - player_row);\n            int new_box_col = new_player_col + (new_player_col - player_col);\n\n            if (map[new_box_row][new_box_col] != '#') {\n                auto box_it = std::find(boxes.begin(), boxes.end(), std::make_pair(new_player_row, new_player_col));\n                if (box_it != boxes.end()) {\n                    boxes.erase(box_it);\n                }\n                boxes.emplace_back(new_box_row, new_box_col);\n                player_row = new_player_row;\n                player_col = new_player_col;\n            }\n        }\n        else {\n            player_row = new_player_row;\n            player_col = new_player_col;\n        }\n    }\n\n    return check_win();\n}\n",
  "RegexUtils": "#include <string>\n#include <vector>\n#include <regex>\n\nclass RegexUtils {\npublic:\n    bool match(const std::string& pattern, const std::string& text);\n    std::vector<std::string> findall(const std::string& pattern, const std::string& text);\n    std::vector<std::string> split(const std::string& pattern, const std::string& text);\n    std::string sub(const std::string& pattern, const std::string& replacement, const std::string& text);\n    std::string generate_email_pattern();\n    std::string generate_phone_number_pattern();\n    std::string generate_split_sentences_pattern();\n    std::vector<std::string> split_sentences(const std::string& text);\n    bool validate_phone_number(const std::string& phone_number);\n    std::vector<std::string> extract_email(const std::string& text);\n};\n\nbool RegexUtils::match(const std::string& pattern, const std::string& text) {\n    std::regex re(pattern);\n    std::smatch match;\n    return std::regex_search(text, match, re);\n}\n\n\nstd::vector<std::string> RegexUtils::findall(const std::string& pattern, const std::string& text) {\n    std::regex re(pattern);\n    std::sregex_iterator begin(text.begin(), text.end(), re);\n    std::sregex_iterator end;\n    std::vector<std::string> results;\n    for (std::sregex_iterator i = begin; i != end; ++i) {\n        results.push_back(i->str());\n    }\n    return results;\n}\n\n\nstd::vector<std::string> RegexUtils::split(const std::string& pattern, const std::string& text) {\n    std::regex re(pattern);\n    std::sregex_token_iterator it(text.begin(), text.end(), re, -1);\n    std::sregex_token_iterator reg_end;\n\n    std::vector<std::string> result;\n    for (; it != reg_end; ++it) {\n\n        result.push_back(it->str());\n    }\n    \n    \n    if (text.empty()) {\n        return result;\n    }\n    if (result[0] != text)\n    {\n        result.push_back(\"\");\n    }\n    \n\n\n    return result;\n}\n\nstd::string RegexUtils::sub(const std::string& pattern, const std::string& replacement, const std::string& text) {\n    std::regex re(pattern);\n    return std::regex_replace(text, re, replacement);\n}\n\nstd::string RegexUtils::generate_email_pattern() {\n    return R\"(\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b)\";\n}\n\nstd::string RegexUtils::generate_phone_number_pattern() {\n    return R\"(\\b\\d{3}-\\d{3}-\\d{4}\\b)\";\n}\n\nstd::string RegexUtils::generate_split_sentences_pattern() {\n    return R\"([.!?][\\s]{1,2}(?=[A-Z]))\";\n}\n\nstd::vector<std::string> RegexUtils::split_sentences(const std::string& text) {\n    std::string pattern = generate_split_sentences_pattern();\n    std::vector<std::string> sentences = split(pattern, text);\n\n    \n    if (!sentences.empty() && sentences.front().empty()) {\n        sentences.erase(sentences.begin());  \n    }\n    if (!sentences.empty() && sentences.back().empty()) {\n        sentences.pop_back();  \n    }\n\n    return sentences;\n}\n\nbool RegexUtils::validate_phone_number(const std::string& phone_number) {\n    std::string pattern = generate_phone_number_pattern();\n    return match(pattern, phone_number);\n}\n\nstd::vector<std::string> RegexUtils::extract_email(const std::string& text) {\n    std::string pattern = generate_email_pattern();\n    return findall(pattern, text);\n}\n\n",
  "RPGCharacter": "#include <string>\n\nclass RPGCharacter {\npublic:\n    RPGCharacter(const std::string& name, int hp, int attack_power, int defense, int level = 1);\n\n    void attack(RPGCharacter& other_character);\n    int heal();\n    void gain_exp(int amount);\n    bool is_alive() const;\n\n    \n    int get_hp() const;\n    int get_exp() const;\n    int get_attack_power() const;\n    int get_defense() const;\n    int get_level() const;\n    void set_hp(int x);\n\n    void level_up();\n\n    std::string name;\n    int hp;\n    int attack_power;\n    int defense;\n    int level;\n    int exp;\n};\nRPGCharacter::RPGCharacter(const std::string& name, int hp, int attack_power, int defense, int level)\n    : name(name), hp(hp), attack_power(attack_power), defense(defense), level(level), exp(0) {\n}\n\nvoid RPGCharacter::attack(RPGCharacter& other_character) {\n    int damage = std::max(attack_power - other_character.defense, 1);\n    other_character.hp -= damage;\n}\n\nint RPGCharacter::heal() {\n    hp += 10;\n    if (hp > 100) {\n        hp = 100;\n    }\n    return hp;\n}\n\nvoid RPGCharacter::gain_exp(int amount) {\n    while (amount != 0) {\n        if (exp + amount >= level * 100) {\n            amount -= (level * 100 - exp);\n            level_up();\n        }\n        else {\n            exp += amount;\n            amount = 0;\n        }\n    }\n}\n\nvoid RPGCharacter::level_up() {\n    if (level < 100) {\n        level++;\n        exp = 0;\n        hp += 20;\n        attack_power += 5;\n        defense += 5;\n    }\n}\n\nbool RPGCharacter::is_alive() const {\n    return hp > 0;\n}\n\nint RPGCharacter::get_hp() const {\n    return hp;\n}\n\nint RPGCharacter::get_exp() const {\n    return exp;\n}\n\nint RPGCharacter::get_attack_power() const {\n    return attack_power;\n}\n\nint RPGCharacter::get_defense() const {\n    return defense;\n}\n\nint RPGCharacter::get_level() const {\n    return level;\n}\n\nvoid RPGCharacter::set_hp(int x)\n{\n    this->hp = x;\n}",
  "Server": "\n#include <algorithm>\n#include <stdexcept>\n#include <vector>\n#include <map>\n#include <string>\n\nclass Server {\npublic:\n    Server();\n\n    std::vector<int> add_white_list(int addr);\n    std::vector<int> del_white_list(int addr);\n    int recv(const std::map<std::string, std::string>& info);\n    std::string send(const std::map<std::string, std::string>& info);\n    std::map<std::string, std::string> show(const std::string& type) const;\n\n    std::vector<int> white_list;\n    std::map<std::string, std::string> send_struct;\n    std::map<std::string, std::string> receive_struct;\n};\n\nServer::Server() {\n    white_list = {};\n    send_struct = {};\n    receive_struct = {};\n}\n\nstd::vector<int> Server::add_white_list(int addr) {\n    if (std::find(white_list.begin(), white_list.end(), addr) != white_list.end()) {\n        return {};\n    }\n    else {\n        white_list.push_back(addr);\n        return white_list;\n    }\n}\n\nstd::vector<int> Server::del_white_list(int addr) {\n    auto it = std::find(white_list.begin(), white_list.end(), addr);\n    if (it == white_list.end()) {\n        return {};\n    }\n    else {\n        white_list.erase(it);\n        return white_list;\n    }\n}\n\nint Server::recv(const std::map<std::string, std::string>& info) {\n    if (info.find(\"addr\") == info.end() || info.find(\"content\") == info.end()) {\n        return -1;\n    }\n    int addr = std::stoi(info.at(\"addr\"));\n    std::string content = info.at(\"content\");\n\n    if (std::find(white_list.begin(), white_list.end(), addr) == white_list.end()) {\n        return 0;  \n    }\n    else {\n        receive_struct = { {\"addr\", std::to_string(addr)}, {\"content\", content} };\n        return 1;  \n    }\n}\n\nstd::string Server::send(const std::map<std::string, std::string>& info) {\n    if (info.find(\"addr\") == info.end() || info.find(\"content\") == info.end()) {\n        return \"info structure is not correct\";\n    }\n    send_struct = { {\"addr\", info.at(\"addr\")}, {\"content\", info.at(\"content\")} };\n    return \"\";\n}\n\nstd::map<std::string, std::string> Server::show(const std::string& type) const {\n    if (type == \"send\") {\n        return send_struct;\n    }\n    else if (type == \"receive\") {\n        return receive_struct;\n    }\n    else {\n        return {};\n    }\n}\n",
  "ShoppingCart": "#include <unordered_map>\n#include <string>\n\nclass ShoppingCart {\npublic:\n    ShoppingCart();\n\n    void add_item(const std::string& item, double price, int quantity = 1);\n    void remove_item(const std::string& item, int quantity = 1);\n    std::unordered_map<std::string, std::pair<double, int>> view_items() const;\n    double total_price() const;\n\nprivate:\n    std::unordered_map<std::string, std::pair<double, int>> items;\n};\n\nShoppingCart::ShoppingCart() {}\n\nvoid ShoppingCart::add_item(const std::string& item, double price, int quantity) {\n    if (items.find(item) != items.end()) {\n        items[item] = { price, quantity };\n    }\n    else {\n        items[item] = { price, quantity };\n    }\n}\n\nvoid ShoppingCart::remove_item(const std::string& item, int quantity) {\n    auto it = items.find(item);\n    if (it != items.end()) {\n        it->second.second -= quantity;\n        if (it->second.second <= 0) {\n            items.erase(it);\n        }\n    }\n}\n\nstd::unordered_map<std::string, std::pair<double, int>> ShoppingCart::view_items() const {\n    return items;\n}\n\ndouble ShoppingCart::total_price() const {\n    double total = 0.0;\n    for (const auto& [item, info] : items) {\n        total += info.first * info.second;\n    }\n    return total;\n}\n",
  "SignInSystem": "#include <unordered_map>\n#include <vector>\n#include <string>\n\nclass SignInSystem {\npublic:\n    SignInSystem();\n    bool add_user(const std::string& username);\n    bool sign_in(const std::string& username);\n    bool check_sign_in(const std::string& username);\n    bool all_signed_in();\n    std::vector<std::string> all_not_signed_in();\n\nprivate:\n    std::unordered_map<std::string, bool> users;\n};\n\nSignInSystem::SignInSystem() {}\n\nbool SignInSystem::add_user(const std::string& username) {\n    auto result = users.find(username);\n    if (result != users.end()) {\n        return false;\n    }\n    else {\n        users[username] = false;\n        return true;\n    }\n}\n\nbool SignInSystem::sign_in(const std::string& username) {\n    auto result = users.find(username);\n    if (result == users.end()) {\n        return false;\n    }\n    else {\n        users[username] = true;\n        return true;\n    }\n}\n\nbool SignInSystem::check_sign_in(const std::string& username) {\n    auto result = users.find(username);\n    if (result == users.end()) {\n        return false;\n    }\n    else {\n        return result->second;\n    }\n}\n\nbool SignInSystem::all_signed_in() {\n    for (const auto& pair : users) {\n        if (!pair.second) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<std::string> SignInSystem::all_not_signed_in() {\n    std::vector<std::string> not_signed_in_users;\n    for (const auto& pair : users) {\n        if (!pair.second) {\n            not_signed_in_users.push_back(pair.first);\n        }\n    }\n    return not_signed_in_users;\n}\n",
  "Snake": "\n#include <algorithm>\n#include <random>\n#include <ctime>\n\n#include <vector>\n#include <utility>\n\nclass Snake {\npublic:\n    Snake(int screenWidth, int screenHeight, int blockSize, std::pair<int, int> foodPosition);\n\n    void move(std::pair<int, int> direction);\n    void random_food_position();\n    void reset();\n    void eat_food();\n\n    int get_length() const;\n    std::vector<std::pair<int, int>> get_positions() const;\n    int get_score() const;\n    std::pair<int, int> get_food_position() const;\n    int get_SCREEN_WIDTH() const;\n    int get_SCREEN_HEIGHT() const;\n    int get_BLOCK_SIZE() const;\n\n    int length;\n    int SCREEN_WIDTH;\n    int SCREEN_HEIGHT;\n    int BLOCK_SIZE;\n    std::vector<std::pair<int, int>> positions;\n    int score;\n    std::pair<int, int> food_position;\n};\n\nSnake::Snake(int screenWidth, int screenHeight, int blockSize, std::pair<int, int> foodPosition)\n    : length(1), SCREEN_WIDTH(screenWidth), SCREEN_HEIGHT(screenHeight), BLOCK_SIZE(blockSize), score(0), food_position(foodPosition) {\n    positions.push_back(std::make_pair(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2));\n}\n\nvoid Snake::move(std::pair<int, int> direction) {\n    auto cur = positions[0];\n    int x = direction.first;\n    int y = direction.second;\n\n    auto newPos = std::make_pair(\n        (cur.first + x * BLOCK_SIZE) % SCREEN_WIDTH,\n        (cur.second + y * BLOCK_SIZE) % SCREEN_HEIGHT\n    );\n\n    if (newPos == food_position) {\n        eat_food();\n    }\n\n    if (positions.size() > 2 && std::find(positions.begin() + 2, positions.end(), newPos) != positions.end()) {\n        reset();\n    }\n    else {\n        positions.insert(positions.begin(), newPos);\n        if (positions.size() > static_cast<size_t>(length)) {\n            positions.pop_back();\n        }\n    }\n}\n\nvoid Snake::random_food_position() {\n    std::srand(static_cast<unsigned>(std::time(nullptr)));\n    do {\n        food_position = std::make_pair(\n            (std::rand() % (SCREEN_WIDTH / BLOCK_SIZE)) * BLOCK_SIZE,\n            (std::rand() % (SCREEN_HEIGHT / BLOCK_SIZE)) * BLOCK_SIZE\n        );\n    } while (std::find(positions.begin(), positions.end(), food_position) != positions.end());\n}\n\nvoid Snake::reset() {\n    length = 1;\n    positions = { std::make_pair(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2) };\n    score = 0;\n    random_food_position();\n}\n\nvoid Snake::eat_food() {\n    length++;\n    score += 100;\n    random_food_position();\n}\n\nint Snake::get_length() const {\n    return length;\n}\n\nstd::vector<std::pair<int, int>> Snake::get_positions() const {\n    return positions;\n}\n\nint Snake::get_score() const {\n    return score;\n}\n\nstd::pair<int, int> Snake::get_food_position() const {\n    return food_position;\n}\n\nint Snake::get_SCREEN_WIDTH() const {\n    return SCREEN_WIDTH;\n}\n\nint Snake::get_SCREEN_HEIGHT() const {\n    return SCREEN_HEIGHT;\n}\n\nint Snake::get_BLOCK_SIZE() const {\n    return BLOCK_SIZE;\n}\n",
  "SplitSentence": "\n#include <boost/regex.hpp>\n#include <sstream>\n#include <algorithm>\n#include <cctype>\n\n#include <string>\n#include <vector>\n\nclass SplitSentence {\npublic:\n    std::vector<std::string> split_sentences(const std::string& sentences_string);\n    int count_words(const std::string& sentence);\n    int process_text_file(const std::string& sentences_string);\n};\n\n\nstd::vector<std::string> SplitSentence::split_sentences(const std::string& sentences_string) {\n    std::vector<std::string> sentences;\n    boost::regex regex(R\"((?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s)\");\n    boost::sregex_token_iterator iter(sentences_string.begin(), sentences_string.end(), regex, -1);\n    boost::sregex_token_iterator end;\n\n    for (; iter != end; ++iter) {\n        std::string sentence = iter->str();\n        \n        if (!sentence.empty()) {\n            \n            sentence.erase(std::find_if(sentence.rbegin(), sentence.rend(), [](char ch) {\n                return !std::isspace(ch);\n                }).base(), sentence.end());\n            if (!sentence.empty()) {\n                sentences.push_back(sentence);\n            }\n        }\n    }\n\n    return sentences;\n}\n\n\nint SplitSentence::count_words(const std::string& sentence) {\n    std::string cleaned_sentence;\n    std::remove_copy_if(sentence.begin(), sentence.end(), std::back_inserter(cleaned_sentence),\n        [](char c) { return !std::isalpha(c) && !std::isspace(c); });\n\n    std::istringstream stream(cleaned_sentence);\n    std::string word;\n    int count = 0;\n\n    while (stream >> word) {\n        ++count;\n    }\n\n    return count;\n}\n\n\nint SplitSentence::process_text_file(const std::string& sentences_string) {\n    std::vector<std::string> sentences = split_sentences(sentences_string);\n    int max_count = 0;\n\n    for (const auto& sentence : sentences) {\n        int count = count_words(sentence);\n        if (count > max_count) {\n            max_count = count;\n        }\n    }\n\n    return max_count;\n}\n",
  "SQLGenerator": "\n#include <sstream>\n#include <algorithm>\n\n#include <string>\n#include <vector>\n#include <map>\n\nclass SQLGenerator {\npublic:\n    SQLGenerator(const std::string& table_name);\n\n    std::string select(const std::vector<std::string>& fields = {}, const std::string& condition = \"\") const;\n    std::string insert(const std::map<std::string, std::string>& data) const;\n    std::string update(const std::map<std::string, std::string>& data, const std::string& condition) const;\n    std::string delete_query(const std::string& condition) const;\n    std::string select_female_under_age(int age) const;\n    std::string select_by_age_range(int min_age, int max_age) const;\n\nprivate:\n    std::string table_name;\n};\n\n\nSQLGenerator::SQLGenerator(const std::string& table_name) : table_name(table_name) {}\n\n\nstd::string SQLGenerator::select(const std::vector<std::string>& fields, const std::string& condition) const {\n    std::string fields_str = \"*\";\n    if (!fields.empty()) {\n        fields_str = fields[0];\n        for (size_t i = 1; i < fields.size(); ++i) {\n            fields_str += \", \" + fields[i];\n        }\n    }\n\n    std::string sql = \"SELECT \" + fields_str + \" FROM \" + table_name;\n    if (!condition.empty()) {\n        sql += \" WHERE \" + condition;\n    }\n    return sql + \";\";\n}\n\n\nstd::string SQLGenerator::insert(const std::map<std::string, std::string>& data) const {\n    std::ostringstream fields_stream, values_stream;\n\n    for (auto it = data.begin(); it != data.end(); ++it) {\n        if (it != data.begin()) {\n            fields_stream << \", \";\n            values_stream << \", \";\n        }\n        fields_stream << it->first;\n        values_stream << \"'\" << it->second << \"'\";\n    }\n\n    std::string sql = \"INSERT INTO \" + table_name + \" (\" + fields_stream.str() + \") VALUES (\" + values_stream.str() + \")\";\n    return sql + \";\";\n}\n\n\nstd::string SQLGenerator::update(const std::map<std::string, std::string>& data, const std::string& condition) const {\n    std::ostringstream set_clause_stream;\n\n    for (auto it = data.begin(); it != data.end(); ++it) {\n        if (it != data.begin()) {\n            set_clause_stream << \", \";\n        }\n        set_clause_stream << it->first << \" = '\" << it->second << \"'\";\n    }\n\n    std::string sql = \"UPDATE \" + table_name + \" SET \" + set_clause_stream.str();\n    if (!condition.empty()) {\n        sql += \" WHERE \" + condition;\n    }\n    return sql + \";\";\n}\n\n\nstd::string SQLGenerator::delete_query(const std::string& condition) const {\n    std::string sql = \"DELETE FROM \" + table_name;\n    if (!condition.empty()) {\n        sql += \" WHERE \" + condition;\n    }\n    return sql + \";\";\n}\n\n\nstd::string SQLGenerator::select_female_under_age(int age) const {\n    std::string condition = \"age < \" + std::to_string(age) + \" AND gender = 'female'\";\n    return select({}, condition);\n}\n\n\nstd::string SQLGenerator::select_by_age_range(int min_age, int max_age) const {\n    std::string condition = \"age BETWEEN \" + std::to_string(min_age) + \" AND \" + std::to_string(max_age);\n    return select({}, condition);\n}\n",
  "SQLQueryBuilder": "#include <string>\n#include <vector>\n#include <sstream>\n\nclass SQLQueryBuilder {\npublic:\n    static std::string select(const std::string& table, const std::vector<std::string>& columns = { \"*\" }, const std::vector<std::pair<std::string, std::string>>& where = {});\n    static std::string insert(const std::string& table, const std::vector<std::pair<std::string, std::string>>& data);\n    static std::string delete_(const std::string& table, const std::vector<std::pair<std::string, std::string>>& where = {});\n    static std::string update(const std::string& table, const std::vector<std::pair<std::string, std::string>>& data, const std::vector<std::pair<std::string, std::string>>& where = {});\n};\n\n\nstd::string SQLQueryBuilder::select(const std::string& table, const std::vector<std::string>& columns, const std::vector<std::pair<std::string, std::string>>& where) {\n    std::ostringstream query;\n    if (columns.size() == 1 && columns[0] == \"*\") {\n        query << \"SELECT *\";\n    }\n    else {\n        query << \"SELECT \";\n        for (size_t i = 0; i < columns.size(); ++i) {\n            query << columns[i];\n            if (i < columns.size() - 1) {\n                query << \", \";\n            }\n        }\n    }\n    query << \" FROM \" << table;\n    if (!where.empty()) {\n        query << \" WHERE \";\n        bool first = true;\n        for (const auto& [key, value] : where) {\n            if (!first) {\n                query << \" AND \";\n            }\n            query << key << \"='\" << value << \"'\";\n            first = false;\n        }\n    }\n    return query.str();\n}\n\nstd::string SQLQueryBuilder::insert(const std::string& table, const std::vector<std::pair<std::string, std::string>>& data) {\n    std::ostringstream query;\n    query << \"INSERT INTO \" << table << \" (\";\n    for (size_t i = 0; i < data.size(); ++i) {\n        query << data[i].first;\n        if (i < data.size() - 1) {\n            query << \", \";\n        }\n    }\n    query << \") VALUES (\";\n    for (size_t i = 0; i < data.size(); ++i) {\n        query << \"'\" << data[i].second << \"'\";\n        if (i < data.size() - 1) {\n            query << \", \";\n        }\n    }\n    query << \")\";\n    return query.str();\n}\n\nstd::string SQLQueryBuilder::delete_(const std::string& table, const std::vector<std::pair<std::string, std::string>>& where) {\n    std::ostringstream query;\n    query << \"DELETE FROM \" << table;\n    if (!where.empty()) {\n        query << \" WHERE \";\n        for (size_t i = 0; i < where.size(); ++i) {\n            query << where[i].first << \"='\" << where[i].second << \"'\";\n            if (i < where.size() - 1) {\n                query << \" AND \";\n            }\n        }\n    }\n    return query.str();\n}\n\nstd::string SQLQueryBuilder::update(const std::string& table, const std::vector<std::pair<std::string, std::string>>& data, const std::vector<std::pair<std::string, std::string>>& where) {\n    std::ostringstream query;\n    query << \"UPDATE \" << table << \" SET \";\n    for (size_t i = 0; i < data.size(); ++i) {\n        query << data[i].first << \"='\" << data[i].second << \"'\";\n        if (i < data.size() - 1) {\n            query << \", \";\n        }\n    }\n    if (!where.empty()) {\n        query << \" WHERE \";\n        for (size_t i = 0; i < where.size(); ++i) {\n            query << where[i].first << \"='\" << where[i].second << \"'\";\n            if (i < where.size() - 1) {\n                query << \" AND \";\n            }\n        }\n    }\n    return query.str();\n}\n",
  "Statistics3": "\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <numeric>\n#include <stdexcept>\n\n#include <vector>\n\nclass Statistics3 {\npublic:\n    static double median(const std::vector<int>& data);\n    static std::vector<int> mode(const std::vector<int>& data);\n    static double correlation(const std::vector<int>& x, const std::vector<int>& y);\n    static double mean(const std::vector<int>& data);\n    static std::vector<std::vector<double>> correlation_matrix(const std::vector<std::vector<int>>& data);\n    static double standard_deviation(const std::vector<int>& data);\n    static std::vector<double> z_score(const std::vector<int>& data);\n};\n\n\ndouble Statistics3::mean(const std::vector<int>& data) {\n    if (data.empty()) return NAN;\n    return static_cast<double>(std::accumulate(data.begin(), data.end(), 0)) / data.size();\n}\n\n\ndouble variance(const std::vector<int>& data, double mean_value) {\n    double variance_sum = 0.0;\n    for (int x : data) {\n        double diff = x - mean_value;\n        variance_sum += diff * diff;\n    }\n    return variance_sum / (data.size() - 1);\n}\n\n\ndouble Statistics3::median(const std::vector<int>& data) {\n    std::vector<int> sorted_data = data;\n    std::sort(sorted_data.begin(), sorted_data.end());\n    size_t n = sorted_data.size();\n    if (n % 2 == 1) {\n        return sorted_data[n / 2];\n    }\n    else {\n        return (sorted_data[n / 2 - 1] + sorted_data[n / 2]) / 2.0;\n    }\n}\n\n\nstd::vector<int> Statistics3::mode(const std::vector<int>& data) {\n    std::map<int, int> counts;\n    for (int value : data) {\n        counts[value]++;\n    }\n    int max_count = 0;\n    for (const auto& pair : counts) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    std::vector<int> mode_values;\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) {\n            mode_values.push_back(pair.first);\n        }\n    }\n    return mode_values;\n}\n\n\ndouble Statistics3::correlation(const std::vector<int>& x, const std::vector<int>& y) {\n    size_t n = x.size();\n    if (n != y.size()) throw std::invalid_argument(\"Vectors must be of the same length\");\n\n    double mean_x = mean(x);\n    double mean_y = mean(y);\n    double numerator = 0.0;\n    double denominator_x = 0.0;\n    double denominator_y = 0.0;\n\n    for (size_t i = 0; i < n; ++i) {\n        double diff_x = x[i] - mean_x;\n        double diff_y = y[i] - mean_y;\n        numerator += diff_x * diff_y;\n        denominator_x += diff_x * diff_x;\n        denominator_y += diff_y * diff_y;\n    }\n\n    double denominator = std::sqrt(denominator_x * denominator_y);\n    if (denominator == 0) return NAN;\n    return numerator / denominator;\n}\n\n\nstd::vector<std::vector<double>> Statistics3::correlation_matrix(const std::vector<std::vector<int>>& data) {\n    size_t num_rows = data.size();\n    size_t num_cols = data[0].size();\n    std::vector<std::vector<double>> matrix(num_cols, std::vector<double>(num_cols, 0.0));\n\n    for (size_t i = 0; i < num_cols; ++i) {\n        for (size_t j = 0; j < num_cols; ++j) {\n            std::vector<int> column1(num_rows);\n            std::vector<int> column2(num_rows);\n            for (size_t k = 0; k < num_rows; ++k) {\n                column1[k] = data[k][i];\n                column2[k] = data[k][j];\n            }\n            matrix[i][j] = correlation(column1, column2);\n        }\n    }\n    return matrix;\n}\n\n\ndouble Statistics3::standard_deviation(const std::vector<int>& data) {\n    size_t n = data.size();\n    if (n < 2) return NAN;\n    double mean_value = mean(data);\n    double var = variance(data, mean_value);\n    return std::sqrt(var);\n}\n\n\nstd::vector<double> Statistics3::z_score(const std::vector<int>& data) {\n    double mean_value = mean(data);\n    double std_deviation = standard_deviation(data);\n    if (std_deviation == NAN || std_deviation == 0) return std::vector<double>(data.size(), NAN);\n\n    std::vector<double> z_scores;\n    z_scores.reserve(data.size());\n    for (int x : data) {\n        z_scores.push_back((x - mean_value) / std_deviation);\n    }\n    return z_scores;\n}\n",
  "StockPortfolioTracker": "#include <vector>\n#include <string>\n\n\nstruct Stock {\n    std::string name;\n    double price;\n    int quantity;\n\n    \n    bool operator==(const Stock& other) const {\n        return name == other.name && price == other.price && quantity == other.quantity;\n    }\n};\n\n\nstruct StockSummary {\n    std::string name;\n    double value;\n\n    \n    bool operator==(const StockSummary& other) const {\n        return name == other.name && value == other.value;\n    }\n};\n\n\nclass StockPortfolioTracker {\npublic:\n    explicit StockPortfolioTracker(double cash_balance);\n\n    void add_stock(const Stock& stock);\n    bool remove_stock(const Stock& stock);\n    bool buy_stock(const Stock& stock);\n    bool sell_stock(const Stock& stock);\n    double calculate_portfolio_value() const;\n    std::pair<double, std::vector<StockSummary>> get_portfolio_summary() const;\n    double get_stock_value(const Stock& stock) const;\n    const std::vector<Stock>& get_portfolio() const;\n    double get_cash_balance() const;\n    void set_portfolio(const std::vector<Stock>& portfolio);\n\nprivate:\n    std::vector<Stock> portfolio;\n    double cash_balance;\n};\n\nStockPortfolioTracker::StockPortfolioTracker(double cash_balance)\n    : cash_balance(cash_balance) {\n}\n\nvoid StockPortfolioTracker::add_stock(const Stock& stock) {\n    for (auto& pf : portfolio) {\n        if (pf.name == stock.name) {\n            pf.quantity += stock.quantity;\n            return;\n        }\n    }\n    portfolio.push_back(stock);\n}\n\nbool StockPortfolioTracker::remove_stock(const Stock& stock) {\n    for (auto it = portfolio.begin(); it != portfolio.end(); ++it) {\n        if (it->name == stock.name && it->quantity >= stock.quantity) {\n            it->quantity -= stock.quantity;\n            if (it->quantity == 0) {\n                portfolio.erase(it);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nbool StockPortfolioTracker::buy_stock(const Stock& stock) {\n    if (stock.price * stock.quantity > cash_balance) {\n        return false;\n    }\n    else {\n        add_stock(stock);\n        cash_balance -= stock.price * stock.quantity;\n        return true;\n    }\n}\n\nbool StockPortfolioTracker::sell_stock(const Stock& stock) {\n    if (!remove_stock(stock)) {\n        return false;\n    }\n    cash_balance += stock.price * stock.quantity;\n    return true;\n}\n\ndouble StockPortfolioTracker::calculate_portfolio_value() const {\n    double total_value = cash_balance;\n    for (const auto& stock : portfolio) {\n        total_value += stock.price * stock.quantity;\n    }\n    return total_value;\n}\n\nstd::pair<double, std::vector<StockSummary>> StockPortfolioTracker::get_portfolio_summary() const {\n    std::vector<StockSummary> summary;\n    for (const auto& stock : portfolio) {\n        summary.push_back({ stock.name, get_stock_value(stock) });\n    }\n    return { calculate_portfolio_value(), summary };\n}\n\ndouble StockPortfolioTracker::get_stock_value(const Stock& stock) const {\n    return stock.price * stock.quantity;\n}\n\nconst std::vector<Stock>& StockPortfolioTracker::get_portfolio() const {\n    return portfolio;\n}\n\ndouble StockPortfolioTracker::get_cash_balance() const {\n    return cash_balance;\n}\n\nvoid StockPortfolioTracker::set_portfolio(const std::vector<Stock>& p) {\n    portfolio = p;\n}\n",
  "StudentDatabaseProcessor": "\n#include <iostream>\n#include <sstream>\n\n#include <string>\n#include <map>\n#include <vector>\n#include <winsqlite/winsqlite3.h>\n\nclass StudentDatabaseProcessor {\npublic:\n    explicit StudentDatabaseProcessor(const std::string& database_name);\n    void create_student_table();\n    void insert_student(const std::map<std::string, std::string>& student_data);\n    std::vector<std::map<std::string, std::string>> search_student_by_name(const std::string& name);\n    void delete_student_by_name(const std::string& name);\n\nprivate:\n    std::string database_name;\n\n    void execute_query(const std::string& query, const std::vector<std::string>& params);\n    std::vector<std::vector<std::string>> query_result(const std::string& query, const std::vector<std::string>& params);\n};\n\nStudentDatabaseProcessor::StudentDatabaseProcessor(const std::string& database_name)\n    : database_name(database_name) {}\n\nvoid StudentDatabaseProcessor::create_student_table() {\n    std::string create_table_query = R\"(\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n    )\";\n\n    execute_query(create_table_query, {});\n}\n\nvoid StudentDatabaseProcessor::insert_student(const std::map<std::string, std::string>& student_data) {\n    std::string insert_query = R\"(\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n    )\";\n\n    std::vector<std::string> params = {\n        student_data.at(\"name\"),\n        student_data.at(\"age\"),\n        student_data.at(\"gender\"),\n        student_data.at(\"grade\")\n    };\n\n    execute_query(insert_query, params);\n}\n\nstd::vector<std::map<std::string, std::string>> StudentDatabaseProcessor::search_student_by_name(const std::string& name) {\n    std::string select_query = R\"(\n        SELECT * FROM students WHERE name = ?\n    )\";\n\n    std::vector<std::string> params = { name };\n    std::vector<std::vector<std::string>> results = query_result(select_query, params);\n\n    std::vector<std::map<std::string, std::string>> students;\n    for (const auto& row : results) {\n        std::map<std::string, std::string> student;\n        student[\"id\"] = row[0];\n        student[\"name\"] = row[1];\n        student[\"age\"] = row[2];\n        student[\"gender\"] = row[3];\n        student[\"grade\"] = row[4];\n        students.push_back(student);\n    }\n\n    return students;\n}\n\nvoid StudentDatabaseProcessor::delete_student_by_name(const std::string& name) {\n    std::string delete_query = R\"(\n        DELETE FROM students WHERE name = ?\n    )\";\n\n    std::vector<std::string> params = { name };\n    execute_query(delete_query, params);\n}\n\nvoid StudentDatabaseProcessor::execute_query(const std::string& query, const std::vector<std::string>& params) {\n    sqlite3* conn;\n    sqlite3_open(database_name.c_str(), &conn);\n\n    sqlite3_stmt* stmt;\n    sqlite3_prepare_v2(conn, query.c_str(), -1, &stmt, nullptr);\n\n    for (size_t i = 0; i < params.size(); ++i) {\n        sqlite3_bind_text(stmt, static_cast<int>(i + 1), params[i].c_str(), -1, SQLITE_STATIC);\n    }\n\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n    sqlite3_close(conn);\n}\n\nstd::vector<std::vector<std::string>> StudentDatabaseProcessor::query_result(const std::string& query, const std::vector<std::string>& params) {\n    sqlite3* conn;\n    sqlite3_open(database_name.c_str(), &conn);\n\n    sqlite3_stmt* stmt;\n    sqlite3_prepare_v2(conn, query.c_str(), -1, &stmt, nullptr);\n\n    for (size_t i = 0; i < params.size(); ++i) {\n        sqlite3_bind_text(stmt, static_cast<int>(i + 1), params[i].c_str(), -1, SQLITE_STATIC);\n    }\n\n    std::vector<std::vector<std::string>> results;\n    int result = sqlite3_step(stmt);\n    while (result == SQLITE_ROW) {\n        std::vector<std::string> row;\n        for (int i = 0; i < sqlite3_column_count(stmt); ++i) {\n            row.push_back(reinterpret_cast<const char*>(sqlite3_column_text(stmt, i)));\n        }\n        results.push_back(row);\n        result = sqlite3_step(stmt);\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(conn);\n\n    return results;\n}\n",
  "TextFileProcessor": "\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <cctype>\n\n#include <string>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\nusing namespace std;\n\nclass TextFileProcessor {\npublic:\n    explicit TextFileProcessor(const string& filename);\n\n    json read_file_as_json();\n    virtual std::string read_file() const;\n    virtual void write_file(const std::string& content);\n    string process_file();\n\nprivate:\n    string filename_;\n};\n\n\nTextFileProcessor::TextFileProcessor(const string& filename) : filename_(filename) {}\n\n\njson TextFileProcessor::read_file_as_json() {\n    ifstream file(filename_);\n    json j;\n    file >> j;\n    return j;\n}\n\n\n\nstring TextFileProcessor::read_file() const{\n    ifstream file(filename_);\n    stringstream buffer;\n    buffer << file.rdbuf();\n    return buffer.str();\n}\n\n\nvoid TextFileProcessor::write_file(const string& content) {\n    ofstream file(filename_);\n    file << content;\n}\n\n\nstring TextFileProcessor::process_file() {\n    string content = read_file();\n    string result;\n\n    for (char c : content) {\n        if (isalpha(c)) {\n            result += c;\n        }\n    }\n\n    write_file(result);\n    return result;\n}\n",
  "Thermostat": "#include <string>\n\nclass Thermostat {\npublic:\n    Thermostat(double current_temperature, double target_temperature, const std::string& mode);\n\n    double get_target_temperature() const;\n    void set_target_temperature(double temperature);\n\n    std::string get_mode() const;\n    bool set_mode(const std::string& mode);\n\n    void auto_set_mode();\n    bool auto_check_conflict();\n    int simulate_operation();\n\n    double current_temperature;\n    double target_temperature;\n    std::string mode;\n};\nThermostat::Thermostat(double current_temperature, double target_temperature, const std::string& mode)\n    : current_temperature(current_temperature), target_temperature(target_temperature), mode(mode) {}\n\ndouble Thermostat::get_target_temperature() const {\n    return target_temperature;\n}\n\nvoid Thermostat::set_target_temperature(double temperature) {\n    target_temperature = temperature;\n}\n\nstd::string Thermostat::get_mode() const {\n    return mode;\n}\n\nbool Thermostat::set_mode(const std::string& new_mode) {\n    if (new_mode == \"heat\" || new_mode == \"cool\") {\n        mode = new_mode;\n        return true;\n    }\n    return false;\n}\n\nvoid Thermostat::auto_set_mode() {\n    if (current_temperature < target_temperature) {\n        mode = \"heat\";\n    }\n    else {\n        mode = \"cool\";\n    }\n}\n\nbool Thermostat::auto_check_conflict() {\n    if (current_temperature > target_temperature) {\n        if (mode == \"cool\") {\n            return true;\n        }\n        else {\n            auto_set_mode();\n            return false;\n        }\n    }\n    else {\n        if (mode == \"heat\") {\n            return true;\n        }\n        else {\n            auto_set_mode();\n            return false;\n        }\n    }\n}\n\nint Thermostat::simulate_operation() {\n    auto_set_mode();\n    int use_time = 0;\n    if (mode == \"heat\") {\n        while (current_temperature < target_temperature) {\n            current_temperature += 1;\n            use_time += 1;\n        }\n    }\n    else {\n        while (current_temperature > target_temperature) {\n            current_temperature -= 1;\n            use_time += 1;\n        }\n    }\n    return use_time;\n}\n",
  "TicTacToe": "#include <vector>\n#include <string>\n\nclass TicTacToe {\npublic:\n    TicTacToe(int N = 3);\n    bool make_move(int row, int col);\n    char check_winner();\n    bool is_board_full();\n    char get_current_player() const;\n\nprivate:\n    std::vector<std::vector<char>> board;\n    char current_player;\n};\n\nTicTacToe::TicTacToe(int N) : board(3, std::vector<char>(N, ' ')), current_player('X') {}\n\n\nbool TicTacToe::make_move(int row, int col) {\n    if (board[row][col] == ' ') {\n        board[row][col] = current_player;\n        current_player = (current_player == 'X') ? 'O' : 'X';\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\nchar TicTacToe::check_winner() {\n    \n    for (const auto& row : board) {\n        if (row[0] != ' ' && row[0] == row[1] && row[1] == row[2]) {\n            return row[0];\n        }\n    }\n    \n    for (int col = 0; col < 3; ++col) {\n        if (board[0][col] != ' ' && board[0][col] == board[1][col] && board[1][col] == board[2][col]) {\n            return board[0][col];\n        }\n    }\n    \n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        return board[0][0];\n    }\n    \n    if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        return board[0][2];\n    }\n    return '\\0'; \n}\n\n\n\nbool TicTacToe::is_board_full() {\n    for (const auto& row : board) {\n        if (std::find(row.begin(), row.end(), ' ') != row.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nchar TicTacToe::get_current_player() const {\n    return current_player;\n}\n",
  "TimeUtils": "#include <string>\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n#include <sstream>\n#include <time.h>\n\nclass TimeUtils {\npublic:\n    TimeUtils();\n\n    std::string get_current_time() const;\n    std::string get_current_date() const;\n    std::string add_seconds(int seconds);\n    std::tm string_to_datetime(const std::string& str) const;\n    std::string datetime_to_string(const std::tm& datetime) const;\n    int get_minutes(const std::string& string_time1, const std::string& string_time2) const;\n    std::string get_format_time(int year, int month, int day, int hour, int minute, int second) const;\n\n    std::tm datetime;\n\n};\n\nTimeUtils::TimeUtils() {\n    auto now = std::chrono::system_clock::now();\n    auto time_t_now = std::chrono::system_clock::to_time_t(now);\n    datetime = *std::localtime(&time_t_now);\n}\n\nstd::string TimeUtils::get_current_time() const {\n    std::stringstream ss;\n    ss << std::put_time(&datetime, \"%H:%M:%S\");\n    return ss.str();\n}\n\nstd::string TimeUtils::get_current_date() const {\n    std::stringstream ss;\n    ss << std::put_time(&datetime, \"%Y-%m-%d\");\n    return ss.str();\n}\n\nstd::string TimeUtils::add_seconds(int seconds) {\n    auto time_t_now = std::mktime(const_cast<std::tm*>(&datetime));\n    time_t_now += seconds;\n    std::tm new_datetime = *std::localtime(&time_t_now);\n    datetime = new_datetime;\n    std::stringstream ss;\n    ss << std::put_time(&new_datetime, \"%H:%M:%S\");\n    return ss.str();\n}\n\nstd::tm TimeUtils::string_to_datetime(const std::string& str) const {\n    std::tm tm = {};\n    std::istringstream ss(str);\n    ss >> std::get_time(&tm, \"%Y-%m-%d %H:%M:%S\");\n    return tm;\n}\n\nstd::string TimeUtils::datetime_to_string(const std::tm& datetime) const {\n    std::stringstream ss;\n    ss << std::put_time(&datetime, \"%Y-%m-%d %H:%M:%S\");\n    return ss.str();\n}\n\nint TimeUtils::get_minutes(const std::string& string_time1, const std::string& string_time2) const {\n    std::tm time1 = string_to_datetime(string_time1);\n    std::tm time2 = string_to_datetime(string_time2);\n\n    auto time_t1 = std::mktime(&time1);\n    auto time_t2 = std::mktime(&time2);\n\n    return std::difftime(time_t2, time_t1) / 60;\n}\n\nstd::string TimeUtils::get_format_time(int year, int month, int day, int hour, int minute, int second) const {\n    std::tm tm = {};\n    tm.tm_year = year - 1900;\n    tm.tm_mon = month - 1;\n    tm.tm_mday = day;\n    tm.tm_hour = hour;\n    tm.tm_min = minute;\n    tm.tm_sec = second;\n\n    std::stringstream ss;\n    ss << std::put_time(&tm, \"%Y-%m-%d %H:%M:%S\");\n    return ss.str();\n}\n",
  "TriCalculator": "\n#include <cmath>\n#include <limits>\n#include <iostream>\n\nclass TriCalculator{\npublic:\n    TriCalculator();\n    double cos(double x);\n    int factorial(int a);\n    double taylor(double x, int n);\n    double sin(double x);\n    double tan(double x);\n\nprivate:\n    static constexpr double PI = 3.14159265358979323846;\n    double round(double value, int precision);\n};\n\n\ndouble TriCalculator::round(double value, int precision) {\n    double factor = std::pow(10.0, precision);\n    return std::round(value * factor) / factor;\n}\n\nTriCalculator::TriCalculator() {\n    \n}\n\ndouble TriCalculator::cos(double x) {\n    double result = taylor(x, 17);\n    std::cout << \"Taylor result for cos: \" << result << std::endl;\n    return round(result, 10);\n}\n\nint TriCalculator::factorial(int a) {\n    if (a < 0) return 0; \n    if (a == 0) return 1; \n    int b = 1;\n    for (int i = 1; i <= a; ++i) {\n        b *= i;\n    }\n    return b;\n}\n\ndouble TriCalculator::taylor(double x, int n) {\n    double a = 0.0; \n    x = x / 180.0 * PI; \n    int sign = 1; \n\n    for (int k = 0; k < n; ++k) {\n        double term = std::pow(x, 2 * k) / factorial(2 * k);\n        if (k % 2 == 0) {\n            a += term;\n        }\n        else {\n            a -= term;\n        }\n    }\n    return a;\n}\n\ndouble TriCalculator::sin(double x) {\n    x = x / 180.0 * PI;\n    double g = 0.0;\n    double t = x;\n    int n = 1;\n\n    while (std::fabs(t) >= 1e-15) {\n        g += t;\n        ++n;\n        t = -t * x * x / ((2 * n - 1) * (2 * n - 2));\n    }\n    return round(g, 10);\n}\n\ndouble TriCalculator::tan(double x) {\n    double cosine = cos(x);\n    if (std::fabs(cosine) > 0.01) {\n        \n        double result = sin(x) / cosine;\n        \n        return round(result, 10);\n    }\n    else {\n        return std::numeric_limits<double>::quiet_NaN(); \n    }\n}\n",
  "TwentyFourPointGame": "\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <algorithm>\n\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <sstream>\n#include <iostream>\n#include <cctype>\n#include <stdexcept>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <unordered_map>\n\nclass TwentyFourPointGame {\npublic:\n    TwentyFourPointGame();\n    std::vector<int> get_my_cards();\n    std::vector<int> answer(const std::string& expression);\n    bool evaluate_expression(const std::string& expression);\n    void set_nums(std::vector<int> now);\n\nprivate:\n    void generate_cards();\n    std::vector<int> nums;\n};\n\nclass Calculator\n{\npublic:\n    Calculator();\n    double calculate(const std::string& expression);\n    int precedence(char op);\n    std::pair<std::stack<double>, std::stack<char>> apply_operator(std::stack<double> operand_stack, std::stack<char> operator_stack);\n\nprivate:\n    std::unordered_map<char, std::function<double(double, double)>> operators;\n};\n\nTwentyFourPointGame::TwentyFourPointGame() {\n    nums = {};\n    std::srand(std::time(nullptr)); \n}\n\nvoid TwentyFourPointGame::generate_cards() {\n    for (int i = 0; i < 4; ++i) {\n        nums.push_back(std::rand() % 9 + 1); \n    }\n    assert(nums.size() == 4);\n}\n\nstd::vector<int> TwentyFourPointGame::get_my_cards() {\n    nums.clear();\n    generate_cards();\n    return nums;\n}\n\nstd::vector<int> TwentyFourPointGame::answer(const std::string& expression) {\n    if (expression == \"pass\") {\n        return get_my_cards();\n    }\n\n    std::unordered_map<char, int> statistic;\n    for (const char& c : expression) {\n        if (std::isdigit(c) && std::find(nums.begin(), nums.end(), c - '0') != nums.end()) {\n            statistic[c] = statistic[c] + 1;\n        }\n    }\n\n    std::unordered_map<char, int> numsUsed = statistic;\n\n    for (const int& num : nums) {\n        if (numsUsed.find('0' + num) != numsUsed.end() && numsUsed['0' + num] > 0) {\n            numsUsed['0' + num]--;\n        }\n        else {\n            return {};\n        }\n    }\n\n    if (std::all_of(numsUsed.begin(), numsUsed.end(), [](const auto& kv) { return kv.second == 0; })) {\n        if (evaluate_expression(expression)) {\n            return { 1 };\n        }\n        else {\n            return {};\n        }\n    }\n    else {\n        return {};\n    }\n}\n\nbool TwentyFourPointGame::evaluate_expression(const std::string& expression) {\n    try {\n        if (expression[0] < '0' || expression[0] > '9')\n        {\n            if(expression[0] != '(')\n                throw(false);\n        }\n        int kkk = expression.size() - 1;\n        if (expression[kkk] < '0' || expression[kkk] > '9')\n        {\n            if (expression[kkk] != ')')\n                throw(false);\n        }\n        Calculator calculator;\n        double ans = calculator.calculate(expression);\n\n        if (ans == 24.0)\n        {\n            return true;\n        }\n        else return false;\n    }\n    catch (...) {\n        return false;\n    }\n}\n\nvoid TwentyFourPointGame::set_nums(std::vector<int> now)\n{\n    this->nums = now;\n}\n\n\nCalculator::Calculator()\n{\n    operators['+'] = [](double x, double y)\n        { return x + y; };\n    operators['-'] = [](double x, double y)\n        { return x - y; };\n    operators['*'] = [](double x, double y)\n        { return x * y; };\n    operators['/'] = [](double x, double y)\n        { return x / y; };\n    operators['^'] = [](double x, double y)\n        { return std::pow(x, y); };\n}\n\ndouble Calculator::calculate(const std::string& expression)\n{\n    if (expression.empty())\n    {\n        return 0.0; \n    }\n\n    std::stack<double> operand_stack;\n    std::stack<char> operator_stack;\n    std::string num_buffer;\n\n    for (char ch : expression)\n    {\n        if (std::isdigit(ch) || ch == '.')\n        {\n            num_buffer += ch;\n        }\n        else\n        {\n            if (!num_buffer.empty())\n            {\n                operand_stack.push(std::stod(num_buffer));\n                num_buffer.clear();\n            }\n\n            if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^')\n            {\n                while (!operator_stack.empty() && operator_stack.top() != '(' &&\n                    precedence(operator_stack.top()) >= precedence(ch))\n                {\n                    auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n                    operand_stack = std::move(operands);\n                    operator_stack = std::move(operators);\n                }\n                operator_stack.push(ch);\n            }\n            else if (ch == '(')\n            {\n                operator_stack.push(ch);\n            }\n            else if (ch == ')')\n            {\n                while (!operator_stack.empty() && operator_stack.top() != '(')\n                {\n                    auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n                    operand_stack = std::move(operands);\n                    operator_stack = std::move(operators);\n                }\n                operator_stack.pop(); \n            }\n        }\n    }\n\n    if (!num_buffer.empty())\n    {\n        operand_stack.push(std::stod(num_buffer));\n    }\n\n    while (!operator_stack.empty())\n    {\n        auto [operands, operators] = apply_operator(operand_stack, operator_stack);\n        operand_stack = std::move(operands);\n        operator_stack = std::move(operators);\n    }\n\n    return !operand_stack.empty() ? operand_stack.top() : 0.0; \n}\n\nint Calculator::precedence(char op)\n{\n    switch (op)\n    {\n    case '+':\n    case '-':\n        return 1;\n    case '*':\n    case '/':\n        return 2;\n    case '^':\n        return 3;\n    default:\n        return 0;\n    }\n}\n\nstd::pair<std::stack<double>, std::stack<char>> Calculator::apply_operator(std::stack<double> operand_stack, std::stack<char> operator_stack)\n{\n    char op = operator_stack.top();\n    operator_stack.pop();\n\n    double operand2 = operand_stack.top();\n    operand_stack.pop();\n    double operand1 = operand_stack.top();\n    operand_stack.pop();\n\n    double result = operators[op](operand1, operand2);\n    operand_stack.push(result);\n\n    return { operand_stack, operator_stack };\n}",
  "URLHandler": "#include <string>\n#include <map>\n#include <algorithm>\n\nclass URLHandler {\npublic:\n    explicit URLHandler(const std::string& url);\n\n    std::string get_scheme() const;\n    std::string get_host() const;\n    std::string get_path() const;\n    std::map<std::string, std::string> get_query_params() const;\n    std::string get_fragment() const;\n\nprivate:\n    std::string url;\n};\n\nURLHandler::URLHandler(const std::string& url) : url(url) {}\n\nstd::string URLHandler::get_scheme() const {\n    size_t scheme_end = url.find(\"://\");\n    if (scheme_end != std::string::npos) {\n        return url.substr(0, scheme_end);\n    }\n    return \"\";\n}\n\nstd::string URLHandler::get_host() const {\n    size_t scheme_end = url.find(\"://\");\n    if (scheme_end != std::string::npos) {\n        std::string url_without_scheme = url.substr(scheme_end + 3);\n        size_t host_end = url_without_scheme.find(\"/\");\n        if (host_end != std::string::npos) {\n            return url_without_scheme.substr(0, host_end);\n        }\n        return url_without_scheme;\n    }\n    return \"\";\n}\n\nstd::string URLHandler::get_path() const {\n    size_t scheme_end = url.find(\"://\");\n    if (scheme_end != std::string::npos) {\n        std::string url_without_scheme = url.substr(scheme_end + 3);\n        size_t host_end = url_without_scheme.find(\"/\");\n        if (host_end != std::string::npos) {\n            return url_without_scheme.substr(host_end);\n        }\n    }\n    return \"\";\n}\n\nstd::map<std::string, std::string> URLHandler::get_query_params() const {\n    std::map<std::string, std::string> params;\n    size_t query_start = url.find(\"?\");\n    size_t fragment_start = url.find(\"#\");\n    if (query_start != std::string::npos) {\n        std::string query_string = url.substr(query_start + 1, fragment_start - query_start - 1);\n        if (!query_string.empty()) {\n            size_t pos = 0;\n            std::string token;\n            while ((pos = query_string.find(\"&\")) != std::string::npos) {\n                token = query_string.substr(0, pos);\n                size_t equal_pos = token.find(\"=\");\n                if (equal_pos != std::string::npos) {\n                    std::string key = token.substr(0, equal_pos);\n                    std::string value = token.substr(equal_pos + 1);\n                    params[key] = value;\n                }\n                query_string.erase(0, pos + 1);\n            }\n            size_t equal_pos = query_string.find(\"=\");\n            if (equal_pos != std::string::npos) {\n                std::string key = query_string.substr(0, equal_pos);\n                std::string value = query_string.substr(equal_pos + 1);\n                params[key] = value;\n            }\n        }\n    }\n    return params;\n}\n\nstd::string URLHandler::get_fragment() const {\n    size_t fragment_start = url.find(\"#\");\n    if (fragment_start != std::string::npos) {\n        return url.substr(fragment_start + 1);\n    }\n    return \"\";\n}\n",
  "UrlPath": "\n#include <algorithm>\n#include <cctype>\n#include <sstream>\n#include <iomanip>\n#include <locale>\n#include <codecvt>\n\n#include <string>\n#include <vector>\n\nclass UrlPath {\npublic:\n    UrlPath();\n\n    void add(const std::string& segment);\n    void parse(const std::string& path, const std::string& charset);\n    static std::string fix_path(const std::string& path);\n\n    const std::vector<std::string>& get_segments() const;\n    bool with_end_tag() const;\n\nprivate:\n    std::vector<std::string> segments;\n    bool _with_end_tag;\n};\n\n\nUrlPath::UrlPath() : _with_end_tag(false) {}\n\nvoid UrlPath::add(const std::string& segment) {\n    segments.push_back(fix_path(segment));\n}\n\nvoid UrlPath::parse(const std::string& path, const std::string& charset) {\n    if (!path.empty()) {\n        if (path.back() == '/') {\n            _with_end_tag = true;\n        }\n\n        std::string fixed_path = fix_path(path);\n        if (!fixed_path.empty()) {\n            std::istringstream ss(fixed_path);\n            std::string segment;\n            while (std::getline(ss, segment, '/')) {\n                std::string decoded_seg;\n                std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n                std::wstring wide_segment = converter.from_bytes(segment);\n                for (wchar_t ch : wide_segment) {\n                    if (ch == '%') {\n\n                    }\n                    else {\n                        decoded_seg.push_back(static_cast<char>(ch));\n                    }\n                }\n                segments.push_back(decoded_seg);\n            }\n        }\n    }\n}\n\nstd::string UrlPath::fix_path(const std::string& path) {\n    if (path.empty()) {\n        return \"\";\n    }\n\n    std::string segment_str = path;\n    if (segment_str.front() == '/') {\n        segment_str.erase(segment_str.begin());\n    }\n    if (segment_str.back() == '/') {\n        segment_str.pop_back();\n    }\n    return segment_str;\n}\n\nconst std::vector<std::string>& UrlPath::get_segments() const {\n    return segments;\n}\n\nbool UrlPath::with_end_tag() const {\n    return _with_end_tag;\n}\n",
  "UserLoginDB": "\n#include <stdexcept>\n#include <tuple>\n\n#include <winsqlite/winsqlite3.h>\n#include <string>\n#include <memory>\n\nclass UserLoginDB {\npublic:\n    explicit UserLoginDB(const std::string& db_name);\n    ~UserLoginDB();\n\n    void insert_user(const std::string& username, const std::string& password);\n    std::unique_ptr<std::tuple<std::string, std::string>> search_user_by_username(const std::string& username);\n    void delete_user_by_username(const std::string& username);\n    bool validate_user_login(const std::string& username, const std::string& password);\n\n    void close_connection();\n    void create_table();\n\nprivate:\n    sqlite3* connection;\n    sqlite3_stmt* stmt;\n    void prepare_statement(const std::string& query);\n    void finalize_statement();\n};\n\nUserLoginDB::UserLoginDB(const std::string& db_name) : connection(nullptr), stmt(nullptr) {\n    if (sqlite3_open(db_name.c_str(), &connection) != SQLITE_OK) {\n        throw std::runtime_error(\"Cannot open database: \" + std::string(sqlite3_errmsg(connection)));\n    }\n    create_table(); \n}\n\nUserLoginDB::~UserLoginDB() {\n    finalize_statement();\n    if (connection) {\n        sqlite3_close(connection);\n    }\n}\n\nvoid UserLoginDB::prepare_statement(const std::string& query) {\n    finalize_statement();\n    if (sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(\"Failed to prepare statement: \" + std::string(sqlite3_errmsg(connection)));\n    }\n}\n\nvoid UserLoginDB::finalize_statement() {\n    if (stmt) {\n        sqlite3_finalize(stmt);\n        stmt = nullptr;\n    }\n}\n\nvoid UserLoginDB::insert_user(const std::string& username, const std::string& password) {\n    prepare_statement(\"INSERT INTO users (username, password) VALUES (?, ?)\");\n    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);\n    sqlite3_bind_text(stmt, 2, password.c_str(), -1, SQLITE_STATIC);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(\"Failed to insert user: \" + std::string(sqlite3_errmsg(connection)));\n    }\n    finalize_statement();\n}\n\nstd::unique_ptr<std::tuple<std::string, std::string>> UserLoginDB::search_user_by_username(const std::string& username) {\n    prepare_statement(\"SELECT username, password FROM users WHERE username = ?\");\n    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);\n    std::unique_ptr<std::tuple<std::string, std::string>> user = nullptr;\n    if (sqlite3_step(stmt) == SQLITE_ROW) {\n        user = std::make_unique<std::tuple<std::string, std::string>>(\n            std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0))),\n            std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1)))\n        );\n    }\n    finalize_statement();\n    return user;\n}\n\nvoid UserLoginDB::delete_user_by_username(const std::string& username) {\n    prepare_statement(\"DELETE FROM users WHERE username = ?\");\n    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\n        throw std::runtime_error(\"Failed to delete user: \" + std::string(sqlite3_errmsg(connection)));\n    }\n    finalize_statement();\n}\n\nbool UserLoginDB::validate_user_login(const std::string& username, const std::string& password) {\n    auto user = search_user_by_username(username);\n    if (user && std::get<1>(*user) == password) {\n        return true;\n    }\n    return false;\n}\n\nvoid UserLoginDB::create_table() {\n    const char* create_table_query = R\"(\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT,\n            password TEXT\n        )\n    )\";\n    if (sqlite3_exec(connection, create_table_query, nullptr, nullptr, nullptr) != SQLITE_OK) {\n        throw std::runtime_error(\"Cannot create table: \" + std::string(sqlite3_errmsg(connection)));\n    }\n}\n\nvoid UserLoginDB::close_connection() {\n    if (connection) {\n        sqlite3_close(connection);\n        connection = nullptr;\n    }\n}\n",
  "VectorUtil": "\n#include <cmath>\n#include <stdexcept>\n\n#include <array>\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nclass VectorUtil {\npublic:\n    template<size_t N>\n    static double similarity(const std::array<double, N>& vector_1, const std::array<double, N>& vector_2);\n\n    template<size_t N>\n    static std::vector<double> cosine_similarities(const std::array<double, N>& vector_1,\n        const std::vector<std::array<double, N>>& vectors_all);\n\n    template<size_t N>\n    static double n_similarity(const std::vector<std::array<double, N>>& vector_list_1,\n        const std::vector<std::array<double, N>>& vector_list_2);\n\n    static std::unordered_map<std::string, double> compute_idf_weight_dict(int total_num,\n        const std::unordered_map<std::string, double>& number_dict);\n\nprivate:\n    template<size_t N>\n    static double norm(const std::array<double, N>& vec);\n\n    template<size_t N>\n    static std::array<double, N> normalize(const std::array<double, N>& vec);\n};\n\n\ntemplate<size_t N>\ndouble VectorUtil::norm(const std::array<double, N>& vec) {\n    double sum = 0.0;\n    for (double val : vec) {\n        sum += val * val;\n    }\n    return std::sqrt(sum);\n}\n\n\ntemplate<size_t N>\nstd::array<double, N> VectorUtil::normalize(const std::array<double, N>& vec) {\n    std::array<double, N> normalized = {};\n    double vec_norm = norm(vec);\n    if (vec_norm == 0.0) {\n        return normalized; \n    }\n    for (size_t i = 0; i < N; ++i) {\n        normalized[i] = vec[i] / vec_norm;\n    }\n    return normalized;\n}\n\n\ntemplate<size_t N>\ndouble VectorUtil::similarity(const std::array<double, N>& vector_1, const std::array<double, N>& vector_2) {\n    auto norm_vec1 = normalize(vector_1);\n    auto norm_vec2 = normalize(vector_2);\n    double dot_product = 0.0;\n    for (size_t i = 0; i < N; ++i) {\n        dot_product += norm_vec1[i] * norm_vec2[i];\n    }\n    return dot_product;\n}\n\n\ntemplate<size_t N>\nstd::vector<double> VectorUtil::cosine_similarities(const std::array<double, N>& vector_1,\n    const std::vector<std::array<double, N>>& vectors_all) {\n    std::vector<double> similarities;\n    double norm_vec1 = norm(vector_1);\n\n    for (const auto& vec : vectors_all) {\n        double norm_vec_all = norm(vec);\n        if (norm_vec_all == 0.0) {\n            similarities.push_back(0.0); \n            continue;\n        }\n        double dot_product = 0.0;\n        for (size_t i = 0; i < N; ++i) {\n            dot_product += vec[i] * vector_1[i];\n        }\n        double similarity = dot_product / (norm_vec1 * norm_vec_all);\n        similarities.push_back(similarity);\n    }\n    return similarities;\n}\n\n\ntemplate<size_t N>\ndouble VectorUtil::n_similarity(const std::vector<std::array<double, N>>& vector_list_1,\n    const std::vector<std::array<double, N>>& vector_list_2) {\n    if (vector_list_1.empty() || vector_list_2.empty()) {\n        throw std::invalid_argument(\"At least one of the lists is empty.\");\n    }\n\n    std::array<double, N> mean_vec1 = {};\n    std::array<double, N> mean_vec2 = {};\n\n    for (const auto& vec : vector_list_1) {\n        for (size_t i = 0; i < N; ++i) {\n            mean_vec1[i] += vec[i];\n        }\n    }\n    for (const auto& vec : vector_list_2) {\n        for (size_t i = 0; i < N; ++i) {\n            mean_vec2[i] += vec[i];\n        }\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        mean_vec1[i] /= vector_list_1.size();\n        mean_vec2[i] /= vector_list_2.size();\n    }\n\n    return similarity(mean_vec1, mean_vec2);\n}\n\n\nstd::unordered_map<std::string, double> VectorUtil::compute_idf_weight_dict(int total_num,\n    const std::unordered_map<std::string, double>& number_dict) {\n    std::unordered_map<std::string, double> result;\n    std::unordered_map<int, std::string> index_2_key_map;\n    std::vector<double> count_list;\n    int index = 0;\n\n    for (const auto& [key, count] : number_dict) {\n        index_2_key_map[index] = key;\n        count_list.push_back(count);\n        ++index;\n    }\n\n    std::vector<double> a(count_list.size());\n    for (size_t i = 0; i < count_list.size(); ++i) {\n        a[i] = std::log((total_num + 1.0) / (count_list[i] + 1.0));\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        result[index_2_key_map[i]] = a[i];\n    }\n\n    return result;\n}\n\n\ntemplate double VectorUtil::similarity(const std::array<double, 2>& vector_1, const std::array<double, 2>& vector_2);\ntemplate double VectorUtil::similarity(const std::array<double, 8>& vector_1, const std::array<double, 8>& vector_2);\ntemplate std::vector<double> VectorUtil::cosine_similarities(const std::array<double, 2>& vector_1,\n    const std::vector<std::array<double, 2>>& vectors_all);\ntemplate std::vector<double> VectorUtil::cosine_similarities(const std::array<double, 8>& vector_1,\n    const std::vector<std::array<double, 8>>& vectors_all);\ntemplate double VectorUtil::n_similarity(const std::vector<std::array<double, 2>>& vector_list_1,\n    const std::vector<std::array<double, 2>>& vector_list_2);\ntemplate double VectorUtil::n_similarity(const std::vector<std::array<double, 8>>& vector_list_1,\n    const std::vector<std::array<double, 8>>& vector_list_2);\n",
  "VendingMachine": "\n#include <sstream>\n\n#include <string>\n#include <unordered_map>\n\nclass VendingMachine {\npublic:\n    VendingMachine();\n    void add_item(const std::string& item_name, double price, int quantity);\n    double insert_coin(double amount);\n    double purchase_item(const std::string& item_name);\n    bool restock_item(const std::string& item_name, int quantity);\n    std::string display_items() const;\n    std::unordered_map<std::string, std::unordered_map<std::string, double>> inventory() const;\n    void set_inventory(std::unordered_map<std::string, std::unordered_map<std::string, double>> x);\n    void set_balance(double y);\n\nprivate:\n    std::unordered_map<std::string, std::unordered_map<std::string, double>> inventory_;\n    double balance_;\n};\n\nVendingMachine::VendingMachine() : balance_(0) {}\n\nvoid VendingMachine::add_item(const std::string& item_name, double price, int quantity) {\n    if (!restock_item(item_name, quantity)) {\n        inventory_[item_name] = { {\"price\", price}, {\"quantity\", static_cast<double>(quantity)} };\n    }\n}\n\ndouble VendingMachine::insert_coin(double amount) {\n    balance_ += amount;\n    return balance_;\n}\n\ndouble VendingMachine::purchase_item(const std::string& item_name) {\n    if (inventory_.count(item_name)) {\n        auto& item = inventory_[item_name];\n        if (item[\"quantity\"] > 0 && balance_ >= item[\"price\"]) {\n            balance_ -= item[\"price\"];\n            item[\"quantity\"] -= 1;\n            return balance_;\n        }\n    }\n    return false;\n}\n\nbool VendingMachine::restock_item(const std::string& item_name, int quantity) {\n    if (inventory_.count(item_name)) {\n        inventory_[item_name][\"quantity\"] += static_cast<double>(quantity);\n        return true;\n    }\n    return false;\n}\n\nstd::string VendingMachine::display_items() const {\n    if (inventory_.empty()) {\n        return \"false\";\n    }\n\n    std::ostringstream oss;\n    for (const auto& item : inventory_) {\n        oss << item.first << \" - $\" << item.second.at(\"price\") << \" [\" << item.second.at(\"quantity\") << \"]\\n\";\n    }\n\n    std::string result = oss.str();\n    result.pop_back(); \n    return result;\n}\n\nstd::unordered_map<std::string, std::unordered_map<std::string, double>> VendingMachine::inventory() const {\n    return inventory_;\n}\n\nvoid VendingMachine::set_inventory(std::unordered_map<std::string, std::unordered_map<std::string, double>> x)\n{\n    this->inventory_ = x;\n}\n\nvoid VendingMachine::set_balance(double y)\n{\n    this->balance_ = y;\n}",
  "Warehouse": "#include <map>\n#include <string>\n\nclass Warehouse {\npublic:\n    Warehouse();\n\n    void add_product(int product_id, const std::string& name, int quantity);\n    void update_product_quantity(int product_id, int quantity);\n    int get_product_quantity(int product_id) const;\n    bool create_order(int order_id, int product_id, int quantity);\n    bool change_order_status(int order_id, const std::string& status);\n    std::string track_order(int order_id) const;\n\n    \n    const std::map<int, std::map<std::string, std::string>>& orders() const;\n    const std::map<int, std::map<std::string, std::string>>& inventory() const;\n\nprivate:\n    std::map<int, std::map<std::string, std::string>> inventory_;\n    std::map<int, std::map<std::string, std::string>> orders_;\n};\nWarehouse::Warehouse() {}\n\nvoid Warehouse::add_product(int product_id, const std::string& name, int quantity) {\n    auto& product = inventory_[product_id];\n    if (product.empty()) {\n        product[\"name\"] = name;\n        product[\"quantity\"] = std::to_string(quantity);\n    }\n    else {\n        int current_quantity = std::stoi(product[\"quantity\"]);\n        product[\"quantity\"] = std::to_string(current_quantity + quantity);\n    }\n}\n\nvoid Warehouse::update_product_quantity(int product_id, int quantity) {\n    auto it = inventory_.find(product_id);\n    if (it != inventory_.end()) {\n        int current_quantity = std::stoi(it->second[\"quantity\"]);\n        it->second[\"quantity\"] = std::to_string(current_quantity + quantity);\n    }\n}\n\nint Warehouse::get_product_quantity(int product_id) const {\n    auto it = inventory_.find(product_id);\n    if (it != inventory_.end()) {\n        return std::stoi(it->second.at(\"quantity\"));\n    }\n    return false;  \n}\n\nbool Warehouse::create_order(int order_id, int product_id, int quantity) {\n    int available_quantity = get_product_quantity(product_id);\n    if (available_quantity >= quantity) {\n        update_product_quantity(product_id, -quantity);\n        orders_[order_id] = {\n            {\"product_id\", std::to_string(product_id)},\n            {\"quantity\", std::to_string(quantity)},\n            {\"status\", \"Shipped\"}\n        };\n        return true;\n    }\n    return false;\n}\n\nbool Warehouse::change_order_status(int order_id, const std::string& status) {\n    auto it = orders_.find(order_id);\n    if (it != orders_.end()) {\n        it->second[\"status\"] = status;\n        return true;\n    }\n    return false;\n}\n\nstd::string Warehouse::track_order(int order_id) const {\n    auto it = orders_.find(order_id);\n    if (it != orders_.end()) {\n        return it->second.at(\"status\");\n    }\n    return \"\";  \n}\n\nconst std::map<int, std::map<std::string, std::string>>& Warehouse::orders() const {\n    return orders_;\n}\n\nconst std::map<int, std::map<std::string, std::string>>& Warehouse::inventory() const {\n    return inventory_;\n}\n",
  "WeatherSystem": "#include <string>\n#include <map>\n\n\nstruct WeatherInfo {\n    std::string weather;\n    double temperature;\n    std::string temperature_units;\n};\n\nclass WeatherSystem {\npublic:\n    WeatherSystem(const std::string& city);\n\n    std::pair<double, std::string> query(const std::map<std::string, WeatherInfo>& weather_list, const std::string& tmp_units = \"celsius\");\n    void set_city(const std::string& city);\n    void set_temperature(double temperature);\n\n    double celsius_to_fahrenheit() const;\n    double fahrenheit_to_celsius() const;\n\n    std::string get_city() const;\n\nprivate:\n    double temperature;\n    std::string weather;\n    std::string city;\n    std::map<std::string, WeatherInfo> weather_list;\n};\n\n\n\nWeatherSystem::WeatherSystem(const std::string& city) : city(city), temperature(0.0), weather(\"\") {}\n\n\nstd::pair<double, std::string> WeatherSystem::query(const std::map<std::string, WeatherInfo>& weather_list, const std::string& tmp_units) {\n    this->weather_list = weather_list;\n    auto it = this->weather_list.find(this->city);\n    if (it == this->weather_list.end()) {\n        return { 0.0, \"\" };\n    }\n    else {\n        this->temperature = it->second.temperature;\n        this->weather = it->second.weather;\n    }\n\n    if (it->second.temperature_units != tmp_units) {\n        if (tmp_units == \"celsius\") {\n            return { fahrenheit_to_celsius(), this->weather };\n        }\n        else if (tmp_units == \"fahrenheit\") {\n            return { celsius_to_fahrenheit(), this->weather };\n        }\n    }\n    else {\n        return { this->temperature, this->weather };\n    }\n}\n\n\nvoid WeatherSystem::set_city(const std::string& city) {\n    this->city = city;\n}\n\n\nvoid WeatherSystem::set_temperature(double temperature) {\n    this->temperature = temperature;\n}\n\n\ndouble WeatherSystem::celsius_to_fahrenheit() const {\n    return (this->temperature * 9 / 5) + 32;\n}\n\n\ndouble WeatherSystem::fahrenheit_to_celsius() const {\n    return (this->temperature - 32) * 5 / 9;\n}\n\n\nstd::string WeatherSystem::get_city() const {\n    return this->city;\n}\n",
  "Words2Numbers": "#include <sstream>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n#include <stdexcept>\n\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nclass Words2Numbers {\npublic:\n    Words2Numbers();\n    std::string text2int(const std::string& textnum);\n    bool is_valid_input(const std::string& textnum) const;\n\nprivate:\n    std::unordered_map<std::string, std::pair<int, int>> numwords;\n    std::vector<std::string> units;\n    std::vector<std::string> tens;\n    std::vector<std::string> scales;\n    std::unordered_map<std::string, int> ordinal_words;\n    std::vector<std::pair<std::string, std::string>> ordinal_endings;\n};\n\n\nWords2Numbers::Words2Numbers() {\n    units = { \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n             \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\",\n             \"eighteen\", \"nineteen\" };\n\n    tens = { \"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n\n    scales = { \"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\" };\n\n    numwords[\"and\"] = { 1, 0 };\n    for (size_t idx = 0; idx < units.size(); ++idx) {\n        numwords[units[idx]] = { 1, static_cast<int>(idx) };\n    }\n    for (size_t idx = 0; idx < tens.size(); ++idx) {\n        numwords[tens[idx]] = { 1, static_cast<int>(idx) * 10 };\n    }\n    for (size_t idx = 0; idx < scales.size(); ++idx) {\n        numwords[scales[idx]] = { static_cast<int>(std::pow(10, idx * 3)), 0 };\n    }\n    numwords[\"hundred\"] = { 100,0 };\n    ordinal_words = { {\"first\", 1}, {\"second\", 2}, {\"third\", 3}, {\"fifth\", 5}, {\"eighth\", 8},\n                     {\"ninth\", 9}, {\"twelfth\", 12} };\n    ordinal_endings = { {\"ieth\", \"y\"}, {\"th\", \"\"} };\n}\n\nstd::string Words2Numbers::text2int(const std::string& textnum) {\n    std::string text = textnum;\n    std::replace(text.begin(), text.end(), '-', ' ');\n\n    int current = 0, result = 0;\n    std::string curstring;\n\n    std::istringstream iss(text);\n    std::string word;\n    while (iss >> word) {\n        auto it = ordinal_words.find(word);\n        if (it != ordinal_words.end()) {\n            int scale = 1, increment = it->second;\n            current = current * scale + increment;\n        }\n        else {\n            for (const auto& ending : ordinal_endings) {\n                if (word.size() > ending.first.size() &&\n                    word.compare(word.size() - ending.first.size(), ending.first.size(), ending.first) == 0) {\n                    word = word.substr(0, word.size() - ending.first.size()) + ending.second;\n                }\n            }\n\n            auto numword_it = numwords.find(word);\n            if (numword_it == numwords.end()) {\n                if (current > 0) {\n                    result += current;\n                    current = 0;\n                }\n                curstring += word + \" \";\n            }\n            else {\n                auto [scale, increment] = numword_it->second;\n                if (scale == 1) {\n                    current += increment;\n                }\n                else {\n                    current *= scale;\n                    result += current;\n                    current = 0;\n                }\n            }\n        }\n    }\n\n    if (current > 0) {\n        result += current;\n    }\n\n    curstring += std::to_string(result);\n    return curstring;\n}\n\nbool Words2Numbers::is_valid_input(const std::string& textnum) const {\n    std::string text = textnum;\n    std::replace(text.begin(), text.end(), '-', ' ');\n\n    std::istringstream iss(text);\n    std::string word;\n    while (iss >> word) {\n        if (ordinal_words.find(word) != ordinal_words.end()) {\n            continue;\n        }\n        else {\n            for (const auto& ending : ordinal_endings) {\n                if (word.size() > ending.first.size() &&\n                    word.compare(word.size() - ending.first.size(), ending.first.size(), ending.first) == 0) {\n                    word = word.substr(0, word.size() - ending.first.size()) + ending.second;\n                }\n            }\n\n            if (numwords.find(word) == numwords.end()) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n",
  "XMLProcessor": "\n#include <algorithm>\n#include <iostream>\n\n#include <string>\n#include <vector>\n#include \"tinyxml.h\"\n\nclass XMLProcessor {\npublic:\n    XMLProcessor(const std::string& file_name);\n    TiXmlNode* read_xml();\n    bool write_xml(const std::string& file_name);\n    bool process_xml_data(const std::string& file_name);\n    std::vector<TiXmlElement*> find_element(const std::string& element_name);\n\n    std::string file_name;\n    TiXmlDocument doc;\n};\n\nXMLProcessor::XMLProcessor(const std::string& file_name) : file_name(file_name) {}\n\nTiXmlNode* XMLProcessor::read_xml() {\n    if (!doc.LoadFile(file_name.c_str())) {\n        std::cerr << \"Error: Could not load XML file: \" << file_name << std::endl;\n        return nullptr;\n    }\n    return doc.RootElement();\n}\n\nbool XMLProcessor::write_xml(const std::string& file_name) {\n    return doc.SaveFile(file_name.c_str());\n}\n\nbool XMLProcessor::process_xml_data(const std::string& file_name) {\n    TiXmlElement* root = doc.RootElement();\n    if (root == nullptr) {\n        std::cerr << \"Error: No root element found.\" << std::endl;\n        return false;\n    }\n\n    for (TiXmlElement* element = root->FirstChildElement(\"item\"); element != nullptr; element = element->NextSiblingElement(\"item\")) {\n        const char* text = element->GetText();\n        if (text) {\n            std::string upper_text(text);\n            std::transform(upper_text.begin(), upper_text.end(), upper_text.begin(), ::toupper);\n            element->Clear(); \n            element->LinkEndChild(new TiXmlText(upper_text.c_str())); \n        }\n    }\n    return write_xml(file_name);\n}\n\nstd::vector<TiXmlElement*> XMLProcessor::find_element(const std::string& element_name) {\n    std::vector<TiXmlElement*> elements;\n    TiXmlElement* root = doc.RootElement();\n    if (root == nullptr) return elements;\n\n    for (TiXmlElement* element = root->FirstChildElement(element_name.c_str()); element != nullptr; element = element->NextSiblingElement(element_name.c_str())) {\n        elements.push_back(element);\n    }\n    return elements;\n}\n",
  "ZipFileProcessor": "\n#include <boost/iostreams/device/file.hpp>\n#include <boost/iostreams/filtering_stream.hpp>\n#include <boost/iostreams/filtering_streambuf.hpp>\n#include <fstream>\n#include <iostream>\n\n#include <string>\n#include <vector>\n#include <boost/filesystem.hpp>\n#include <zip.h>\n\nstruct ZipFileInfo {\n    std::string filename;\n    std::string mode;\n};\n\nclass ZipFileProcessor {\npublic:\n    explicit ZipFileProcessor(const std::string& zip_file_path);\n\n    bool extract_all(const std::string& output_directory);\n    bool extract_file(const std::string& file_name, const std::string& output_directory);\n    bool create_zip_file(const std::vector<std::string>& files, const std::string& output_zip_file);\n    ZipFileInfo read_zip_file();  \n\nprivate:\n    bool extract_file_from_zip(zip_t* archive, zip_int64_t index, const std::string& output_file_path);\n    bool create_directory_if_not_exists(const std::string& dir_path);\n    zip_t* open_zip_file(int flags);\n\n    std::string zip_file_path_;\n};\n\n\nZipFileProcessor::ZipFileProcessor(const std::string& zip_file_path)\n    : zip_file_path_(zip_file_path) {}\n\nZipFileInfo ZipFileProcessor::read_zip_file() {\n    zip_t* archive = open_zip_file(ZIP_RDONLY);\n    ZipFileInfo info;\n    if (archive) {\n        info.filename = zip_file_path_;  \n        info.mode = \"r\";  \n        zip_close(archive);\n    }\n    return info;\n}\n\n\nbool ZipFileProcessor::extract_all(const std::string& output_directory) {\n    \n    if (output_directory.empty()) {\n        return false; \n    }\n    \n    if (!create_directory_if_not_exists(output_directory)) {\n        \n        return false;\n    }\n\n    \n    zip_t* archive = open_zip_file(ZIP_RDONLY);\n    if (!archive) return false;\n\n    \n    bool success = true;\n    zip_int64_t num_entries = zip_get_num_entries(archive, ZIP_FL_UNCHANGED);\n    for (zip_int64_t i = 0; i < num_entries; ++i) {\n        zip_stat_t stat;\n        if (zip_stat_index(archive, i, ZIP_FL_ENC_UTF_8, &stat) == 0) {\n            std::string output_file_path = output_directory + \"/\" + stat.name;\n            if (!extract_file_from_zip(archive, i, output_file_path)) {\n                success = false;\n            }\n        }\n    }\n\n    zip_close(archive);\n    return success;\n}\n\nbool ZipFileProcessor::extract_file(const std::string& file_name, const std::string& output_directory) {\n    \n    if (output_directory.empty()) {\n        return false;\n    }\n\n    if (!create_directory_if_not_exists(output_directory)) {\n        std::cerr << \"Failed to create output directory: \" << output_directory << std::endl;\n        return false;\n    }\n\n    \n    zip_t* archive = open_zip_file(ZIP_RDONLY);\n    if (!archive) return false;\n\n    \n    zip_int64_t index = zip_name_locate(archive, file_name.c_str(), ZIP_FL_ENC_UTF_8);\n    if (index < 0) {\n        std::cerr << \"File not found in zip: \" << file_name << std::endl;\n        zip_close(archive);\n        return false;\n    }\n\n    std::string output_file_path = output_directory + \"/\" + file_name;\n    bool success = extract_file_from_zip(archive, index, output_file_path);\n\n    zip_close(archive);\n    return success;\n}\n\nbool ZipFileProcessor::create_zip_file(const std::vector<std::string>& files, const std::string& output_zip_file) {\n    zip_t* archive = zip_open(output_zip_file.c_str(), ZIP_CREATE | ZIP_TRUNCATE, nullptr);\n    if (!archive) {\n        std::cerr << \"Error opening zip file: \" << output_zip_file << std::endl;\n        return false;\n    }\n\n    for (const auto& file_path : files) {\n        zip_source_t* source = zip_source_file(archive, file_path.c_str(), 0, 0);\n        if (!source) {\n            std::cerr << \"Error creating zip source for file: \" << file_path << std::endl;\n            zip_close(archive);\n            return false;\n        }\n        \n        if (zip_file_add(archive, file_path.c_str(), source, ZIP_FL_ENC_UTF_8) < 0) {\n            std::cerr << \"Error adding file to zip: \" << file_path << std::endl;\n            zip_source_free(source);\n            zip_close(archive);\n            return false;\n        }\n    }\n\n    if (zip_close(archive) < 0) {\n        std::cerr << \"Error closing zip file: \" << output_zip_file << std::endl;\n        return false;\n    }\n\n    return true;\n}\n\n\nbool ZipFileProcessor::extract_file_from_zip(zip_t* archive, zip_int64_t index, const std::string& output_file_path) {\n    zip_file_t* file = zip_fopen(archive, zip_get_name(archive, index, ZIP_FL_ENC_UTF_8), ZIP_FL_UNCHANGED);\n    if (!file) {\n        std::cerr << \"Failed to open file in zip: \" << zip_get_name(archive, index, ZIP_FL_ENC_UTF_8) << std::endl;\n        return false;\n    }\n\n    std::ofstream out_file(output_file_path, std::ios::binary);\n    if (!out_file.is_open()) {\n        std::cerr << \"Failed to open output file: \" << output_file_path << std::endl;\n        zip_fclose(file);\n        return false;\n    }\n\n    char buffer[4096];\n    zip_int64_t bytes_read;\n    while ((bytes_read = zip_fread(file, buffer, sizeof(buffer))) > 0) {\n        out_file.write(buffer, bytes_read);\n        if (!out_file) {\n            std::cerr << \"Failed to write to file: \" << output_file_path << std::endl;\n            zip_fclose(file);\n            return false;\n        }\n    }\n\n    zip_fclose(file);\n    return true;\n}\n\nbool ZipFileProcessor::create_directory_if_not_exists(const std::string& dir_path) {\n    namespace fs = boost::filesystem;\n    if (!fs::exists(dir_path)) {\n        return fs::create_directories(dir_path);\n    }\n    return true;\n}\n\n\n\nzip_t* ZipFileProcessor::open_zip_file(int flags) {\n    zip_t* archive = zip_open(zip_file_path_.c_str(), flags, nullptr);\n    if (!archive) {\n        std::cerr << \"Failed to open zip file: \" << zip_file_path_ << std::endl;\n    }\n    return archive;\n}\n"
}